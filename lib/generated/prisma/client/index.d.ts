
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model UserAggregate
 * 
 */
export type UserAggregate = $Result.DefaultSelection<Prisma.$UserAggregatePayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Thema
 * 
 */
export type Thema = $Result.DefaultSelection<Prisma.$ThemaPayload>
/**
 * Model Epic
 * 
 */
export type Epic = $Result.DefaultSelection<Prisma.$EpicPayload>
/**
 * Model UserStory
 * 
 */
export type UserStory = $Result.DefaultSelection<Prisma.$UserStoryPayload>
/**
 * Model Sprint
 * 
 */
export type Sprint = $Result.DefaultSelection<Prisma.$SprintPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Subtask
 * 
 */
export type Subtask = $Result.DefaultSelection<Prisma.$SubtaskPayload>
/**
 * Model Folder
 * 
 */
export type Folder = $Result.DefaultSelection<Prisma.$FolderPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model Dependency
 * 
 */
export type Dependency = $Result.DefaultSelection<Prisma.$DependencyPayload>
/**
 * Model FileRelation
 * 
 */
export type FileRelation = $Result.DefaultSelection<Prisma.$FileRelationPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model TimeLog
 * 
 */
export type TimeLog = $Result.DefaultSelection<Prisma.$TimeLogPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  READER: 'READER',
  AUTHOR: 'AUTHOR',
  DEV: 'DEV',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Status: {
  TODO: 'TODO',
  IN_PROGRESS: 'IN_PROGRESS',
  REVIEW: 'REVIEW',
  DONE: 'DONE',
  BLOCKED: 'BLOCKED',
  CANCELLED: 'CANCELLED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const FileType: {
  DOCUMENT: 'DOCUMENT',
  IMAGE: 'IMAGE',
  SPREADSHEET: 'SPREADSHEET',
  PRESENTATION: 'PRESENTATION',
  ARCHIVE: 'ARCHIVE',
  CODE: 'CODE',
  OTHER: 'OTHER'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const ActionType: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type ActionType = (typeof ActionType)[keyof typeof ActionType]


export const RelationType: {
  IMPORT: 'IMPORT',
  REFERENCE: 'REFERENCE',
  OTHER: 'OTHER'
};

export type RelationType = (typeof RelationType)[keyof typeof RelationType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

export type ActionType = $Enums.ActionType

export const ActionType: typeof $Enums.ActionType

export type RelationType = $Enums.RelationType

export const RelationType: typeof $Enums.RelationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAggregate`: Exposes CRUD operations for the **UserAggregate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAggregates
    * const userAggregates = await prisma.userAggregate.findMany()
    * ```
    */
  get userAggregate(): Prisma.UserAggregateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.thema`: Exposes CRUD operations for the **Thema** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Themas
    * const themas = await prisma.thema.findMany()
    * ```
    */
  get thema(): Prisma.ThemaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.epic`: Exposes CRUD operations for the **Epic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Epics
    * const epics = await prisma.epic.findMany()
    * ```
    */
  get epic(): Prisma.EpicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userStory`: Exposes CRUD operations for the **UserStory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStories
    * const userStories = await prisma.userStory.findMany()
    * ```
    */
  get userStory(): Prisma.UserStoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sprint`: Exposes CRUD operations for the **Sprint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sprints
    * const sprints = await prisma.sprint.findMany()
    * ```
    */
  get sprint(): Prisma.SprintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subtask`: Exposes CRUD operations for the **Subtask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subtasks
    * const subtasks = await prisma.subtask.findMany()
    * ```
    */
  get subtask(): Prisma.SubtaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.folder`: Exposes CRUD operations for the **Folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folders
    * const folders = await prisma.folder.findMany()
    * ```
    */
  get folder(): Prisma.FolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dependency`: Exposes CRUD operations for the **Dependency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dependencies
    * const dependencies = await prisma.dependency.findMany()
    * ```
    */
  get dependency(): Prisma.DependencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileRelation`: Exposes CRUD operations for the **FileRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileRelations
    * const fileRelations = await prisma.fileRelation.findMany()
    * ```
    */
  get fileRelation(): Prisma.FileRelationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeLog`: Exposes CRUD operations for the **TimeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeLogs
    * const timeLogs = await prisma.timeLog.findMany()
    * ```
    */
  get timeLog(): Prisma.TimeLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    UserAggregate: 'UserAggregate',
    Project: 'Project',
    Member: 'Member',
    Thema: 'Thema',
    Epic: 'Epic',
    UserStory: 'UserStory',
    Sprint: 'Sprint',
    Task: 'Task',
    Subtask: 'Subtask',
    Folder: 'Folder',
    File: 'File',
    Dependency: 'Dependency',
    FileRelation: 'FileRelation',
    Comment: 'Comment',
    TimeLog: 'TimeLog',
    ActivityLog: 'ActivityLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "userAggregate" | "project" | "member" | "thema" | "epic" | "userStory" | "sprint" | "task" | "subtask" | "folder" | "file" | "dependency" | "fileRelation" | "comment" | "timeLog" | "activityLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      UserAggregate: {
        payload: Prisma.$UserAggregatePayload<ExtArgs>
        fields: Prisma.UserAggregateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAggregateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAggregatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAggregateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAggregatePayload>
          }
          findFirst: {
            args: Prisma.UserAggregateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAggregatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAggregateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAggregatePayload>
          }
          findMany: {
            args: Prisma.UserAggregateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAggregatePayload>[]
          }
          create: {
            args: Prisma.UserAggregateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAggregatePayload>
          }
          createMany: {
            args: Prisma.UserAggregateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAggregateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAggregatePayload>[]
          }
          delete: {
            args: Prisma.UserAggregateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAggregatePayload>
          }
          update: {
            args: Prisma.UserAggregateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAggregatePayload>
          }
          deleteMany: {
            args: Prisma.UserAggregateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAggregateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAggregateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAggregatePayload>[]
          }
          upsert: {
            args: Prisma.UserAggregateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAggregatePayload>
          }
          aggregate: {
            args: Prisma.UserAggregateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAggregate>
          }
          groupBy: {
            args: Prisma.UserAggregateGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAggregateGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAggregateCountArgs<ExtArgs>
            result: $Utils.Optional<UserAggregateCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Thema: {
        payload: Prisma.$ThemaPayload<ExtArgs>
        fields: Prisma.ThemaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThemaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThemaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemaPayload>
          }
          findFirst: {
            args: Prisma.ThemaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThemaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemaPayload>
          }
          findMany: {
            args: Prisma.ThemaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemaPayload>[]
          }
          create: {
            args: Prisma.ThemaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemaPayload>
          }
          createMany: {
            args: Prisma.ThemaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThemaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemaPayload>[]
          }
          delete: {
            args: Prisma.ThemaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemaPayload>
          }
          update: {
            args: Prisma.ThemaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemaPayload>
          }
          deleteMany: {
            args: Prisma.ThemaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThemaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ThemaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemaPayload>[]
          }
          upsert: {
            args: Prisma.ThemaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemaPayload>
          }
          aggregate: {
            args: Prisma.ThemaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThema>
          }
          groupBy: {
            args: Prisma.ThemaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThemaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThemaCountArgs<ExtArgs>
            result: $Utils.Optional<ThemaCountAggregateOutputType> | number
          }
        }
      }
      Epic: {
        payload: Prisma.$EpicPayload<ExtArgs>
        fields: Prisma.EpicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EpicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EpicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpicPayload>
          }
          findFirst: {
            args: Prisma.EpicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EpicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpicPayload>
          }
          findMany: {
            args: Prisma.EpicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpicPayload>[]
          }
          create: {
            args: Prisma.EpicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpicPayload>
          }
          createMany: {
            args: Prisma.EpicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EpicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpicPayload>[]
          }
          delete: {
            args: Prisma.EpicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpicPayload>
          }
          update: {
            args: Prisma.EpicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpicPayload>
          }
          deleteMany: {
            args: Prisma.EpicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EpicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EpicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpicPayload>[]
          }
          upsert: {
            args: Prisma.EpicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpicPayload>
          }
          aggregate: {
            args: Prisma.EpicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEpic>
          }
          groupBy: {
            args: Prisma.EpicGroupByArgs<ExtArgs>
            result: $Utils.Optional<EpicGroupByOutputType>[]
          }
          count: {
            args: Prisma.EpicCountArgs<ExtArgs>
            result: $Utils.Optional<EpicCountAggregateOutputType> | number
          }
        }
      }
      UserStory: {
        payload: Prisma.$UserStoryPayload<ExtArgs>
        fields: Prisma.UserStoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserStoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserStoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStoryPayload>
          }
          findFirst: {
            args: Prisma.UserStoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserStoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStoryPayload>
          }
          findMany: {
            args: Prisma.UserStoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStoryPayload>[]
          }
          create: {
            args: Prisma.UserStoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStoryPayload>
          }
          createMany: {
            args: Prisma.UserStoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserStoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStoryPayload>[]
          }
          delete: {
            args: Prisma.UserStoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStoryPayload>
          }
          update: {
            args: Prisma.UserStoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStoryPayload>
          }
          deleteMany: {
            args: Prisma.UserStoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserStoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserStoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStoryPayload>[]
          }
          upsert: {
            args: Prisma.UserStoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStoryPayload>
          }
          aggregate: {
            args: Prisma.UserStoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserStory>
          }
          groupBy: {
            args: Prisma.UserStoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserStoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserStoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserStoryCountAggregateOutputType> | number
          }
        }
      }
      Sprint: {
        payload: Prisma.$SprintPayload<ExtArgs>
        fields: Prisma.SprintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SprintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SprintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          findFirst: {
            args: Prisma.SprintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SprintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          findMany: {
            args: Prisma.SprintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          create: {
            args: Prisma.SprintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          createMany: {
            args: Prisma.SprintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SprintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          delete: {
            args: Prisma.SprintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          update: {
            args: Prisma.SprintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          deleteMany: {
            args: Prisma.SprintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SprintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SprintUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          upsert: {
            args: Prisma.SprintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          aggregate: {
            args: Prisma.SprintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSprint>
          }
          groupBy: {
            args: Prisma.SprintGroupByArgs<ExtArgs>
            result: $Utils.Optional<SprintGroupByOutputType>[]
          }
          count: {
            args: Prisma.SprintCountArgs<ExtArgs>
            result: $Utils.Optional<SprintCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Subtask: {
        payload: Prisma.$SubtaskPayload<ExtArgs>
        fields: Prisma.SubtaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubtaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubtaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          findFirst: {
            args: Prisma.SubtaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubtaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          findMany: {
            args: Prisma.SubtaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[]
          }
          create: {
            args: Prisma.SubtaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          createMany: {
            args: Prisma.SubtaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubtaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[]
          }
          delete: {
            args: Prisma.SubtaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          update: {
            args: Prisma.SubtaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          deleteMany: {
            args: Prisma.SubtaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubtaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubtaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[]
          }
          upsert: {
            args: Prisma.SubtaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          aggregate: {
            args: Prisma.SubtaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubtask>
          }
          groupBy: {
            args: Prisma.SubtaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubtaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubtaskCountArgs<ExtArgs>
            result: $Utils.Optional<SubtaskCountAggregateOutputType> | number
          }
        }
      }
      Folder: {
        payload: Prisma.$FolderPayload<ExtArgs>
        fields: Prisma.FolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findFirst: {
            args: Prisma.FolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findMany: {
            args: Prisma.FolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          create: {
            args: Prisma.FolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          createMany: {
            args: Prisma.FolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          delete: {
            args: Prisma.FolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          update: {
            args: Prisma.FolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          deleteMany: {
            args: Prisma.FolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          upsert: {
            args: Prisma.FolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          aggregate: {
            args: Prisma.FolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolder>
          }
          groupBy: {
            args: Prisma.FolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderCountArgs<ExtArgs>
            result: $Utils.Optional<FolderCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      Dependency: {
        payload: Prisma.$DependencyPayload<ExtArgs>
        fields: Prisma.DependencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DependencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DependencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          findFirst: {
            args: Prisma.DependencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DependencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          findMany: {
            args: Prisma.DependencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>[]
          }
          create: {
            args: Prisma.DependencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          createMany: {
            args: Prisma.DependencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DependencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>[]
          }
          delete: {
            args: Prisma.DependencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          update: {
            args: Prisma.DependencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          deleteMany: {
            args: Prisma.DependencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DependencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DependencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>[]
          }
          upsert: {
            args: Prisma.DependencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          aggregate: {
            args: Prisma.DependencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDependency>
          }
          groupBy: {
            args: Prisma.DependencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DependencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DependencyCountArgs<ExtArgs>
            result: $Utils.Optional<DependencyCountAggregateOutputType> | number
          }
        }
      }
      FileRelation: {
        payload: Prisma.$FileRelationPayload<ExtArgs>
        fields: Prisma.FileRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileRelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileRelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileRelationPayload>
          }
          findFirst: {
            args: Prisma.FileRelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileRelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileRelationPayload>
          }
          findMany: {
            args: Prisma.FileRelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileRelationPayload>[]
          }
          create: {
            args: Prisma.FileRelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileRelationPayload>
          }
          createMany: {
            args: Prisma.FileRelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileRelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileRelationPayload>[]
          }
          delete: {
            args: Prisma.FileRelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileRelationPayload>
          }
          update: {
            args: Prisma.FileRelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileRelationPayload>
          }
          deleteMany: {
            args: Prisma.FileRelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileRelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileRelationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileRelationPayload>[]
          }
          upsert: {
            args: Prisma.FileRelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileRelationPayload>
          }
          aggregate: {
            args: Prisma.FileRelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileRelation>
          }
          groupBy: {
            args: Prisma.FileRelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileRelationCountArgs<ExtArgs>
            result: $Utils.Optional<FileRelationCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      TimeLog: {
        payload: Prisma.$TimeLogPayload<ExtArgs>
        fields: Prisma.TimeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          findFirst: {
            args: Prisma.TimeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          findMany: {
            args: Prisma.TimeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>[]
          }
          create: {
            args: Prisma.TimeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          createMany: {
            args: Prisma.TimeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>[]
          }
          delete: {
            args: Prisma.TimeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          update: {
            args: Prisma.TimeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          deleteMany: {
            args: Prisma.TimeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>[]
          }
          upsert: {
            args: Prisma.TimeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          aggregate: {
            args: Prisma.TimeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeLog>
          }
          groupBy: {
            args: Prisma.TimeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeLogCountArgs<ExtArgs>
            result: $Utils.Optional<TimeLogCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    userAggregate?: UserAggregateOmit
    project?: ProjectOmit
    member?: MemberOmit
    thema?: ThemaOmit
    epic?: EpicOmit
    userStory?: UserStoryOmit
    sprint?: SprintOmit
    task?: TaskOmit
    subtask?: SubtaskOmit
    folder?: FolderOmit
    file?: FileOmit
    dependency?: DependencyOmit
    fileRelation?: FileRelationOmit
    comment?: CommentOmit
    timeLog?: TimeLogOmit
    activityLog?: ActivityLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    memberships: number
    verifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
    verifications?: boolean | UserCountOutputTypeCountVerificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    themas: number
    epics: number
    userStories: number
    sprints: number
    members: number
    folders: number
    files: number
    comments: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    themas?: boolean | ProjectCountOutputTypeCountThemasArgs
    epics?: boolean | ProjectCountOutputTypeCountEpicsArgs
    userStories?: boolean | ProjectCountOutputTypeCountUserStoriesArgs
    sprints?: boolean | ProjectCountOutputTypeCountSprintsArgs
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    folders?: boolean | ProjectCountOutputTypeCountFoldersArgs
    files?: boolean | ProjectCountOutputTypeCountFilesArgs
    comments?: boolean | ProjectCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountThemasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemaWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountEpicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpicWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountUserStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStoryWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SprintWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    files: number
    tasks: number
    subtasks: number
    comments: number
    timeLogs: number
    userStories: number
    themas: number
    epics: number
    sprints: number
    activities: number
    createdProjects: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | MemberCountOutputTypeCountFilesArgs
    tasks?: boolean | MemberCountOutputTypeCountTasksArgs
    subtasks?: boolean | MemberCountOutputTypeCountSubtasksArgs
    comments?: boolean | MemberCountOutputTypeCountCommentsArgs
    timeLogs?: boolean | MemberCountOutputTypeCountTimeLogsArgs
    userStories?: boolean | MemberCountOutputTypeCountUserStoriesArgs
    themas?: boolean | MemberCountOutputTypeCountThemasArgs
    epics?: boolean | MemberCountOutputTypeCountEpicsArgs
    sprints?: boolean | MemberCountOutputTypeCountSprintsArgs
    activities?: boolean | MemberCountOutputTypeCountActivitiesArgs
    createdProjects?: boolean | MemberCountOutputTypeCountCreatedProjectsArgs
  }

  // Custom InputTypes
  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountUserStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStoryWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountThemasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemaWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountEpicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpicWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountSprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SprintWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountCreatedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ThemaCountOutputType
   */

  export type ThemaCountOutputType = {
    tasks: number
    comments: number
  }

  export type ThemaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ThemaCountOutputTypeCountTasksArgs
    comments?: boolean | ThemaCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ThemaCountOutputType without action
   */
  export type ThemaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemaCountOutputType
     */
    select?: ThemaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ThemaCountOutputType without action
   */
  export type ThemaCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ThemaCountOutputType without action
   */
  export type ThemaCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type EpicCountOutputType
   */

  export type EpicCountOutputType = {
    userStories: number
    comments: number
  }

  export type EpicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userStories?: boolean | EpicCountOutputTypeCountUserStoriesArgs
    comments?: boolean | EpicCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * EpicCountOutputType without action
   */
  export type EpicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EpicCountOutputType
     */
    select?: EpicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EpicCountOutputType without action
   */
  export type EpicCountOutputTypeCountUserStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStoryWhereInput
  }

  /**
   * EpicCountOutputType without action
   */
  export type EpicCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type UserStoryCountOutputType
   */

  export type UserStoryCountOutputType = {
    tasks: number
    comments: number
  }

  export type UserStoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | UserStoryCountOutputTypeCountTasksArgs
    comments?: boolean | UserStoryCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * UserStoryCountOutputType without action
   */
  export type UserStoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStoryCountOutputType
     */
    select?: UserStoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserStoryCountOutputType without action
   */
  export type UserStoryCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserStoryCountOutputType without action
   */
  export type UserStoryCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type SprintCountOutputType
   */

  export type SprintCountOutputType = {
    userStories: number
    tasks: number
    subtasks: number
    files: number
  }

  export type SprintCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userStories?: boolean | SprintCountOutputTypeCountUserStoriesArgs
    tasks?: boolean | SprintCountOutputTypeCountTasksArgs
    subtasks?: boolean | SprintCountOutputTypeCountSubtasksArgs
    files?: boolean | SprintCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SprintCountOutputType
     */
    select?: SprintCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeCountUserStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStoryWhereInput
  }

  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
  }

  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    subtasks: number
    dependencies: number
    blockedBy: number
    comments: number
    timeLogs: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtasks?: boolean | TaskCountOutputTypeCountSubtasksArgs
    dependencies?: boolean | TaskCountOutputTypeCountDependenciesArgs
    blockedBy?: boolean | TaskCountOutputTypeCountBlockedByArgs
    comments?: boolean | TaskCountOutputTypeCountCommentsArgs
    timeLogs?: boolean | TaskCountOutputTypeCountTimeLogsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountDependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountBlockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
  }


  /**
   * Count Type SubtaskCountOutputType
   */

  export type SubtaskCountOutputType = {
    files: number
  }

  export type SubtaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | SubtaskCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * SubtaskCountOutputType without action
   */
  export type SubtaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskCountOutputType
     */
    select?: SubtaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubtaskCountOutputType without action
   */
  export type SubtaskCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type FolderCountOutputType
   */

  export type FolderCountOutputType = {
    files: number
  }

  export type FolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | FolderCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderCountOutputType
     */
    select?: FolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type FileCountOutputType
   */

  export type FileCountOutputType = {
    dependencies: number
    relationsFrom: number
    relationsTo: number
  }

  export type FileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dependencies?: boolean | FileCountOutputTypeCountDependenciesArgs
    relationsFrom?: boolean | FileCountOutputTypeCountRelationsFromArgs
    relationsTo?: boolean | FileCountOutputTypeCountRelationsToArgs
  }

  // Custom InputTypes
  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCountOutputType
     */
    select?: FileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountDependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DependencyWhereInput
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountRelationsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileRelationWhereInput
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountRelationsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileRelationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    role: $Enums.Role | null
    lang: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    role: $Enums.Role | null
    lang: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    role: number
    lang: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    lang?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    lang?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    lang?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: boolean
    image: string | null
    role: $Enums.Role
    lang: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    lang?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    verifications?: boolean | User$verificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    lang?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    lang?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    lang?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "role" | "lang" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    verifications?: boolean | User$verificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      memberships: Prisma.$MemberPayload<ExtArgs>[]
      verifications: Prisma.$VerificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: boolean
      image: string | null
      role: $Enums.Role
      lang: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verifications<T extends User$verificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$verificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly lang: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * User.verifications
   */
  export type User$verificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    cursor?: VerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    idToken: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "idToken" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      idToken: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["verification"]>
  export type VerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
    readonly userId: FieldRef<"Verification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
  }


  /**
   * Model UserAggregate
   */

  export type AggregateUserAggregate = {
    _count: UserAggregateCountAggregateOutputType | null
    _min: UserAggregateMinAggregateOutputType | null
    _max: UserAggregateMaxAggregateOutputType | null
  }

  export type UserAggregateMinAggregateOutputType = {
    id: string | null
    userName: string | null
    userEmail: string | null
    userImage: string | null
    userRole: $Enums.Role | null
    userLang: string | null
    userCreatedAt: Date | null
    userUpdatedAt: Date | null
  }

  export type UserAggregateMaxAggregateOutputType = {
    id: string | null
    userName: string | null
    userEmail: string | null
    userImage: string | null
    userRole: $Enums.Role | null
    userLang: string | null
    userCreatedAt: Date | null
    userUpdatedAt: Date | null
  }

  export type UserAggregateCountAggregateOutputType = {
    id: number
    userName: number
    userEmail: number
    userImage: number
    userRole: number
    userLang: number
    userCreatedAt: number
    userUpdatedAt: number
    sessions: number
    accounts: number
    memberProjects: number
    projects: number
    files: number
    tasks: number
    subtasks: number
    comments: number
    timeLogs: number
    epics: number
    userStories: number
    sprints: number
    themas: number
    activities: number
    fileDependencies: number
    fileRelations: number
    _all: number
  }


  export type UserAggregateMinAggregateInputType = {
    id?: true
    userName?: true
    userEmail?: true
    userImage?: true
    userRole?: true
    userLang?: true
    userCreatedAt?: true
    userUpdatedAt?: true
  }

  export type UserAggregateMaxAggregateInputType = {
    id?: true
    userName?: true
    userEmail?: true
    userImage?: true
    userRole?: true
    userLang?: true
    userCreatedAt?: true
    userUpdatedAt?: true
  }

  export type UserAggregateCountAggregateInputType = {
    id?: true
    userName?: true
    userEmail?: true
    userImage?: true
    userRole?: true
    userLang?: true
    userCreatedAt?: true
    userUpdatedAt?: true
    sessions?: true
    accounts?: true
    memberProjects?: true
    projects?: true
    files?: true
    tasks?: true
    subtasks?: true
    comments?: true
    timeLogs?: true
    epics?: true
    userStories?: true
    sprints?: true
    themas?: true
    activities?: true
    fileDependencies?: true
    fileRelations?: true
    _all?: true
  }

  export type UserAggregateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAggregate to aggregate.
     */
    where?: UserAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAggregates to fetch.
     */
    orderBy?: UserAggregateOrderByWithRelationInput | UserAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAggregates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAggregates
    **/
    _count?: true | UserAggregateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAggregateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAggregateMaxAggregateInputType
  }

  export type GetUserAggregateAggregateType<T extends UserAggregateAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAggregate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAggregate[P]>
      : GetScalarType<T[P], AggregateUserAggregate[P]>
  }




  export type UserAggregateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAggregateWhereInput
    orderBy?: UserAggregateOrderByWithAggregationInput | UserAggregateOrderByWithAggregationInput[]
    by: UserAggregateScalarFieldEnum[] | UserAggregateScalarFieldEnum
    having?: UserAggregateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAggregateCountAggregateInputType | true
    _min?: UserAggregateMinAggregateInputType
    _max?: UserAggregateMaxAggregateInputType
  }

  export type UserAggregateGroupByOutputType = {
    id: string
    userName: string | null
    userEmail: string | null
    userImage: string | null
    userRole: $Enums.Role
    userLang: string | null
    userCreatedAt: Date
    userUpdatedAt: Date
    sessions: JsonValue
    accounts: JsonValue
    memberProjects: JsonValue
    projects: JsonValue
    files: JsonValue
    tasks: JsonValue
    subtasks: JsonValue
    comments: JsonValue
    timeLogs: JsonValue
    epics: JsonValue
    userStories: JsonValue
    sprints: JsonValue
    themas: JsonValue
    activities: JsonValue
    fileDependencies: JsonValue
    fileRelations: JsonValue
    _count: UserAggregateCountAggregateOutputType | null
    _min: UserAggregateMinAggregateOutputType | null
    _max: UserAggregateMaxAggregateOutputType | null
  }

  type GetUserAggregateGroupByPayload<T extends UserAggregateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAggregateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAggregateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAggregateGroupByOutputType[P]>
            : GetScalarType<T[P], UserAggregateGroupByOutputType[P]>
        }
      >
    >


  export type UserAggregateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    userEmail?: boolean
    userImage?: boolean
    userRole?: boolean
    userLang?: boolean
    userCreatedAt?: boolean
    userUpdatedAt?: boolean
    sessions?: boolean
    accounts?: boolean
    memberProjects?: boolean
    projects?: boolean
    files?: boolean
    tasks?: boolean
    subtasks?: boolean
    comments?: boolean
    timeLogs?: boolean
    epics?: boolean
    userStories?: boolean
    sprints?: boolean
    themas?: boolean
    activities?: boolean
    fileDependencies?: boolean
    fileRelations?: boolean
  }, ExtArgs["result"]["userAggregate"]>

  export type UserAggregateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    userEmail?: boolean
    userImage?: boolean
    userRole?: boolean
    userLang?: boolean
    userCreatedAt?: boolean
    userUpdatedAt?: boolean
    sessions?: boolean
    accounts?: boolean
    memberProjects?: boolean
    projects?: boolean
    files?: boolean
    tasks?: boolean
    subtasks?: boolean
    comments?: boolean
    timeLogs?: boolean
    epics?: boolean
    userStories?: boolean
    sprints?: boolean
    themas?: boolean
    activities?: boolean
    fileDependencies?: boolean
    fileRelations?: boolean
  }, ExtArgs["result"]["userAggregate"]>

  export type UserAggregateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    userEmail?: boolean
    userImage?: boolean
    userRole?: boolean
    userLang?: boolean
    userCreatedAt?: boolean
    userUpdatedAt?: boolean
    sessions?: boolean
    accounts?: boolean
    memberProjects?: boolean
    projects?: boolean
    files?: boolean
    tasks?: boolean
    subtasks?: boolean
    comments?: boolean
    timeLogs?: boolean
    epics?: boolean
    userStories?: boolean
    sprints?: boolean
    themas?: boolean
    activities?: boolean
    fileDependencies?: boolean
    fileRelations?: boolean
  }, ExtArgs["result"]["userAggregate"]>

  export type UserAggregateSelectScalar = {
    id?: boolean
    userName?: boolean
    userEmail?: boolean
    userImage?: boolean
    userRole?: boolean
    userLang?: boolean
    userCreatedAt?: boolean
    userUpdatedAt?: boolean
    sessions?: boolean
    accounts?: boolean
    memberProjects?: boolean
    projects?: boolean
    files?: boolean
    tasks?: boolean
    subtasks?: boolean
    comments?: boolean
    timeLogs?: boolean
    epics?: boolean
    userStories?: boolean
    sprints?: boolean
    themas?: boolean
    activities?: boolean
    fileDependencies?: boolean
    fileRelations?: boolean
  }

  export type UserAggregateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userName" | "userEmail" | "userImage" | "userRole" | "userLang" | "userCreatedAt" | "userUpdatedAt" | "sessions" | "accounts" | "memberProjects" | "projects" | "files" | "tasks" | "subtasks" | "comments" | "timeLogs" | "epics" | "userStories" | "sprints" | "themas" | "activities" | "fileDependencies" | "fileRelations", ExtArgs["result"]["userAggregate"]>

  export type $UserAggregatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAggregate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userName: string | null
      userEmail: string | null
      userImage: string | null
      userRole: $Enums.Role
      userLang: string | null
      userCreatedAt: Date
      userUpdatedAt: Date
      sessions: Prisma.JsonValue
      accounts: Prisma.JsonValue
      memberProjects: Prisma.JsonValue
      projects: Prisma.JsonValue
      files: Prisma.JsonValue
      tasks: Prisma.JsonValue
      subtasks: Prisma.JsonValue
      comments: Prisma.JsonValue
      timeLogs: Prisma.JsonValue
      epics: Prisma.JsonValue
      userStories: Prisma.JsonValue
      sprints: Prisma.JsonValue
      themas: Prisma.JsonValue
      activities: Prisma.JsonValue
      fileDependencies: Prisma.JsonValue
      fileRelations: Prisma.JsonValue
    }, ExtArgs["result"]["userAggregate"]>
    composites: {}
  }

  type UserAggregateGetPayload<S extends boolean | null | undefined | UserAggregateDefaultArgs> = $Result.GetResult<Prisma.$UserAggregatePayload, S>

  type UserAggregateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAggregateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAggregateCountAggregateInputType | true
    }

  export interface UserAggregateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAggregate'], meta: { name: 'UserAggregate' } }
    /**
     * Find zero or one UserAggregate that matches the filter.
     * @param {UserAggregateFindUniqueArgs} args - Arguments to find a UserAggregate
     * @example
     * // Get one UserAggregate
     * const userAggregate = await prisma.userAggregate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAggregateFindUniqueArgs>(args: SelectSubset<T, UserAggregateFindUniqueArgs<ExtArgs>>): Prisma__UserAggregateClient<$Result.GetResult<Prisma.$UserAggregatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAggregate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAggregateFindUniqueOrThrowArgs} args - Arguments to find a UserAggregate
     * @example
     * // Get one UserAggregate
     * const userAggregate = await prisma.userAggregate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAggregateFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAggregateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAggregateClient<$Result.GetResult<Prisma.$UserAggregatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAggregate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateFindFirstArgs} args - Arguments to find a UserAggregate
     * @example
     * // Get one UserAggregate
     * const userAggregate = await prisma.userAggregate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAggregateFindFirstArgs>(args?: SelectSubset<T, UserAggregateFindFirstArgs<ExtArgs>>): Prisma__UserAggregateClient<$Result.GetResult<Prisma.$UserAggregatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAggregate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateFindFirstOrThrowArgs} args - Arguments to find a UserAggregate
     * @example
     * // Get one UserAggregate
     * const userAggregate = await prisma.userAggregate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAggregateFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAggregateFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAggregateClient<$Result.GetResult<Prisma.$UserAggregatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAggregates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAggregates
     * const userAggregates = await prisma.userAggregate.findMany()
     * 
     * // Get first 10 UserAggregates
     * const userAggregates = await prisma.userAggregate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAggregateWithIdOnly = await prisma.userAggregate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAggregateFindManyArgs>(args?: SelectSubset<T, UserAggregateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAggregatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAggregate.
     * @param {UserAggregateCreateArgs} args - Arguments to create a UserAggregate.
     * @example
     * // Create one UserAggregate
     * const UserAggregate = await prisma.userAggregate.create({
     *   data: {
     *     // ... data to create a UserAggregate
     *   }
     * })
     * 
     */
    create<T extends UserAggregateCreateArgs>(args: SelectSubset<T, UserAggregateCreateArgs<ExtArgs>>): Prisma__UserAggregateClient<$Result.GetResult<Prisma.$UserAggregatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAggregates.
     * @param {UserAggregateCreateManyArgs} args - Arguments to create many UserAggregates.
     * @example
     * // Create many UserAggregates
     * const userAggregate = await prisma.userAggregate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAggregateCreateManyArgs>(args?: SelectSubset<T, UserAggregateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAggregates and returns the data saved in the database.
     * @param {UserAggregateCreateManyAndReturnArgs} args - Arguments to create many UserAggregates.
     * @example
     * // Create many UserAggregates
     * const userAggregate = await prisma.userAggregate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAggregates and only return the `id`
     * const userAggregateWithIdOnly = await prisma.userAggregate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAggregateCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAggregateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAggregatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAggregate.
     * @param {UserAggregateDeleteArgs} args - Arguments to delete one UserAggregate.
     * @example
     * // Delete one UserAggregate
     * const UserAggregate = await prisma.userAggregate.delete({
     *   where: {
     *     // ... filter to delete one UserAggregate
     *   }
     * })
     * 
     */
    delete<T extends UserAggregateDeleteArgs>(args: SelectSubset<T, UserAggregateDeleteArgs<ExtArgs>>): Prisma__UserAggregateClient<$Result.GetResult<Prisma.$UserAggregatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAggregate.
     * @param {UserAggregateUpdateArgs} args - Arguments to update one UserAggregate.
     * @example
     * // Update one UserAggregate
     * const userAggregate = await prisma.userAggregate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAggregateUpdateArgs>(args: SelectSubset<T, UserAggregateUpdateArgs<ExtArgs>>): Prisma__UserAggregateClient<$Result.GetResult<Prisma.$UserAggregatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAggregates.
     * @param {UserAggregateDeleteManyArgs} args - Arguments to filter UserAggregates to delete.
     * @example
     * // Delete a few UserAggregates
     * const { count } = await prisma.userAggregate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAggregateDeleteManyArgs>(args?: SelectSubset<T, UserAggregateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAggregates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAggregates
     * const userAggregate = await prisma.userAggregate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAggregateUpdateManyArgs>(args: SelectSubset<T, UserAggregateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAggregates and returns the data updated in the database.
     * @param {UserAggregateUpdateManyAndReturnArgs} args - Arguments to update many UserAggregates.
     * @example
     * // Update many UserAggregates
     * const userAggregate = await prisma.userAggregate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAggregates and only return the `id`
     * const userAggregateWithIdOnly = await prisma.userAggregate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAggregateUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAggregateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAggregatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAggregate.
     * @param {UserAggregateUpsertArgs} args - Arguments to update or create a UserAggregate.
     * @example
     * // Update or create a UserAggregate
     * const userAggregate = await prisma.userAggregate.upsert({
     *   create: {
     *     // ... data to create a UserAggregate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAggregate we want to update
     *   }
     * })
     */
    upsert<T extends UserAggregateUpsertArgs>(args: SelectSubset<T, UserAggregateUpsertArgs<ExtArgs>>): Prisma__UserAggregateClient<$Result.GetResult<Prisma.$UserAggregatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAggregates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateCountArgs} args - Arguments to filter UserAggregates to count.
     * @example
     * // Count the number of UserAggregates
     * const count = await prisma.userAggregate.count({
     *   where: {
     *     // ... the filter for the UserAggregates we want to count
     *   }
     * })
    **/
    count<T extends UserAggregateCountArgs>(
      args?: Subset<T, UserAggregateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAggregateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAggregate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateAggregateArgs>(args: Subset<T, UserAggregateAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateAggregateType<T>>

    /**
     * Group by UserAggregate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAggregateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAggregateGroupByArgs['orderBy'] }
        : { orderBy?: UserAggregateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAggregateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAggregateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAggregate model
   */
  readonly fields: UserAggregateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAggregate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAggregateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAggregate model
   */
  interface UserAggregateFieldRefs {
    readonly id: FieldRef<"UserAggregate", 'String'>
    readonly userName: FieldRef<"UserAggregate", 'String'>
    readonly userEmail: FieldRef<"UserAggregate", 'String'>
    readonly userImage: FieldRef<"UserAggregate", 'String'>
    readonly userRole: FieldRef<"UserAggregate", 'Role'>
    readonly userLang: FieldRef<"UserAggregate", 'String'>
    readonly userCreatedAt: FieldRef<"UserAggregate", 'DateTime'>
    readonly userUpdatedAt: FieldRef<"UserAggregate", 'DateTime'>
    readonly sessions: FieldRef<"UserAggregate", 'Json'>
    readonly accounts: FieldRef<"UserAggregate", 'Json'>
    readonly memberProjects: FieldRef<"UserAggregate", 'Json'>
    readonly projects: FieldRef<"UserAggregate", 'Json'>
    readonly files: FieldRef<"UserAggregate", 'Json'>
    readonly tasks: FieldRef<"UserAggregate", 'Json'>
    readonly subtasks: FieldRef<"UserAggregate", 'Json'>
    readonly comments: FieldRef<"UserAggregate", 'Json'>
    readonly timeLogs: FieldRef<"UserAggregate", 'Json'>
    readonly epics: FieldRef<"UserAggregate", 'Json'>
    readonly userStories: FieldRef<"UserAggregate", 'Json'>
    readonly sprints: FieldRef<"UserAggregate", 'Json'>
    readonly themas: FieldRef<"UserAggregate", 'Json'>
    readonly activities: FieldRef<"UserAggregate", 'Json'>
    readonly fileDependencies: FieldRef<"UserAggregate", 'Json'>
    readonly fileRelations: FieldRef<"UserAggregate", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UserAggregate findUnique
   */
  export type UserAggregateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
    /**
     * Filter, which UserAggregate to fetch.
     */
    where: UserAggregateWhereUniqueInput
  }

  /**
   * UserAggregate findUniqueOrThrow
   */
  export type UserAggregateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
    /**
     * Filter, which UserAggregate to fetch.
     */
    where: UserAggregateWhereUniqueInput
  }

  /**
   * UserAggregate findFirst
   */
  export type UserAggregateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
    /**
     * Filter, which UserAggregate to fetch.
     */
    where?: UserAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAggregates to fetch.
     */
    orderBy?: UserAggregateOrderByWithRelationInput | UserAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAggregates.
     */
    cursor?: UserAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAggregates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAggregates.
     */
    distinct?: UserAggregateScalarFieldEnum | UserAggregateScalarFieldEnum[]
  }

  /**
   * UserAggregate findFirstOrThrow
   */
  export type UserAggregateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
    /**
     * Filter, which UserAggregate to fetch.
     */
    where?: UserAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAggregates to fetch.
     */
    orderBy?: UserAggregateOrderByWithRelationInput | UserAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAggregates.
     */
    cursor?: UserAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAggregates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAggregates.
     */
    distinct?: UserAggregateScalarFieldEnum | UserAggregateScalarFieldEnum[]
  }

  /**
   * UserAggregate findMany
   */
  export type UserAggregateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
    /**
     * Filter, which UserAggregates to fetch.
     */
    where?: UserAggregateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAggregates to fetch.
     */
    orderBy?: UserAggregateOrderByWithRelationInput | UserAggregateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAggregates.
     */
    cursor?: UserAggregateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAggregates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAggregates.
     */
    skip?: number
    distinct?: UserAggregateScalarFieldEnum | UserAggregateScalarFieldEnum[]
  }

  /**
   * UserAggregate create
   */
  export type UserAggregateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
    /**
     * The data needed to create a UserAggregate.
     */
    data: XOR<UserAggregateCreateInput, UserAggregateUncheckedCreateInput>
  }

  /**
   * UserAggregate createMany
   */
  export type UserAggregateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAggregates.
     */
    data: UserAggregateCreateManyInput | UserAggregateCreateManyInput[]
  }

  /**
   * UserAggregate createManyAndReturn
   */
  export type UserAggregateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
    /**
     * The data used to create many UserAggregates.
     */
    data: UserAggregateCreateManyInput | UserAggregateCreateManyInput[]
  }

  /**
   * UserAggregate update
   */
  export type UserAggregateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
    /**
     * The data needed to update a UserAggregate.
     */
    data: XOR<UserAggregateUpdateInput, UserAggregateUncheckedUpdateInput>
    /**
     * Choose, which UserAggregate to update.
     */
    where: UserAggregateWhereUniqueInput
  }

  /**
   * UserAggregate updateMany
   */
  export type UserAggregateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAggregates.
     */
    data: XOR<UserAggregateUpdateManyMutationInput, UserAggregateUncheckedUpdateManyInput>
    /**
     * Filter which UserAggregates to update
     */
    where?: UserAggregateWhereInput
    /**
     * Limit how many UserAggregates to update.
     */
    limit?: number
  }

  /**
   * UserAggregate updateManyAndReturn
   */
  export type UserAggregateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
    /**
     * The data used to update UserAggregates.
     */
    data: XOR<UserAggregateUpdateManyMutationInput, UserAggregateUncheckedUpdateManyInput>
    /**
     * Filter which UserAggregates to update
     */
    where?: UserAggregateWhereInput
    /**
     * Limit how many UserAggregates to update.
     */
    limit?: number
  }

  /**
   * UserAggregate upsert
   */
  export type UserAggregateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
    /**
     * The filter to search for the UserAggregate to update in case it exists.
     */
    where: UserAggregateWhereUniqueInput
    /**
     * In case the UserAggregate found by the `where` argument doesn't exist, create a new UserAggregate with this data.
     */
    create: XOR<UserAggregateCreateInput, UserAggregateUncheckedCreateInput>
    /**
     * In case the UserAggregate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAggregateUpdateInput, UserAggregateUncheckedUpdateInput>
  }

  /**
   * UserAggregate delete
   */
  export type UserAggregateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
    /**
     * Filter which UserAggregate to delete.
     */
    where: UserAggregateWhereUniqueInput
  }

  /**
   * UserAggregate deleteMany
   */
  export type UserAggregateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAggregates to delete
     */
    where?: UserAggregateWhereInput
    /**
     * Limit how many UserAggregates to delete.
     */
    limit?: number
  }

  /**
   * UserAggregate without action
   */
  export type UserAggregateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAggregate
     */
    select?: UserAggregateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAggregate
     */
    omit?: UserAggregateOmit<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    priority: number | null
  }

  export type ProjectSumAggregateOutputType = {
    priority: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    status: $Enums.Status | null
    priority: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    status: $Enums.Status | null
    priority: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    status: number
    priority: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    creatorId: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    priority?: true
  }

  export type ProjectSumAggregateInputType = {
    priority?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    status?: true
    priority?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    status?: true
    priority?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    status?: true
    priority?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    image: string | null
    status: $Enums.Status
    priority: number
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    creatorId: string | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    themas?: boolean | Project$themasArgs<ExtArgs>
    epics?: boolean | Project$epicsArgs<ExtArgs>
    userStories?: boolean | Project$userStoriesArgs<ExtArgs>
    sprints?: boolean | Project$sprintsArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    folders?: boolean | Project$foldersArgs<ExtArgs>
    files?: boolean | Project$filesArgs<ExtArgs>
    comments?: boolean | Project$commentsArgs<ExtArgs>
    creator?: boolean | Project$creatorArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "image" | "status" | "priority" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "creatorId", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    themas?: boolean | Project$themasArgs<ExtArgs>
    epics?: boolean | Project$epicsArgs<ExtArgs>
    userStories?: boolean | Project$userStoriesArgs<ExtArgs>
    sprints?: boolean | Project$sprintsArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    folders?: boolean | Project$foldersArgs<ExtArgs>
    files?: boolean | Project$filesArgs<ExtArgs>
    comments?: boolean | Project$commentsArgs<ExtArgs>
    creator?: boolean | Project$creatorArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      themas: Prisma.$ThemaPayload<ExtArgs>[]
      epics: Prisma.$EpicPayload<ExtArgs>[]
      userStories: Prisma.$UserStoryPayload<ExtArgs>[]
      sprints: Prisma.$SprintPayload<ExtArgs>[]
      members: Prisma.$MemberPayload<ExtArgs>[]
      folders: Prisma.$FolderPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      creator: Prisma.$MemberPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      image: string | null
      status: $Enums.Status
      priority: number
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
      creatorId: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    themas<T extends Project$themasArgs<ExtArgs> = {}>(args?: Subset<T, Project$themasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    epics<T extends Project$epicsArgs<ExtArgs> = {}>(args?: Subset<T, Project$epicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userStories<T extends Project$userStoriesArgs<ExtArgs> = {}>(args?: Subset<T, Project$userStoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sprints<T extends Project$sprintsArgs<ExtArgs> = {}>(args?: Subset<T, Project$sprintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    folders<T extends Project$foldersArgs<ExtArgs> = {}>(args?: Subset<T, Project$foldersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Project$filesArgs<ExtArgs> = {}>(args?: Subset<T, Project$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Project$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creator<T extends Project$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Project$creatorArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly image: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'Status'>
    readonly priority: FieldRef<"Project", 'Int'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly creatorId: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.themas
   */
  export type Project$themasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    where?: ThemaWhereInput
    orderBy?: ThemaOrderByWithRelationInput | ThemaOrderByWithRelationInput[]
    cursor?: ThemaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThemaScalarFieldEnum | ThemaScalarFieldEnum[]
  }

  /**
   * Project.epics
   */
  export type Project$epicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    where?: EpicWhereInput
    orderBy?: EpicOrderByWithRelationInput | EpicOrderByWithRelationInput[]
    cursor?: EpicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EpicScalarFieldEnum | EpicScalarFieldEnum[]
  }

  /**
   * Project.userStories
   */
  export type Project$userStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    where?: UserStoryWhereInput
    orderBy?: UserStoryOrderByWithRelationInput | UserStoryOrderByWithRelationInput[]
    cursor?: UserStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserStoryScalarFieldEnum | UserStoryScalarFieldEnum[]
  }

  /**
   * Project.sprints
   */
  export type Project$sprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    cursor?: SprintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Project.folders
   */
  export type Project$foldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    cursor?: FolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Project.files
   */
  export type Project$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Project.comments
   */
  export type Project$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Project.creator
   */
  export type Project$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    joinedAt: Date | null
    updatedAt: Date | null
    userId: string | null
    projectId: string | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    joinedAt: Date | null
    updatedAt: Date | null
    userId: string | null
    projectId: string | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    role: number
    joinedAt: number
    updatedAt: number
    userId: number
    projectId: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    role?: true
    joinedAt?: true
    updatedAt?: true
    userId?: true
    projectId?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    role?: true
    joinedAt?: true
    updatedAt?: true
    userId?: true
    projectId?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    role?: true
    joinedAt?: true
    updatedAt?: true
    userId?: true
    projectId?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    role: $Enums.Role
    joinedAt: Date
    updatedAt: Date
    userId: string
    projectId: string
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    projectId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    files?: boolean | Member$filesArgs<ExtArgs>
    tasks?: boolean | Member$tasksArgs<ExtArgs>
    subtasks?: boolean | Member$subtasksArgs<ExtArgs>
    comments?: boolean | Member$commentsArgs<ExtArgs>
    timeLogs?: boolean | Member$timeLogsArgs<ExtArgs>
    userStories?: boolean | Member$userStoriesArgs<ExtArgs>
    themas?: boolean | Member$themasArgs<ExtArgs>
    epics?: boolean | Member$epicsArgs<ExtArgs>
    sprints?: boolean | Member$sprintsArgs<ExtArgs>
    activities?: boolean | Member$activitiesArgs<ExtArgs>
    createdProjects?: boolean | Member$createdProjectsArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    projectId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    projectId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    role?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    projectId?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "joinedAt" | "updatedAt" | "userId" | "projectId", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    files?: boolean | Member$filesArgs<ExtArgs>
    tasks?: boolean | Member$tasksArgs<ExtArgs>
    subtasks?: boolean | Member$subtasksArgs<ExtArgs>
    comments?: boolean | Member$commentsArgs<ExtArgs>
    timeLogs?: boolean | Member$timeLogsArgs<ExtArgs>
    userStories?: boolean | Member$userStoriesArgs<ExtArgs>
    themas?: boolean | Member$themasArgs<ExtArgs>
    epics?: boolean | Member$epicsArgs<ExtArgs>
    sprints?: boolean | Member$sprintsArgs<ExtArgs>
    activities?: boolean | Member$activitiesArgs<ExtArgs>
    createdProjects?: boolean | Member$createdProjectsArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
      files: Prisma.$FilePayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      subtasks: Prisma.$SubtaskPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      timeLogs: Prisma.$TimeLogPayload<ExtArgs>[]
      userStories: Prisma.$UserStoryPayload<ExtArgs>[]
      themas: Prisma.$ThemaPayload<ExtArgs>[]
      epics: Prisma.$EpicPayload<ExtArgs>[]
      sprints: Prisma.$SprintPayload<ExtArgs>[]
      activities: Prisma.$ActivityLogPayload<ExtArgs>[]
      createdProjects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.Role
      joinedAt: Date
      updatedAt: Date
      userId: string
      projectId: string
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    files<T extends Member$filesArgs<ExtArgs> = {}>(args?: Subset<T, Member$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Member$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Member$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subtasks<T extends Member$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, Member$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Member$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Member$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeLogs<T extends Member$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, Member$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userStories<T extends Member$userStoriesArgs<ExtArgs> = {}>(args?: Subset<T, Member$userStoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    themas<T extends Member$themasArgs<ExtArgs> = {}>(args?: Subset<T, Member$themasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    epics<T extends Member$epicsArgs<ExtArgs> = {}>(args?: Subset<T, Member$epicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sprints<T extends Member$sprintsArgs<ExtArgs> = {}>(args?: Subset<T, Member$sprintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Member$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Member$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdProjects<T extends Member$createdProjectsArgs<ExtArgs> = {}>(args?: Subset<T, Member$createdProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly role: FieldRef<"Member", 'Role'>
    readonly joinedAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
    readonly userId: FieldRef<"Member", 'String'>
    readonly projectId: FieldRef<"Member", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member.files
   */
  export type Member$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Member.tasks
   */
  export type Member$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Member.subtasks
   */
  export type Member$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    cursor?: SubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Member.comments
   */
  export type Member$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Member.timeLogs
   */
  export type Member$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    cursor?: TimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * Member.userStories
   */
  export type Member$userStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    where?: UserStoryWhereInput
    orderBy?: UserStoryOrderByWithRelationInput | UserStoryOrderByWithRelationInput[]
    cursor?: UserStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserStoryScalarFieldEnum | UserStoryScalarFieldEnum[]
  }

  /**
   * Member.themas
   */
  export type Member$themasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    where?: ThemaWhereInput
    orderBy?: ThemaOrderByWithRelationInput | ThemaOrderByWithRelationInput[]
    cursor?: ThemaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThemaScalarFieldEnum | ThemaScalarFieldEnum[]
  }

  /**
   * Member.epics
   */
  export type Member$epicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    where?: EpicWhereInput
    orderBy?: EpicOrderByWithRelationInput | EpicOrderByWithRelationInput[]
    cursor?: EpicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EpicScalarFieldEnum | EpicScalarFieldEnum[]
  }

  /**
   * Member.sprints
   */
  export type Member$sprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    cursor?: SprintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Member.activities
   */
  export type Member$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Member.createdProjects
   */
  export type Member$createdProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Thema
   */

  export type AggregateThema = {
    _count: ThemaCountAggregateOutputType | null
    _avg: ThemaAvgAggregateOutputType | null
    _sum: ThemaSumAggregateOutputType | null
    _min: ThemaMinAggregateOutputType | null
    _max: ThemaMaxAggregateOutputType | null
  }

  export type ThemaAvgAggregateOutputType = {
    priority: number | null
  }

  export type ThemaSumAggregateOutputType = {
    priority: number | null
  }

  export type ThemaMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.Status | null
    priority: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    creatorId: string | null
  }

  export type ThemaMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.Status | null
    priority: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    creatorId: string | null
  }

  export type ThemaCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    priority: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    projectId: number
    creatorId: number
    _all: number
  }


  export type ThemaAvgAggregateInputType = {
    priority?: true
  }

  export type ThemaSumAggregateInputType = {
    priority?: true
  }

  export type ThemaMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    creatorId?: true
  }

  export type ThemaMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    creatorId?: true
  }

  export type ThemaCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    creatorId?: true
    _all?: true
  }

  export type ThemaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Thema to aggregate.
     */
    where?: ThemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themas to fetch.
     */
    orderBy?: ThemaOrderByWithRelationInput | ThemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Themas
    **/
    _count?: true | ThemaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ThemaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ThemaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThemaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThemaMaxAggregateInputType
  }

  export type GetThemaAggregateType<T extends ThemaAggregateArgs> = {
        [P in keyof T & keyof AggregateThema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThema[P]>
      : GetScalarType<T[P], AggregateThema[P]>
  }




  export type ThemaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemaWhereInput
    orderBy?: ThemaOrderByWithAggregationInput | ThemaOrderByWithAggregationInput[]
    by: ThemaScalarFieldEnum[] | ThemaScalarFieldEnum
    having?: ThemaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThemaCountAggregateInputType | true
    _avg?: ThemaAvgAggregateInputType
    _sum?: ThemaSumAggregateInputType
    _min?: ThemaMinAggregateInputType
    _max?: ThemaMaxAggregateInputType
  }

  export type ThemaGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: $Enums.Status
    priority: number
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    creatorId: string
    _count: ThemaCountAggregateOutputType | null
    _avg: ThemaAvgAggregateOutputType | null
    _sum: ThemaSumAggregateOutputType | null
    _min: ThemaMinAggregateOutputType | null
    _max: ThemaMaxAggregateOutputType | null
  }

  type GetThemaGroupByPayload<T extends ThemaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThemaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThemaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThemaGroupByOutputType[P]>
            : GetScalarType<T[P], ThemaGroupByOutputType[P]>
        }
      >
    >


  export type ThemaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    tasks?: boolean | Thema$tasksArgs<ExtArgs>
    comments?: boolean | Thema$commentsArgs<ExtArgs>
    _count?: boolean | ThemaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thema"]>

  export type ThemaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thema"]>

  export type ThemaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thema"]>

  export type ThemaSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
  }

  export type ThemaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "priority" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "projectId" | "creatorId", ExtArgs["result"]["thema"]>
  export type ThemaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    tasks?: boolean | Thema$tasksArgs<ExtArgs>
    comments?: boolean | Thema$commentsArgs<ExtArgs>
    _count?: boolean | ThemaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ThemaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type ThemaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $ThemaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Thema"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$MemberPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: $Enums.Status
      priority: number
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
      projectId: string
      creatorId: string
    }, ExtArgs["result"]["thema"]>
    composites: {}
  }

  type ThemaGetPayload<S extends boolean | null | undefined | ThemaDefaultArgs> = $Result.GetResult<Prisma.$ThemaPayload, S>

  type ThemaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThemaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThemaCountAggregateInputType | true
    }

  export interface ThemaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Thema'], meta: { name: 'Thema' } }
    /**
     * Find zero or one Thema that matches the filter.
     * @param {ThemaFindUniqueArgs} args - Arguments to find a Thema
     * @example
     * // Get one Thema
     * const thema = await prisma.thema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThemaFindUniqueArgs>(args: SelectSubset<T, ThemaFindUniqueArgs<ExtArgs>>): Prisma__ThemaClient<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Thema that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThemaFindUniqueOrThrowArgs} args - Arguments to find a Thema
     * @example
     * // Get one Thema
     * const thema = await prisma.thema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThemaFindUniqueOrThrowArgs>(args: SelectSubset<T, ThemaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThemaClient<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Thema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemaFindFirstArgs} args - Arguments to find a Thema
     * @example
     * // Get one Thema
     * const thema = await prisma.thema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThemaFindFirstArgs>(args?: SelectSubset<T, ThemaFindFirstArgs<ExtArgs>>): Prisma__ThemaClient<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Thema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemaFindFirstOrThrowArgs} args - Arguments to find a Thema
     * @example
     * // Get one Thema
     * const thema = await prisma.thema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThemaFindFirstOrThrowArgs>(args?: SelectSubset<T, ThemaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThemaClient<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Themas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Themas
     * const themas = await prisma.thema.findMany()
     * 
     * // Get first 10 Themas
     * const themas = await prisma.thema.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const themaWithIdOnly = await prisma.thema.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThemaFindManyArgs>(args?: SelectSubset<T, ThemaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Thema.
     * @param {ThemaCreateArgs} args - Arguments to create a Thema.
     * @example
     * // Create one Thema
     * const Thema = await prisma.thema.create({
     *   data: {
     *     // ... data to create a Thema
     *   }
     * })
     * 
     */
    create<T extends ThemaCreateArgs>(args: SelectSubset<T, ThemaCreateArgs<ExtArgs>>): Prisma__ThemaClient<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Themas.
     * @param {ThemaCreateManyArgs} args - Arguments to create many Themas.
     * @example
     * // Create many Themas
     * const thema = await prisma.thema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThemaCreateManyArgs>(args?: SelectSubset<T, ThemaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Themas and returns the data saved in the database.
     * @param {ThemaCreateManyAndReturnArgs} args - Arguments to create many Themas.
     * @example
     * // Create many Themas
     * const thema = await prisma.thema.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Themas and only return the `id`
     * const themaWithIdOnly = await prisma.thema.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThemaCreateManyAndReturnArgs>(args?: SelectSubset<T, ThemaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Thema.
     * @param {ThemaDeleteArgs} args - Arguments to delete one Thema.
     * @example
     * // Delete one Thema
     * const Thema = await prisma.thema.delete({
     *   where: {
     *     // ... filter to delete one Thema
     *   }
     * })
     * 
     */
    delete<T extends ThemaDeleteArgs>(args: SelectSubset<T, ThemaDeleteArgs<ExtArgs>>): Prisma__ThemaClient<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Thema.
     * @param {ThemaUpdateArgs} args - Arguments to update one Thema.
     * @example
     * // Update one Thema
     * const thema = await prisma.thema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThemaUpdateArgs>(args: SelectSubset<T, ThemaUpdateArgs<ExtArgs>>): Prisma__ThemaClient<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Themas.
     * @param {ThemaDeleteManyArgs} args - Arguments to filter Themas to delete.
     * @example
     * // Delete a few Themas
     * const { count } = await prisma.thema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThemaDeleteManyArgs>(args?: SelectSubset<T, ThemaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Themas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Themas
     * const thema = await prisma.thema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThemaUpdateManyArgs>(args: SelectSubset<T, ThemaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Themas and returns the data updated in the database.
     * @param {ThemaUpdateManyAndReturnArgs} args - Arguments to update many Themas.
     * @example
     * // Update many Themas
     * const thema = await prisma.thema.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Themas and only return the `id`
     * const themaWithIdOnly = await prisma.thema.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThemaUpdateManyAndReturnArgs>(args: SelectSubset<T, ThemaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Thema.
     * @param {ThemaUpsertArgs} args - Arguments to update or create a Thema.
     * @example
     * // Update or create a Thema
     * const thema = await prisma.thema.upsert({
     *   create: {
     *     // ... data to create a Thema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Thema we want to update
     *   }
     * })
     */
    upsert<T extends ThemaUpsertArgs>(args: SelectSubset<T, ThemaUpsertArgs<ExtArgs>>): Prisma__ThemaClient<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Themas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemaCountArgs} args - Arguments to filter Themas to count.
     * @example
     * // Count the number of Themas
     * const count = await prisma.thema.count({
     *   where: {
     *     // ... the filter for the Themas we want to count
     *   }
     * })
    **/
    count<T extends ThemaCountArgs>(
      args?: Subset<T, ThemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThemaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Thema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThemaAggregateArgs>(args: Subset<T, ThemaAggregateArgs>): Prisma.PrismaPromise<GetThemaAggregateType<T>>

    /**
     * Group by Thema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThemaGroupByArgs['orderBy'] }
        : { orderBy?: ThemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThemaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThemaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Thema model
   */
  readonly fields: ThemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Thema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThemaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Thema$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Thema$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Thema$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Thema$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Thema model
   */
  interface ThemaFieldRefs {
    readonly id: FieldRef<"Thema", 'String'>
    readonly name: FieldRef<"Thema", 'String'>
    readonly description: FieldRef<"Thema", 'String'>
    readonly status: FieldRef<"Thema", 'Status'>
    readonly priority: FieldRef<"Thema", 'Int'>
    readonly startDate: FieldRef<"Thema", 'DateTime'>
    readonly endDate: FieldRef<"Thema", 'DateTime'>
    readonly createdAt: FieldRef<"Thema", 'DateTime'>
    readonly updatedAt: FieldRef<"Thema", 'DateTime'>
    readonly projectId: FieldRef<"Thema", 'String'>
    readonly creatorId: FieldRef<"Thema", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Thema findUnique
   */
  export type ThemaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    /**
     * Filter, which Thema to fetch.
     */
    where: ThemaWhereUniqueInput
  }

  /**
   * Thema findUniqueOrThrow
   */
  export type ThemaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    /**
     * Filter, which Thema to fetch.
     */
    where: ThemaWhereUniqueInput
  }

  /**
   * Thema findFirst
   */
  export type ThemaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    /**
     * Filter, which Thema to fetch.
     */
    where?: ThemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themas to fetch.
     */
    orderBy?: ThemaOrderByWithRelationInput | ThemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themas.
     */
    cursor?: ThemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themas.
     */
    distinct?: ThemaScalarFieldEnum | ThemaScalarFieldEnum[]
  }

  /**
   * Thema findFirstOrThrow
   */
  export type ThemaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    /**
     * Filter, which Thema to fetch.
     */
    where?: ThemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themas to fetch.
     */
    orderBy?: ThemaOrderByWithRelationInput | ThemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themas.
     */
    cursor?: ThemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themas.
     */
    distinct?: ThemaScalarFieldEnum | ThemaScalarFieldEnum[]
  }

  /**
   * Thema findMany
   */
  export type ThemaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    /**
     * Filter, which Themas to fetch.
     */
    where?: ThemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themas to fetch.
     */
    orderBy?: ThemaOrderByWithRelationInput | ThemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Themas.
     */
    cursor?: ThemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themas.
     */
    skip?: number
    distinct?: ThemaScalarFieldEnum | ThemaScalarFieldEnum[]
  }

  /**
   * Thema create
   */
  export type ThemaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    /**
     * The data needed to create a Thema.
     */
    data: XOR<ThemaCreateInput, ThemaUncheckedCreateInput>
  }

  /**
   * Thema createMany
   */
  export type ThemaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Themas.
     */
    data: ThemaCreateManyInput | ThemaCreateManyInput[]
  }

  /**
   * Thema createManyAndReturn
   */
  export type ThemaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * The data used to create many Themas.
     */
    data: ThemaCreateManyInput | ThemaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Thema update
   */
  export type ThemaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    /**
     * The data needed to update a Thema.
     */
    data: XOR<ThemaUpdateInput, ThemaUncheckedUpdateInput>
    /**
     * Choose, which Thema to update.
     */
    where: ThemaWhereUniqueInput
  }

  /**
   * Thema updateMany
   */
  export type ThemaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Themas.
     */
    data: XOR<ThemaUpdateManyMutationInput, ThemaUncheckedUpdateManyInput>
    /**
     * Filter which Themas to update
     */
    where?: ThemaWhereInput
    /**
     * Limit how many Themas to update.
     */
    limit?: number
  }

  /**
   * Thema updateManyAndReturn
   */
  export type ThemaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * The data used to update Themas.
     */
    data: XOR<ThemaUpdateManyMutationInput, ThemaUncheckedUpdateManyInput>
    /**
     * Filter which Themas to update
     */
    where?: ThemaWhereInput
    /**
     * Limit how many Themas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Thema upsert
   */
  export type ThemaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    /**
     * The filter to search for the Thema to update in case it exists.
     */
    where: ThemaWhereUniqueInput
    /**
     * In case the Thema found by the `where` argument doesn't exist, create a new Thema with this data.
     */
    create: XOR<ThemaCreateInput, ThemaUncheckedCreateInput>
    /**
     * In case the Thema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThemaUpdateInput, ThemaUncheckedUpdateInput>
  }

  /**
   * Thema delete
   */
  export type ThemaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    /**
     * Filter which Thema to delete.
     */
    where: ThemaWhereUniqueInput
  }

  /**
   * Thema deleteMany
   */
  export type ThemaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Themas to delete
     */
    where?: ThemaWhereInput
    /**
     * Limit how many Themas to delete.
     */
    limit?: number
  }

  /**
   * Thema.tasks
   */
  export type Thema$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Thema.comments
   */
  export type Thema$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Thema without action
   */
  export type ThemaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
  }


  /**
   * Model Epic
   */

  export type AggregateEpic = {
    _count: EpicCountAggregateOutputType | null
    _avg: EpicAvgAggregateOutputType | null
    _sum: EpicSumAggregateOutputType | null
    _min: EpicMinAggregateOutputType | null
    _max: EpicMaxAggregateOutputType | null
  }

  export type EpicAvgAggregateOutputType = {
    priority: number | null
  }

  export type EpicSumAggregateOutputType = {
    priority: number | null
  }

  export type EpicMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.Status | null
    priority: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    creatorId: string | null
  }

  export type EpicMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.Status | null
    priority: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    creatorId: string | null
  }

  export type EpicCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    priority: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    projectId: number
    creatorId: number
    _all: number
  }


  export type EpicAvgAggregateInputType = {
    priority?: true
  }

  export type EpicSumAggregateInputType = {
    priority?: true
  }

  export type EpicMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    creatorId?: true
  }

  export type EpicMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    creatorId?: true
  }

  export type EpicCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    creatorId?: true
    _all?: true
  }

  export type EpicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Epic to aggregate.
     */
    where?: EpicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Epics to fetch.
     */
    orderBy?: EpicOrderByWithRelationInput | EpicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EpicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Epics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Epics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Epics
    **/
    _count?: true | EpicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EpicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EpicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EpicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EpicMaxAggregateInputType
  }

  export type GetEpicAggregateType<T extends EpicAggregateArgs> = {
        [P in keyof T & keyof AggregateEpic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpic[P]>
      : GetScalarType<T[P], AggregateEpic[P]>
  }




  export type EpicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpicWhereInput
    orderBy?: EpicOrderByWithAggregationInput | EpicOrderByWithAggregationInput[]
    by: EpicScalarFieldEnum[] | EpicScalarFieldEnum
    having?: EpicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EpicCountAggregateInputType | true
    _avg?: EpicAvgAggregateInputType
    _sum?: EpicSumAggregateInputType
    _min?: EpicMinAggregateInputType
    _max?: EpicMaxAggregateInputType
  }

  export type EpicGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: $Enums.Status
    priority: number
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    creatorId: string
    _count: EpicCountAggregateOutputType | null
    _avg: EpicAvgAggregateOutputType | null
    _sum: EpicSumAggregateOutputType | null
    _min: EpicMinAggregateOutputType | null
    _max: EpicMaxAggregateOutputType | null
  }

  type GetEpicGroupByPayload<T extends EpicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EpicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EpicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EpicGroupByOutputType[P]>
            : GetScalarType<T[P], EpicGroupByOutputType[P]>
        }
      >
    >


  export type EpicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    userStories?: boolean | Epic$userStoriesArgs<ExtArgs>
    comments?: boolean | Epic$commentsArgs<ExtArgs>
    _count?: boolean | EpicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["epic"]>

  export type EpicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["epic"]>

  export type EpicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["epic"]>

  export type EpicSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
  }

  export type EpicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "priority" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "projectId" | "creatorId", ExtArgs["result"]["epic"]>
  export type EpicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    userStories?: boolean | Epic$userStoriesArgs<ExtArgs>
    comments?: boolean | Epic$commentsArgs<ExtArgs>
    _count?: boolean | EpicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EpicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type EpicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $EpicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Epic"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$MemberPayload<ExtArgs>
      userStories: Prisma.$UserStoryPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: $Enums.Status
      priority: number
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
      projectId: string
      creatorId: string
    }, ExtArgs["result"]["epic"]>
    composites: {}
  }

  type EpicGetPayload<S extends boolean | null | undefined | EpicDefaultArgs> = $Result.GetResult<Prisma.$EpicPayload, S>

  type EpicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EpicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EpicCountAggregateInputType | true
    }

  export interface EpicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Epic'], meta: { name: 'Epic' } }
    /**
     * Find zero or one Epic that matches the filter.
     * @param {EpicFindUniqueArgs} args - Arguments to find a Epic
     * @example
     * // Get one Epic
     * const epic = await prisma.epic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EpicFindUniqueArgs>(args: SelectSubset<T, EpicFindUniqueArgs<ExtArgs>>): Prisma__EpicClient<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Epic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EpicFindUniqueOrThrowArgs} args - Arguments to find a Epic
     * @example
     * // Get one Epic
     * const epic = await prisma.epic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EpicFindUniqueOrThrowArgs>(args: SelectSubset<T, EpicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EpicClient<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Epic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpicFindFirstArgs} args - Arguments to find a Epic
     * @example
     * // Get one Epic
     * const epic = await prisma.epic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EpicFindFirstArgs>(args?: SelectSubset<T, EpicFindFirstArgs<ExtArgs>>): Prisma__EpicClient<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Epic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpicFindFirstOrThrowArgs} args - Arguments to find a Epic
     * @example
     * // Get one Epic
     * const epic = await prisma.epic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EpicFindFirstOrThrowArgs>(args?: SelectSubset<T, EpicFindFirstOrThrowArgs<ExtArgs>>): Prisma__EpicClient<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Epics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Epics
     * const epics = await prisma.epic.findMany()
     * 
     * // Get first 10 Epics
     * const epics = await prisma.epic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const epicWithIdOnly = await prisma.epic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EpicFindManyArgs>(args?: SelectSubset<T, EpicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Epic.
     * @param {EpicCreateArgs} args - Arguments to create a Epic.
     * @example
     * // Create one Epic
     * const Epic = await prisma.epic.create({
     *   data: {
     *     // ... data to create a Epic
     *   }
     * })
     * 
     */
    create<T extends EpicCreateArgs>(args: SelectSubset<T, EpicCreateArgs<ExtArgs>>): Prisma__EpicClient<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Epics.
     * @param {EpicCreateManyArgs} args - Arguments to create many Epics.
     * @example
     * // Create many Epics
     * const epic = await prisma.epic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EpicCreateManyArgs>(args?: SelectSubset<T, EpicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Epics and returns the data saved in the database.
     * @param {EpicCreateManyAndReturnArgs} args - Arguments to create many Epics.
     * @example
     * // Create many Epics
     * const epic = await prisma.epic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Epics and only return the `id`
     * const epicWithIdOnly = await prisma.epic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EpicCreateManyAndReturnArgs>(args?: SelectSubset<T, EpicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Epic.
     * @param {EpicDeleteArgs} args - Arguments to delete one Epic.
     * @example
     * // Delete one Epic
     * const Epic = await prisma.epic.delete({
     *   where: {
     *     // ... filter to delete one Epic
     *   }
     * })
     * 
     */
    delete<T extends EpicDeleteArgs>(args: SelectSubset<T, EpicDeleteArgs<ExtArgs>>): Prisma__EpicClient<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Epic.
     * @param {EpicUpdateArgs} args - Arguments to update one Epic.
     * @example
     * // Update one Epic
     * const epic = await prisma.epic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EpicUpdateArgs>(args: SelectSubset<T, EpicUpdateArgs<ExtArgs>>): Prisma__EpicClient<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Epics.
     * @param {EpicDeleteManyArgs} args - Arguments to filter Epics to delete.
     * @example
     * // Delete a few Epics
     * const { count } = await prisma.epic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EpicDeleteManyArgs>(args?: SelectSubset<T, EpicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Epics
     * const epic = await prisma.epic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EpicUpdateManyArgs>(args: SelectSubset<T, EpicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epics and returns the data updated in the database.
     * @param {EpicUpdateManyAndReturnArgs} args - Arguments to update many Epics.
     * @example
     * // Update many Epics
     * const epic = await prisma.epic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Epics and only return the `id`
     * const epicWithIdOnly = await prisma.epic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EpicUpdateManyAndReturnArgs>(args: SelectSubset<T, EpicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Epic.
     * @param {EpicUpsertArgs} args - Arguments to update or create a Epic.
     * @example
     * // Update or create a Epic
     * const epic = await prisma.epic.upsert({
     *   create: {
     *     // ... data to create a Epic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Epic we want to update
     *   }
     * })
     */
    upsert<T extends EpicUpsertArgs>(args: SelectSubset<T, EpicUpsertArgs<ExtArgs>>): Prisma__EpicClient<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Epics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpicCountArgs} args - Arguments to filter Epics to count.
     * @example
     * // Count the number of Epics
     * const count = await prisma.epic.count({
     *   where: {
     *     // ... the filter for the Epics we want to count
     *   }
     * })
    **/
    count<T extends EpicCountArgs>(
      args?: Subset<T, EpicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EpicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Epic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EpicAggregateArgs>(args: Subset<T, EpicAggregateArgs>): Prisma.PrismaPromise<GetEpicAggregateType<T>>

    /**
     * Group by Epic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EpicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EpicGroupByArgs['orderBy'] }
        : { orderBy?: EpicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EpicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Epic model
   */
  readonly fields: EpicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Epic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EpicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userStories<T extends Epic$userStoriesArgs<ExtArgs> = {}>(args?: Subset<T, Epic$userStoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Epic$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Epic$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Epic model
   */
  interface EpicFieldRefs {
    readonly id: FieldRef<"Epic", 'String'>
    readonly name: FieldRef<"Epic", 'String'>
    readonly description: FieldRef<"Epic", 'String'>
    readonly status: FieldRef<"Epic", 'Status'>
    readonly priority: FieldRef<"Epic", 'Int'>
    readonly startDate: FieldRef<"Epic", 'DateTime'>
    readonly endDate: FieldRef<"Epic", 'DateTime'>
    readonly createdAt: FieldRef<"Epic", 'DateTime'>
    readonly updatedAt: FieldRef<"Epic", 'DateTime'>
    readonly projectId: FieldRef<"Epic", 'String'>
    readonly creatorId: FieldRef<"Epic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Epic findUnique
   */
  export type EpicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    /**
     * Filter, which Epic to fetch.
     */
    where: EpicWhereUniqueInput
  }

  /**
   * Epic findUniqueOrThrow
   */
  export type EpicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    /**
     * Filter, which Epic to fetch.
     */
    where: EpicWhereUniqueInput
  }

  /**
   * Epic findFirst
   */
  export type EpicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    /**
     * Filter, which Epic to fetch.
     */
    where?: EpicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Epics to fetch.
     */
    orderBy?: EpicOrderByWithRelationInput | EpicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Epics.
     */
    cursor?: EpicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Epics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Epics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Epics.
     */
    distinct?: EpicScalarFieldEnum | EpicScalarFieldEnum[]
  }

  /**
   * Epic findFirstOrThrow
   */
  export type EpicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    /**
     * Filter, which Epic to fetch.
     */
    where?: EpicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Epics to fetch.
     */
    orderBy?: EpicOrderByWithRelationInput | EpicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Epics.
     */
    cursor?: EpicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Epics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Epics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Epics.
     */
    distinct?: EpicScalarFieldEnum | EpicScalarFieldEnum[]
  }

  /**
   * Epic findMany
   */
  export type EpicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    /**
     * Filter, which Epics to fetch.
     */
    where?: EpicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Epics to fetch.
     */
    orderBy?: EpicOrderByWithRelationInput | EpicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Epics.
     */
    cursor?: EpicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Epics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Epics.
     */
    skip?: number
    distinct?: EpicScalarFieldEnum | EpicScalarFieldEnum[]
  }

  /**
   * Epic create
   */
  export type EpicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    /**
     * The data needed to create a Epic.
     */
    data: XOR<EpicCreateInput, EpicUncheckedCreateInput>
  }

  /**
   * Epic createMany
   */
  export type EpicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Epics.
     */
    data: EpicCreateManyInput | EpicCreateManyInput[]
  }

  /**
   * Epic createManyAndReturn
   */
  export type EpicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * The data used to create many Epics.
     */
    data: EpicCreateManyInput | EpicCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Epic update
   */
  export type EpicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    /**
     * The data needed to update a Epic.
     */
    data: XOR<EpicUpdateInput, EpicUncheckedUpdateInput>
    /**
     * Choose, which Epic to update.
     */
    where: EpicWhereUniqueInput
  }

  /**
   * Epic updateMany
   */
  export type EpicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Epics.
     */
    data: XOR<EpicUpdateManyMutationInput, EpicUncheckedUpdateManyInput>
    /**
     * Filter which Epics to update
     */
    where?: EpicWhereInput
    /**
     * Limit how many Epics to update.
     */
    limit?: number
  }

  /**
   * Epic updateManyAndReturn
   */
  export type EpicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * The data used to update Epics.
     */
    data: XOR<EpicUpdateManyMutationInput, EpicUncheckedUpdateManyInput>
    /**
     * Filter which Epics to update
     */
    where?: EpicWhereInput
    /**
     * Limit how many Epics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Epic upsert
   */
  export type EpicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    /**
     * The filter to search for the Epic to update in case it exists.
     */
    where: EpicWhereUniqueInput
    /**
     * In case the Epic found by the `where` argument doesn't exist, create a new Epic with this data.
     */
    create: XOR<EpicCreateInput, EpicUncheckedCreateInput>
    /**
     * In case the Epic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EpicUpdateInput, EpicUncheckedUpdateInput>
  }

  /**
   * Epic delete
   */
  export type EpicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    /**
     * Filter which Epic to delete.
     */
    where: EpicWhereUniqueInput
  }

  /**
   * Epic deleteMany
   */
  export type EpicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Epics to delete
     */
    where?: EpicWhereInput
    /**
     * Limit how many Epics to delete.
     */
    limit?: number
  }

  /**
   * Epic.userStories
   */
  export type Epic$userStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    where?: UserStoryWhereInput
    orderBy?: UserStoryOrderByWithRelationInput | UserStoryOrderByWithRelationInput[]
    cursor?: UserStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserStoryScalarFieldEnum | UserStoryScalarFieldEnum[]
  }

  /**
   * Epic.comments
   */
  export type Epic$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Epic without action
   */
  export type EpicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
  }


  /**
   * Model UserStory
   */

  export type AggregateUserStory = {
    _count: UserStoryCountAggregateOutputType | null
    _avg: UserStoryAvgAggregateOutputType | null
    _sum: UserStorySumAggregateOutputType | null
    _min: UserStoryMinAggregateOutputType | null
    _max: UserStoryMaxAggregateOutputType | null
  }

  export type UserStoryAvgAggregateOutputType = {
    priority: number | null
  }

  export type UserStorySumAggregateOutputType = {
    priority: number | null
  }

  export type UserStoryMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.Status | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    epicId: string | null
    creatorId: string | null
    sprintId: string | null
  }

  export type UserStoryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.Status | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    epicId: string | null
    creatorId: string | null
    sprintId: string | null
  }

  export type UserStoryCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    projectId: number
    epicId: number
    creatorId: number
    sprintId: number
    _all: number
  }


  export type UserStoryAvgAggregateInputType = {
    priority?: true
  }

  export type UserStorySumAggregateInputType = {
    priority?: true
  }

  export type UserStoryMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    epicId?: true
    creatorId?: true
    sprintId?: true
  }

  export type UserStoryMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    epicId?: true
    creatorId?: true
    sprintId?: true
  }

  export type UserStoryCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    epicId?: true
    creatorId?: true
    sprintId?: true
    _all?: true
  }

  export type UserStoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStory to aggregate.
     */
    where?: UserStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStories to fetch.
     */
    orderBy?: UserStoryOrderByWithRelationInput | UserStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStories
    **/
    _count?: true | UserStoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserStoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserStorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStoryMaxAggregateInputType
  }

  export type GetUserStoryAggregateType<T extends UserStoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStory[P]>
      : GetScalarType<T[P], AggregateUserStory[P]>
  }




  export type UserStoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStoryWhereInput
    orderBy?: UserStoryOrderByWithAggregationInput | UserStoryOrderByWithAggregationInput[]
    by: UserStoryScalarFieldEnum[] | UserStoryScalarFieldEnum
    having?: UserStoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStoryCountAggregateInputType | true
    _avg?: UserStoryAvgAggregateInputType
    _sum?: UserStorySumAggregateInputType
    _min?: UserStoryMinAggregateInputType
    _max?: UserStoryMaxAggregateInputType
  }

  export type UserStoryGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.Status
    priority: number
    createdAt: Date
    updatedAt: Date
    projectId: string
    epicId: string | null
    creatorId: string
    sprintId: string | null
    _count: UserStoryCountAggregateOutputType | null
    _avg: UserStoryAvgAggregateOutputType | null
    _sum: UserStorySumAggregateOutputType | null
    _min: UserStoryMinAggregateOutputType | null
    _max: UserStoryMaxAggregateOutputType | null
  }

  type GetUserStoryGroupByPayload<T extends UserStoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserStoryGroupByOutputType[P]>
        }
      >
    >


  export type UserStorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    epicId?: boolean
    creatorId?: boolean
    sprintId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    epic?: boolean | UserStory$epicArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    sprint?: boolean | UserStory$sprintArgs<ExtArgs>
    tasks?: boolean | UserStory$tasksArgs<ExtArgs>
    comments?: boolean | UserStory$commentsArgs<ExtArgs>
    _count?: boolean | UserStoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStory"]>

  export type UserStorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    epicId?: boolean
    creatorId?: boolean
    sprintId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    epic?: boolean | UserStory$epicArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    sprint?: boolean | UserStory$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["userStory"]>

  export type UserStorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    epicId?: boolean
    creatorId?: boolean
    sprintId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    epic?: boolean | UserStory$epicArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    sprint?: boolean | UserStory$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["userStory"]>

  export type UserStorySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    epicId?: boolean
    creatorId?: boolean
    sprintId?: boolean
  }

  export type UserStoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "priority" | "createdAt" | "updatedAt" | "projectId" | "epicId" | "creatorId" | "sprintId", ExtArgs["result"]["userStory"]>
  export type UserStoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    epic?: boolean | UserStory$epicArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    sprint?: boolean | UserStory$sprintArgs<ExtArgs>
    tasks?: boolean | UserStory$tasksArgs<ExtArgs>
    comments?: boolean | UserStory$commentsArgs<ExtArgs>
    _count?: boolean | UserStoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserStoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    epic?: boolean | UserStory$epicArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    sprint?: boolean | UserStory$sprintArgs<ExtArgs>
  }
  export type UserStoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    epic?: boolean | UserStory$epicArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    sprint?: boolean | UserStory$sprintArgs<ExtArgs>
  }

  export type $UserStoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserStory"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      epic: Prisma.$EpicPayload<ExtArgs> | null
      creator: Prisma.$MemberPayload<ExtArgs>
      sprint: Prisma.$SprintPayload<ExtArgs> | null
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.Status
      priority: number
      createdAt: Date
      updatedAt: Date
      projectId: string
      epicId: string | null
      creatorId: string
      sprintId: string | null
    }, ExtArgs["result"]["userStory"]>
    composites: {}
  }

  type UserStoryGetPayload<S extends boolean | null | undefined | UserStoryDefaultArgs> = $Result.GetResult<Prisma.$UserStoryPayload, S>

  type UserStoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserStoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserStoryCountAggregateInputType | true
    }

  export interface UserStoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserStory'], meta: { name: 'UserStory' } }
    /**
     * Find zero or one UserStory that matches the filter.
     * @param {UserStoryFindUniqueArgs} args - Arguments to find a UserStory
     * @example
     * // Get one UserStory
     * const userStory = await prisma.userStory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserStoryFindUniqueArgs>(args: SelectSubset<T, UserStoryFindUniqueArgs<ExtArgs>>): Prisma__UserStoryClient<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserStory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserStoryFindUniqueOrThrowArgs} args - Arguments to find a UserStory
     * @example
     * // Get one UserStory
     * const userStory = await prisma.userStory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserStoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserStoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserStoryClient<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoryFindFirstArgs} args - Arguments to find a UserStory
     * @example
     * // Get one UserStory
     * const userStory = await prisma.userStory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserStoryFindFirstArgs>(args?: SelectSubset<T, UserStoryFindFirstArgs<ExtArgs>>): Prisma__UserStoryClient<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoryFindFirstOrThrowArgs} args - Arguments to find a UserStory
     * @example
     * // Get one UserStory
     * const userStory = await prisma.userStory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserStoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserStoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserStoryClient<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStories
     * const userStories = await prisma.userStory.findMany()
     * 
     * // Get first 10 UserStories
     * const userStories = await prisma.userStory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userStoryWithIdOnly = await prisma.userStory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserStoryFindManyArgs>(args?: SelectSubset<T, UserStoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserStory.
     * @param {UserStoryCreateArgs} args - Arguments to create a UserStory.
     * @example
     * // Create one UserStory
     * const UserStory = await prisma.userStory.create({
     *   data: {
     *     // ... data to create a UserStory
     *   }
     * })
     * 
     */
    create<T extends UserStoryCreateArgs>(args: SelectSubset<T, UserStoryCreateArgs<ExtArgs>>): Prisma__UserStoryClient<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserStories.
     * @param {UserStoryCreateManyArgs} args - Arguments to create many UserStories.
     * @example
     * // Create many UserStories
     * const userStory = await prisma.userStory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserStoryCreateManyArgs>(args?: SelectSubset<T, UserStoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserStories and returns the data saved in the database.
     * @param {UserStoryCreateManyAndReturnArgs} args - Arguments to create many UserStories.
     * @example
     * // Create many UserStories
     * const userStory = await prisma.userStory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserStories and only return the `id`
     * const userStoryWithIdOnly = await prisma.userStory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserStoryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserStoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserStory.
     * @param {UserStoryDeleteArgs} args - Arguments to delete one UserStory.
     * @example
     * // Delete one UserStory
     * const UserStory = await prisma.userStory.delete({
     *   where: {
     *     // ... filter to delete one UserStory
     *   }
     * })
     * 
     */
    delete<T extends UserStoryDeleteArgs>(args: SelectSubset<T, UserStoryDeleteArgs<ExtArgs>>): Prisma__UserStoryClient<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserStory.
     * @param {UserStoryUpdateArgs} args - Arguments to update one UserStory.
     * @example
     * // Update one UserStory
     * const userStory = await prisma.userStory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserStoryUpdateArgs>(args: SelectSubset<T, UserStoryUpdateArgs<ExtArgs>>): Prisma__UserStoryClient<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserStories.
     * @param {UserStoryDeleteManyArgs} args - Arguments to filter UserStories to delete.
     * @example
     * // Delete a few UserStories
     * const { count } = await prisma.userStory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserStoryDeleteManyArgs>(args?: SelectSubset<T, UserStoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStories
     * const userStory = await prisma.userStory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserStoryUpdateManyArgs>(args: SelectSubset<T, UserStoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStories and returns the data updated in the database.
     * @param {UserStoryUpdateManyAndReturnArgs} args - Arguments to update many UserStories.
     * @example
     * // Update many UserStories
     * const userStory = await prisma.userStory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserStories and only return the `id`
     * const userStoryWithIdOnly = await prisma.userStory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserStoryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserStoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserStory.
     * @param {UserStoryUpsertArgs} args - Arguments to update or create a UserStory.
     * @example
     * // Update or create a UserStory
     * const userStory = await prisma.userStory.upsert({
     *   create: {
     *     // ... data to create a UserStory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStory we want to update
     *   }
     * })
     */
    upsert<T extends UserStoryUpsertArgs>(args: SelectSubset<T, UserStoryUpsertArgs<ExtArgs>>): Prisma__UserStoryClient<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoryCountArgs} args - Arguments to filter UserStories to count.
     * @example
     * // Count the number of UserStories
     * const count = await prisma.userStory.count({
     *   where: {
     *     // ... the filter for the UserStories we want to count
     *   }
     * })
    **/
    count<T extends UserStoryCountArgs>(
      args?: Subset<T, UserStoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStoryAggregateArgs>(args: Subset<T, UserStoryAggregateArgs>): Prisma.PrismaPromise<GetUserStoryAggregateType<T>>

    /**
     * Group by UserStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStoryGroupByArgs['orderBy'] }
        : { orderBy?: UserStoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserStory model
   */
  readonly fields: UserStoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserStoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    epic<T extends UserStory$epicArgs<ExtArgs> = {}>(args?: Subset<T, UserStory$epicArgs<ExtArgs>>): Prisma__EpicClient<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sprint<T extends UserStory$sprintArgs<ExtArgs> = {}>(args?: Subset<T, UserStory$sprintArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tasks<T extends UserStory$tasksArgs<ExtArgs> = {}>(args?: Subset<T, UserStory$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends UserStory$commentsArgs<ExtArgs> = {}>(args?: Subset<T, UserStory$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserStory model
   */
  interface UserStoryFieldRefs {
    readonly id: FieldRef<"UserStory", 'String'>
    readonly title: FieldRef<"UserStory", 'String'>
    readonly description: FieldRef<"UserStory", 'String'>
    readonly status: FieldRef<"UserStory", 'Status'>
    readonly priority: FieldRef<"UserStory", 'Int'>
    readonly createdAt: FieldRef<"UserStory", 'DateTime'>
    readonly updatedAt: FieldRef<"UserStory", 'DateTime'>
    readonly projectId: FieldRef<"UserStory", 'String'>
    readonly epicId: FieldRef<"UserStory", 'String'>
    readonly creatorId: FieldRef<"UserStory", 'String'>
    readonly sprintId: FieldRef<"UserStory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserStory findUnique
   */
  export type UserStoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    /**
     * Filter, which UserStory to fetch.
     */
    where: UserStoryWhereUniqueInput
  }

  /**
   * UserStory findUniqueOrThrow
   */
  export type UserStoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    /**
     * Filter, which UserStory to fetch.
     */
    where: UserStoryWhereUniqueInput
  }

  /**
   * UserStory findFirst
   */
  export type UserStoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    /**
     * Filter, which UserStory to fetch.
     */
    where?: UserStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStories to fetch.
     */
    orderBy?: UserStoryOrderByWithRelationInput | UserStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStories.
     */
    cursor?: UserStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStories.
     */
    distinct?: UserStoryScalarFieldEnum | UserStoryScalarFieldEnum[]
  }

  /**
   * UserStory findFirstOrThrow
   */
  export type UserStoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    /**
     * Filter, which UserStory to fetch.
     */
    where?: UserStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStories to fetch.
     */
    orderBy?: UserStoryOrderByWithRelationInput | UserStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStories.
     */
    cursor?: UserStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStories.
     */
    distinct?: UserStoryScalarFieldEnum | UserStoryScalarFieldEnum[]
  }

  /**
   * UserStory findMany
   */
  export type UserStoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    /**
     * Filter, which UserStories to fetch.
     */
    where?: UserStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStories to fetch.
     */
    orderBy?: UserStoryOrderByWithRelationInput | UserStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStories.
     */
    cursor?: UserStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStories.
     */
    skip?: number
    distinct?: UserStoryScalarFieldEnum | UserStoryScalarFieldEnum[]
  }

  /**
   * UserStory create
   */
  export type UserStoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserStory.
     */
    data: XOR<UserStoryCreateInput, UserStoryUncheckedCreateInput>
  }

  /**
   * UserStory createMany
   */
  export type UserStoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserStories.
     */
    data: UserStoryCreateManyInput | UserStoryCreateManyInput[]
  }

  /**
   * UserStory createManyAndReturn
   */
  export type UserStoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * The data used to create many UserStories.
     */
    data: UserStoryCreateManyInput | UserStoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStory update
   */
  export type UserStoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserStory.
     */
    data: XOR<UserStoryUpdateInput, UserStoryUncheckedUpdateInput>
    /**
     * Choose, which UserStory to update.
     */
    where: UserStoryWhereUniqueInput
  }

  /**
   * UserStory updateMany
   */
  export type UserStoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserStories.
     */
    data: XOR<UserStoryUpdateManyMutationInput, UserStoryUncheckedUpdateManyInput>
    /**
     * Filter which UserStories to update
     */
    where?: UserStoryWhereInput
    /**
     * Limit how many UserStories to update.
     */
    limit?: number
  }

  /**
   * UserStory updateManyAndReturn
   */
  export type UserStoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * The data used to update UserStories.
     */
    data: XOR<UserStoryUpdateManyMutationInput, UserStoryUncheckedUpdateManyInput>
    /**
     * Filter which UserStories to update
     */
    where?: UserStoryWhereInput
    /**
     * Limit how many UserStories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStory upsert
   */
  export type UserStoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserStory to update in case it exists.
     */
    where: UserStoryWhereUniqueInput
    /**
     * In case the UserStory found by the `where` argument doesn't exist, create a new UserStory with this data.
     */
    create: XOR<UserStoryCreateInput, UserStoryUncheckedCreateInput>
    /**
     * In case the UserStory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserStoryUpdateInput, UserStoryUncheckedUpdateInput>
  }

  /**
   * UserStory delete
   */
  export type UserStoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    /**
     * Filter which UserStory to delete.
     */
    where: UserStoryWhereUniqueInput
  }

  /**
   * UserStory deleteMany
   */
  export type UserStoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStories to delete
     */
    where?: UserStoryWhereInput
    /**
     * Limit how many UserStories to delete.
     */
    limit?: number
  }

  /**
   * UserStory.epic
   */
  export type UserStory$epicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    where?: EpicWhereInput
  }

  /**
   * UserStory.sprint
   */
  export type UserStory$sprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
  }

  /**
   * UserStory.tasks
   */
  export type UserStory$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * UserStory.comments
   */
  export type UserStory$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * UserStory without action
   */
  export type UserStoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
  }


  /**
   * Model Sprint
   */

  export type AggregateSprint = {
    _count: SprintCountAggregateOutputType | null
    _min: SprintMinAggregateOutputType | null
    _max: SprintMaxAggregateOutputType | null
  }

  export type SprintMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.Status | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    creatorId: string | null
  }

  export type SprintMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.Status | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    creatorId: string | null
  }

  export type SprintCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    projectId: number
    creatorId: number
    _all: number
  }


  export type SprintMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    creatorId?: true
  }

  export type SprintMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    creatorId?: true
  }

  export type SprintCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    creatorId?: true
    _all?: true
  }

  export type SprintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sprint to aggregate.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sprints
    **/
    _count?: true | SprintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SprintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SprintMaxAggregateInputType
  }

  export type GetSprintAggregateType<T extends SprintAggregateArgs> = {
        [P in keyof T & keyof AggregateSprint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSprint[P]>
      : GetScalarType<T[P], AggregateSprint[P]>
  }




  export type SprintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SprintWhereInput
    orderBy?: SprintOrderByWithAggregationInput | SprintOrderByWithAggregationInput[]
    by: SprintScalarFieldEnum[] | SprintScalarFieldEnum
    having?: SprintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SprintCountAggregateInputType | true
    _min?: SprintMinAggregateInputType
    _max?: SprintMaxAggregateInputType
  }

  export type SprintGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: $Enums.Status
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    creatorId: string
    _count: SprintCountAggregateOutputType | null
    _min: SprintMinAggregateOutputType | null
    _max: SprintMaxAggregateOutputType | null
  }

  type GetSprintGroupByPayload<T extends SprintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SprintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SprintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SprintGroupByOutputType[P]>
            : GetScalarType<T[P], SprintGroupByOutputType[P]>
        }
      >
    >


  export type SprintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    userStories?: boolean | Sprint$userStoriesArgs<ExtArgs>
    tasks?: boolean | Sprint$tasksArgs<ExtArgs>
    subtasks?: boolean | Sprint$subtasksArgs<ExtArgs>
    files?: boolean | Sprint$filesArgs<ExtArgs>
    _count?: boolean | SprintCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    creatorId?: boolean
  }

  export type SprintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "projectId" | "creatorId", ExtArgs["result"]["sprint"]>
  export type SprintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    userStories?: boolean | Sprint$userStoriesArgs<ExtArgs>
    tasks?: boolean | Sprint$tasksArgs<ExtArgs>
    subtasks?: boolean | Sprint$subtasksArgs<ExtArgs>
    files?: boolean | Sprint$filesArgs<ExtArgs>
    _count?: boolean | SprintCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SprintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type SprintIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $SprintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sprint"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$MemberPayload<ExtArgs>
      userStories: Prisma.$UserStoryPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      subtasks: Prisma.$SubtaskPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: $Enums.Status
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
      projectId: string
      creatorId: string
    }, ExtArgs["result"]["sprint"]>
    composites: {}
  }

  type SprintGetPayload<S extends boolean | null | undefined | SprintDefaultArgs> = $Result.GetResult<Prisma.$SprintPayload, S>

  type SprintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SprintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SprintCountAggregateInputType | true
    }

  export interface SprintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sprint'], meta: { name: 'Sprint' } }
    /**
     * Find zero or one Sprint that matches the filter.
     * @param {SprintFindUniqueArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SprintFindUniqueArgs>(args: SelectSubset<T, SprintFindUniqueArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sprint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SprintFindUniqueOrThrowArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SprintFindUniqueOrThrowArgs>(args: SelectSubset<T, SprintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sprint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindFirstArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SprintFindFirstArgs>(args?: SelectSubset<T, SprintFindFirstArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sprint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindFirstOrThrowArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SprintFindFirstOrThrowArgs>(args?: SelectSubset<T, SprintFindFirstOrThrowArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sprints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sprints
     * const sprints = await prisma.sprint.findMany()
     * 
     * // Get first 10 Sprints
     * const sprints = await prisma.sprint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sprintWithIdOnly = await prisma.sprint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SprintFindManyArgs>(args?: SelectSubset<T, SprintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sprint.
     * @param {SprintCreateArgs} args - Arguments to create a Sprint.
     * @example
     * // Create one Sprint
     * const Sprint = await prisma.sprint.create({
     *   data: {
     *     // ... data to create a Sprint
     *   }
     * })
     * 
     */
    create<T extends SprintCreateArgs>(args: SelectSubset<T, SprintCreateArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sprints.
     * @param {SprintCreateManyArgs} args - Arguments to create many Sprints.
     * @example
     * // Create many Sprints
     * const sprint = await prisma.sprint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SprintCreateManyArgs>(args?: SelectSubset<T, SprintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sprints and returns the data saved in the database.
     * @param {SprintCreateManyAndReturnArgs} args - Arguments to create many Sprints.
     * @example
     * // Create many Sprints
     * const sprint = await prisma.sprint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sprints and only return the `id`
     * const sprintWithIdOnly = await prisma.sprint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SprintCreateManyAndReturnArgs>(args?: SelectSubset<T, SprintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sprint.
     * @param {SprintDeleteArgs} args - Arguments to delete one Sprint.
     * @example
     * // Delete one Sprint
     * const Sprint = await prisma.sprint.delete({
     *   where: {
     *     // ... filter to delete one Sprint
     *   }
     * })
     * 
     */
    delete<T extends SprintDeleteArgs>(args: SelectSubset<T, SprintDeleteArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sprint.
     * @param {SprintUpdateArgs} args - Arguments to update one Sprint.
     * @example
     * // Update one Sprint
     * const sprint = await prisma.sprint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SprintUpdateArgs>(args: SelectSubset<T, SprintUpdateArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sprints.
     * @param {SprintDeleteManyArgs} args - Arguments to filter Sprints to delete.
     * @example
     * // Delete a few Sprints
     * const { count } = await prisma.sprint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SprintDeleteManyArgs>(args?: SelectSubset<T, SprintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sprints
     * const sprint = await prisma.sprint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SprintUpdateManyArgs>(args: SelectSubset<T, SprintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sprints and returns the data updated in the database.
     * @param {SprintUpdateManyAndReturnArgs} args - Arguments to update many Sprints.
     * @example
     * // Update many Sprints
     * const sprint = await prisma.sprint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sprints and only return the `id`
     * const sprintWithIdOnly = await prisma.sprint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SprintUpdateManyAndReturnArgs>(args: SelectSubset<T, SprintUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sprint.
     * @param {SprintUpsertArgs} args - Arguments to update or create a Sprint.
     * @example
     * // Update or create a Sprint
     * const sprint = await prisma.sprint.upsert({
     *   create: {
     *     // ... data to create a Sprint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sprint we want to update
     *   }
     * })
     */
    upsert<T extends SprintUpsertArgs>(args: SelectSubset<T, SprintUpsertArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintCountArgs} args - Arguments to filter Sprints to count.
     * @example
     * // Count the number of Sprints
     * const count = await prisma.sprint.count({
     *   where: {
     *     // ... the filter for the Sprints we want to count
     *   }
     * })
    **/
    count<T extends SprintCountArgs>(
      args?: Subset<T, SprintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SprintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SprintAggregateArgs>(args: Subset<T, SprintAggregateArgs>): Prisma.PrismaPromise<GetSprintAggregateType<T>>

    /**
     * Group by Sprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SprintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SprintGroupByArgs['orderBy'] }
        : { orderBy?: SprintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SprintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSprintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sprint model
   */
  readonly fields: SprintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sprint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SprintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userStories<T extends Sprint$userStoriesArgs<ExtArgs> = {}>(args?: Subset<T, Sprint$userStoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Sprint$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Sprint$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subtasks<T extends Sprint$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, Sprint$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Sprint$filesArgs<ExtArgs> = {}>(args?: Subset<T, Sprint$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sprint model
   */
  interface SprintFieldRefs {
    readonly id: FieldRef<"Sprint", 'String'>
    readonly name: FieldRef<"Sprint", 'String'>
    readonly description: FieldRef<"Sprint", 'String'>
    readonly status: FieldRef<"Sprint", 'Status'>
    readonly startDate: FieldRef<"Sprint", 'DateTime'>
    readonly endDate: FieldRef<"Sprint", 'DateTime'>
    readonly createdAt: FieldRef<"Sprint", 'DateTime'>
    readonly updatedAt: FieldRef<"Sprint", 'DateTime'>
    readonly projectId: FieldRef<"Sprint", 'String'>
    readonly creatorId: FieldRef<"Sprint", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sprint findUnique
   */
  export type SprintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint findUniqueOrThrow
   */
  export type SprintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint findFirst
   */
  export type SprintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sprints.
     */
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint findFirstOrThrow
   */
  export type SprintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sprints.
     */
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint findMany
   */
  export type SprintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprints to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint create
   */
  export type SprintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The data needed to create a Sprint.
     */
    data: XOR<SprintCreateInput, SprintUncheckedCreateInput>
  }

  /**
   * Sprint createMany
   */
  export type SprintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sprints.
     */
    data: SprintCreateManyInput | SprintCreateManyInput[]
  }

  /**
   * Sprint createManyAndReturn
   */
  export type SprintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * The data used to create many Sprints.
     */
    data: SprintCreateManyInput | SprintCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sprint update
   */
  export type SprintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The data needed to update a Sprint.
     */
    data: XOR<SprintUpdateInput, SprintUncheckedUpdateInput>
    /**
     * Choose, which Sprint to update.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint updateMany
   */
  export type SprintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sprints.
     */
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyInput>
    /**
     * Filter which Sprints to update
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to update.
     */
    limit?: number
  }

  /**
   * Sprint updateManyAndReturn
   */
  export type SprintUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * The data used to update Sprints.
     */
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyInput>
    /**
     * Filter which Sprints to update
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sprint upsert
   */
  export type SprintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The filter to search for the Sprint to update in case it exists.
     */
    where: SprintWhereUniqueInput
    /**
     * In case the Sprint found by the `where` argument doesn't exist, create a new Sprint with this data.
     */
    create: XOR<SprintCreateInput, SprintUncheckedCreateInput>
    /**
     * In case the Sprint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SprintUpdateInput, SprintUncheckedUpdateInput>
  }

  /**
   * Sprint delete
   */
  export type SprintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter which Sprint to delete.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint deleteMany
   */
  export type SprintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sprints to delete
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to delete.
     */
    limit?: number
  }

  /**
   * Sprint.userStories
   */
  export type Sprint$userStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    where?: UserStoryWhereInput
    orderBy?: UserStoryOrderByWithRelationInput | UserStoryOrderByWithRelationInput[]
    cursor?: UserStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserStoryScalarFieldEnum | UserStoryScalarFieldEnum[]
  }

  /**
   * Sprint.tasks
   */
  export type Sprint$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Sprint.subtasks
   */
  export type Sprint$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    cursor?: SubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Sprint.files
   */
  export type Sprint$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Sprint without action
   */
  export type SprintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    priority: number | null
    estimatedDuration: number | null
  }

  export type TaskSumAggregateOutputType = {
    priority: number | null
    estimatedDuration: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.Status | null
    priority: number | null
    dueDate: Date | null
    estimatedDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    themaId: string | null
    userStoryId: string | null
    sprintId: string | null
    assigneeId: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.Status | null
    priority: number | null
    dueDate: Date | null
    estimatedDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    themaId: string | null
    userStoryId: string | null
    sprintId: string | null
    assigneeId: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    estimatedDuration: number
    createdAt: number
    updatedAt: number
    themaId: number
    userStoryId: number
    sprintId: number
    assigneeId: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    priority?: true
    estimatedDuration?: true
  }

  export type TaskSumAggregateInputType = {
    priority?: true
    estimatedDuration?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    estimatedDuration?: true
    createdAt?: true
    updatedAt?: true
    themaId?: true
    userStoryId?: true
    sprintId?: true
    assigneeId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    estimatedDuration?: true
    createdAt?: true
    updatedAt?: true
    themaId?: true
    userStoryId?: true
    sprintId?: true
    assigneeId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    estimatedDuration?: true
    createdAt?: true
    updatedAt?: true
    themaId?: true
    userStoryId?: true
    sprintId?: true
    assigneeId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.Status
    priority: number
    dueDate: Date | null
    estimatedDuration: number | null
    createdAt: Date
    updatedAt: Date
    themaId: string | null
    userStoryId: string | null
    sprintId: string | null
    assigneeId: string | null
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    themaId?: boolean
    userStoryId?: boolean
    sprintId?: boolean
    assigneeId?: boolean
    thema?: boolean | Task$themaArgs<ExtArgs>
    userStory?: boolean | Task$userStoryArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    subtasks?: boolean | Task$subtasksArgs<ExtArgs>
    dependencies?: boolean | Task$dependenciesArgs<ExtArgs>
    blockedBy?: boolean | Task$blockedByArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    timeLogs?: boolean | Task$timeLogsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    themaId?: boolean
    userStoryId?: boolean
    sprintId?: boolean
    assigneeId?: boolean
    thema?: boolean | Task$themaArgs<ExtArgs>
    userStory?: boolean | Task$userStoryArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    themaId?: boolean
    userStoryId?: boolean
    sprintId?: boolean
    assigneeId?: boolean
    thema?: boolean | Task$themaArgs<ExtArgs>
    userStory?: boolean | Task$userStoryArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    themaId?: boolean
    userStoryId?: boolean
    sprintId?: boolean
    assigneeId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "priority" | "dueDate" | "estimatedDuration" | "createdAt" | "updatedAt" | "themaId" | "userStoryId" | "sprintId" | "assigneeId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thema?: boolean | Task$themaArgs<ExtArgs>
    userStory?: boolean | Task$userStoryArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    subtasks?: boolean | Task$subtasksArgs<ExtArgs>
    dependencies?: boolean | Task$dependenciesArgs<ExtArgs>
    blockedBy?: boolean | Task$blockedByArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    timeLogs?: boolean | Task$timeLogsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thema?: boolean | Task$themaArgs<ExtArgs>
    userStory?: boolean | Task$userStoryArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thema?: boolean | Task$themaArgs<ExtArgs>
    userStory?: boolean | Task$userStoryArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      thema: Prisma.$ThemaPayload<ExtArgs> | null
      userStory: Prisma.$UserStoryPayload<ExtArgs> | null
      sprint: Prisma.$SprintPayload<ExtArgs> | null
      assignee: Prisma.$MemberPayload<ExtArgs> | null
      subtasks: Prisma.$SubtaskPayload<ExtArgs>[]
      dependencies: Prisma.$TaskPayload<ExtArgs>[]
      blockedBy: Prisma.$TaskPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      timeLogs: Prisma.$TimeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.Status
      priority: number
      dueDate: Date | null
      estimatedDuration: number | null
      createdAt: Date
      updatedAt: Date
      themaId: string | null
      userStoryId: string | null
      sprintId: string | null
      assigneeId: string | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thema<T extends Task$themaArgs<ExtArgs> = {}>(args?: Subset<T, Task$themaArgs<ExtArgs>>): Prisma__ThemaClient<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userStory<T extends Task$userStoryArgs<ExtArgs> = {}>(args?: Subset<T, Task$userStoryArgs<ExtArgs>>): Prisma__UserStoryClient<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sprint<T extends Task$sprintArgs<ExtArgs> = {}>(args?: Subset<T, Task$sprintArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignee<T extends Task$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, Task$assigneeArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subtasks<T extends Task$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, Task$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dependencies<T extends Task$dependenciesArgs<ExtArgs> = {}>(args?: Subset<T, Task$dependenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blockedBy<T extends Task$blockedByArgs<ExtArgs> = {}>(args?: Subset<T, Task$blockedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Task$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeLogs<T extends Task$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, Task$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'Status'>
    readonly priority: FieldRef<"Task", 'Int'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly estimatedDuration: FieldRef<"Task", 'Int'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly themaId: FieldRef<"Task", 'String'>
    readonly userStoryId: FieldRef<"Task", 'String'>
    readonly sprintId: FieldRef<"Task", 'String'>
    readonly assigneeId: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.thema
   */
  export type Task$themaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    where?: ThemaWhereInput
  }

  /**
   * Task.userStory
   */
  export type Task$userStoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    where?: UserStoryWhereInput
  }

  /**
   * Task.sprint
   */
  export type Task$sprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
  }

  /**
   * Task.assignee
   */
  export type Task$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * Task.subtasks
   */
  export type Task$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    cursor?: SubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Task.dependencies
   */
  export type Task$dependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task.blockedBy
   */
  export type Task$blockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task.comments
   */
  export type Task$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Task.timeLogs
   */
  export type Task$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    cursor?: TimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Subtask
   */

  export type AggregateSubtask = {
    _count: SubtaskCountAggregateOutputType | null
    _min: SubtaskMinAggregateOutputType | null
    _max: SubtaskMaxAggregateOutputType | null
  }

  export type SubtaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    taskId: string | null
    sprintId: string | null
    assigneeId: string | null
  }

  export type SubtaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    taskId: string | null
    sprintId: string | null
    assigneeId: string | null
  }

  export type SubtaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    taskId: number
    sprintId: number
    assigneeId: number
    _all: number
  }


  export type SubtaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    taskId?: true
    sprintId?: true
    assigneeId?: true
  }

  export type SubtaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    taskId?: true
    sprintId?: true
    assigneeId?: true
  }

  export type SubtaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    taskId?: true
    sprintId?: true
    assigneeId?: true
    _all?: true
  }

  export type SubtaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtask to aggregate.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subtasks
    **/
    _count?: true | SubtaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtaskMaxAggregateInputType
  }

  export type GetSubtaskAggregateType<T extends SubtaskAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtask[P]>
      : GetScalarType<T[P], AggregateSubtask[P]>
  }




  export type SubtaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithAggregationInput | SubtaskOrderByWithAggregationInput[]
    by: SubtaskScalarFieldEnum[] | SubtaskScalarFieldEnum
    having?: SubtaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtaskCountAggregateInputType | true
    _min?: SubtaskMinAggregateInputType
    _max?: SubtaskMaxAggregateInputType
  }

  export type SubtaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    taskId: string
    sprintId: string | null
    assigneeId: string | null
    _count: SubtaskCountAggregateOutputType | null
    _min: SubtaskMinAggregateOutputType | null
    _max: SubtaskMaxAggregateOutputType | null
  }

  type GetSubtaskGroupByPayload<T extends SubtaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubtaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtaskGroupByOutputType[P]>
            : GetScalarType<T[P], SubtaskGroupByOutputType[P]>
        }
      >
    >


  export type SubtaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taskId?: boolean
    sprintId?: boolean
    assigneeId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sprint?: boolean | Subtask$sprintArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
    files?: boolean | Subtask$filesArgs<ExtArgs>
    _count?: boolean | SubtaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtask"]>

  export type SubtaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taskId?: boolean
    sprintId?: boolean
    assigneeId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sprint?: boolean | Subtask$sprintArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["subtask"]>

  export type SubtaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taskId?: boolean
    sprintId?: boolean
    assigneeId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sprint?: boolean | Subtask$sprintArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["subtask"]>

  export type SubtaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taskId?: boolean
    sprintId?: boolean
    assigneeId?: boolean
  }

  export type SubtaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "createdAt" | "updatedAt" | "taskId" | "sprintId" | "assigneeId", ExtArgs["result"]["subtask"]>
  export type SubtaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sprint?: boolean | Subtask$sprintArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
    files?: boolean | Subtask$filesArgs<ExtArgs>
    _count?: boolean | SubtaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubtaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sprint?: boolean | Subtask$sprintArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
  }
  export type SubtaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    sprint?: boolean | Subtask$sprintArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
  }

  export type $SubtaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subtask"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      sprint: Prisma.$SprintPayload<ExtArgs> | null
      assignee: Prisma.$MemberPayload<ExtArgs> | null
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
      taskId: string
      sprintId: string | null
      assigneeId: string | null
    }, ExtArgs["result"]["subtask"]>
    composites: {}
  }

  type SubtaskGetPayload<S extends boolean | null | undefined | SubtaskDefaultArgs> = $Result.GetResult<Prisma.$SubtaskPayload, S>

  type SubtaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubtaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubtaskCountAggregateInputType | true
    }

  export interface SubtaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subtask'], meta: { name: 'Subtask' } }
    /**
     * Find zero or one Subtask that matches the filter.
     * @param {SubtaskFindUniqueArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubtaskFindUniqueArgs>(args: SelectSubset<T, SubtaskFindUniqueArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subtask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubtaskFindUniqueOrThrowArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubtaskFindUniqueOrThrowArgs>(args: SelectSubset<T, SubtaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subtask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindFirstArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubtaskFindFirstArgs>(args?: SelectSubset<T, SubtaskFindFirstArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subtask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindFirstOrThrowArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubtaskFindFirstOrThrowArgs>(args?: SelectSubset<T, SubtaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subtasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subtasks
     * const subtasks = await prisma.subtask.findMany()
     * 
     * // Get first 10 Subtasks
     * const subtasks = await prisma.subtask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subtaskWithIdOnly = await prisma.subtask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubtaskFindManyArgs>(args?: SelectSubset<T, SubtaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subtask.
     * @param {SubtaskCreateArgs} args - Arguments to create a Subtask.
     * @example
     * // Create one Subtask
     * const Subtask = await prisma.subtask.create({
     *   data: {
     *     // ... data to create a Subtask
     *   }
     * })
     * 
     */
    create<T extends SubtaskCreateArgs>(args: SelectSubset<T, SubtaskCreateArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subtasks.
     * @param {SubtaskCreateManyArgs} args - Arguments to create many Subtasks.
     * @example
     * // Create many Subtasks
     * const subtask = await prisma.subtask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubtaskCreateManyArgs>(args?: SelectSubset<T, SubtaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subtasks and returns the data saved in the database.
     * @param {SubtaskCreateManyAndReturnArgs} args - Arguments to create many Subtasks.
     * @example
     * // Create many Subtasks
     * const subtask = await prisma.subtask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subtasks and only return the `id`
     * const subtaskWithIdOnly = await prisma.subtask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubtaskCreateManyAndReturnArgs>(args?: SelectSubset<T, SubtaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subtask.
     * @param {SubtaskDeleteArgs} args - Arguments to delete one Subtask.
     * @example
     * // Delete one Subtask
     * const Subtask = await prisma.subtask.delete({
     *   where: {
     *     // ... filter to delete one Subtask
     *   }
     * })
     * 
     */
    delete<T extends SubtaskDeleteArgs>(args: SelectSubset<T, SubtaskDeleteArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subtask.
     * @param {SubtaskUpdateArgs} args - Arguments to update one Subtask.
     * @example
     * // Update one Subtask
     * const subtask = await prisma.subtask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubtaskUpdateArgs>(args: SelectSubset<T, SubtaskUpdateArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subtasks.
     * @param {SubtaskDeleteManyArgs} args - Arguments to filter Subtasks to delete.
     * @example
     * // Delete a few Subtasks
     * const { count } = await prisma.subtask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubtaskDeleteManyArgs>(args?: SelectSubset<T, SubtaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subtasks
     * const subtask = await prisma.subtask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubtaskUpdateManyArgs>(args: SelectSubset<T, SubtaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subtasks and returns the data updated in the database.
     * @param {SubtaskUpdateManyAndReturnArgs} args - Arguments to update many Subtasks.
     * @example
     * // Update many Subtasks
     * const subtask = await prisma.subtask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subtasks and only return the `id`
     * const subtaskWithIdOnly = await prisma.subtask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubtaskUpdateManyAndReturnArgs>(args: SelectSubset<T, SubtaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subtask.
     * @param {SubtaskUpsertArgs} args - Arguments to update or create a Subtask.
     * @example
     * // Update or create a Subtask
     * const subtask = await prisma.subtask.upsert({
     *   create: {
     *     // ... data to create a Subtask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subtask we want to update
     *   }
     * })
     */
    upsert<T extends SubtaskUpsertArgs>(args: SelectSubset<T, SubtaskUpsertArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskCountArgs} args - Arguments to filter Subtasks to count.
     * @example
     * // Count the number of Subtasks
     * const count = await prisma.subtask.count({
     *   where: {
     *     // ... the filter for the Subtasks we want to count
     *   }
     * })
    **/
    count<T extends SubtaskCountArgs>(
      args?: Subset<T, SubtaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtaskAggregateArgs>(args: Subset<T, SubtaskAggregateArgs>): Prisma.PrismaPromise<GetSubtaskAggregateType<T>>

    /**
     * Group by Subtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubtaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubtaskGroupByArgs['orderBy'] }
        : { orderBy?: SubtaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubtaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subtask model
   */
  readonly fields: SubtaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subtask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubtaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sprint<T extends Subtask$sprintArgs<ExtArgs> = {}>(args?: Subset<T, Subtask$sprintArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignee<T extends Subtask$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, Subtask$assigneeArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    files<T extends Subtask$filesArgs<ExtArgs> = {}>(args?: Subset<T, Subtask$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subtask model
   */
  interface SubtaskFieldRefs {
    readonly id: FieldRef<"Subtask", 'String'>
    readonly title: FieldRef<"Subtask", 'String'>
    readonly description: FieldRef<"Subtask", 'String'>
    readonly status: FieldRef<"Subtask", 'Status'>
    readonly createdAt: FieldRef<"Subtask", 'DateTime'>
    readonly updatedAt: FieldRef<"Subtask", 'DateTime'>
    readonly taskId: FieldRef<"Subtask", 'String'>
    readonly sprintId: FieldRef<"Subtask", 'String'>
    readonly assigneeId: FieldRef<"Subtask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subtask findUnique
   */
  export type SubtaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask findUniqueOrThrow
   */
  export type SubtaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask findFirst
   */
  export type SubtaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtasks.
     */
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask findFirstOrThrow
   */
  export type SubtaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtasks.
     */
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask findMany
   */
  export type SubtaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtasks to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask create
   */
  export type SubtaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Subtask.
     */
    data: XOR<SubtaskCreateInput, SubtaskUncheckedCreateInput>
  }

  /**
   * Subtask createMany
   */
  export type SubtaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subtasks.
     */
    data: SubtaskCreateManyInput | SubtaskCreateManyInput[]
  }

  /**
   * Subtask createManyAndReturn
   */
  export type SubtaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * The data used to create many Subtasks.
     */
    data: SubtaskCreateManyInput | SubtaskCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subtask update
   */
  export type SubtaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Subtask.
     */
    data: XOR<SubtaskUpdateInput, SubtaskUncheckedUpdateInput>
    /**
     * Choose, which Subtask to update.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask updateMany
   */
  export type SubtaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subtasks.
     */
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyInput>
    /**
     * Filter which Subtasks to update
     */
    where?: SubtaskWhereInput
    /**
     * Limit how many Subtasks to update.
     */
    limit?: number
  }

  /**
   * Subtask updateManyAndReturn
   */
  export type SubtaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * The data used to update Subtasks.
     */
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyInput>
    /**
     * Filter which Subtasks to update
     */
    where?: SubtaskWhereInput
    /**
     * Limit how many Subtasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subtask upsert
   */
  export type SubtaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Subtask to update in case it exists.
     */
    where: SubtaskWhereUniqueInput
    /**
     * In case the Subtask found by the `where` argument doesn't exist, create a new Subtask with this data.
     */
    create: XOR<SubtaskCreateInput, SubtaskUncheckedCreateInput>
    /**
     * In case the Subtask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubtaskUpdateInput, SubtaskUncheckedUpdateInput>
  }

  /**
   * Subtask delete
   */
  export type SubtaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter which Subtask to delete.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask deleteMany
   */
  export type SubtaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtasks to delete
     */
    where?: SubtaskWhereInput
    /**
     * Limit how many Subtasks to delete.
     */
    limit?: number
  }

  /**
   * Subtask.sprint
   */
  export type Subtask$sprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
  }

  /**
   * Subtask.assignee
   */
  export type Subtask$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * Subtask.files
   */
  export type Subtask$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Subtask without action
   */
  export type SubtaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
  }


  /**
   * Model Folder
   */

  export type AggregateFolder = {
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  export type FolderMinAggregateOutputType = {
    id: string | null
    name: string | null
    path: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    projectId: string | null
  }

  export type FolderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    path: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    projectId: string | null
  }

  export type FolderCountAggregateOutputType = {
    id: number
    name: number
    path: number
    createdAt: number
    updatedAt: number
    parentId: number
    projectId: number
    _all: number
  }


  export type FolderMinAggregateInputType = {
    id?: true
    name?: true
    path?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    projectId?: true
  }

  export type FolderMaxAggregateInputType = {
    id?: true
    name?: true
    path?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    projectId?: true
  }

  export type FolderCountAggregateInputType = {
    id?: true
    name?: true
    path?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    projectId?: true
    _all?: true
  }

  export type FolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folder to aggregate.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Folders
    **/
    _count?: true | FolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderMaxAggregateInputType
  }

  export type GetFolderAggregateType<T extends FolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolder[P]>
      : GetScalarType<T[P], AggregateFolder[P]>
  }




  export type FolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithAggregationInput | FolderOrderByWithAggregationInput[]
    by: FolderScalarFieldEnum[] | FolderScalarFieldEnum
    having?: FolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FolderCountAggregateInputType | true
    _min?: FolderMinAggregateInputType
    _max?: FolderMaxAggregateInputType
  }

  export type FolderGroupByOutputType = {
    id: string
    name: string
    path: string
    createdAt: Date
    updatedAt: Date
    parentId: string | null
    projectId: string
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  type GetFolderGroupByPayload<T extends FolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderGroupByOutputType[P]>
            : GetScalarType<T[P], FolderGroupByOutputType[P]>
        }
      >
    >


  export type FolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    files?: boolean | Folder$filesArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectScalar = {
    id?: boolean
    name?: boolean
    path?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    projectId?: boolean
  }

  export type FolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "path" | "createdAt" | "updatedAt" | "parentId" | "projectId", ExtArgs["result"]["folder"]>
  export type FolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    files?: boolean | Folder$filesArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type FolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $FolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Folder"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      path: string
      createdAt: Date
      updatedAt: Date
      parentId: string | null
      projectId: string
    }, ExtArgs["result"]["folder"]>
    composites: {}
  }

  type FolderGetPayload<S extends boolean | null | undefined | FolderDefaultArgs> = $Result.GetResult<Prisma.$FolderPayload, S>

  type FolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FolderCountAggregateInputType | true
    }

  export interface FolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Folder'], meta: { name: 'Folder' } }
    /**
     * Find zero or one Folder that matches the filter.
     * @param {FolderFindUniqueArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderFindUniqueArgs>(args: SelectSubset<T, FolderFindUniqueArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Folder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FolderFindUniqueOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderFindFirstArgs>(args?: SelectSubset<T, FolderFindFirstArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folders
     * const folders = await prisma.folder.findMany()
     * 
     * // Get first 10 Folders
     * const folders = await prisma.folder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const folderWithIdOnly = await prisma.folder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FolderFindManyArgs>(args?: SelectSubset<T, FolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Folder.
     * @param {FolderCreateArgs} args - Arguments to create a Folder.
     * @example
     * // Create one Folder
     * const Folder = await prisma.folder.create({
     *   data: {
     *     // ... data to create a Folder
     *   }
     * })
     * 
     */
    create<T extends FolderCreateArgs>(args: SelectSubset<T, FolderCreateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Folders.
     * @param {FolderCreateManyArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderCreateManyArgs>(args?: SelectSubset<T, FolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Folders and returns the data saved in the database.
     * @param {FolderCreateManyAndReturnArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Folder.
     * @param {FolderDeleteArgs} args - Arguments to delete one Folder.
     * @example
     * // Delete one Folder
     * const Folder = await prisma.folder.delete({
     *   where: {
     *     // ... filter to delete one Folder
     *   }
     * })
     * 
     */
    delete<T extends FolderDeleteArgs>(args: SelectSubset<T, FolderDeleteArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Folder.
     * @param {FolderUpdateArgs} args - Arguments to update one Folder.
     * @example
     * // Update one Folder
     * const folder = await prisma.folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderUpdateArgs>(args: SelectSubset<T, FolderUpdateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Folders.
     * @param {FolderDeleteManyArgs} args - Arguments to filter Folders to delete.
     * @example
     * // Delete a few Folders
     * const { count } = await prisma.folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderDeleteManyArgs>(args?: SelectSubset<T, FolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderUpdateManyArgs>(args: SelectSubset<T, FolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders and returns the data updated in the database.
     * @param {FolderUpdateManyAndReturnArgs} args - Arguments to update many Folders.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FolderUpdateManyAndReturnArgs>(args: SelectSubset<T, FolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Folder.
     * @param {FolderUpsertArgs} args - Arguments to update or create a Folder.
     * @example
     * // Update or create a Folder
     * const folder = await prisma.folder.upsert({
     *   create: {
     *     // ... data to create a Folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folder we want to update
     *   }
     * })
     */
    upsert<T extends FolderUpsertArgs>(args: SelectSubset<T, FolderUpsertArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderCountArgs} args - Arguments to filter Folders to count.
     * @example
     * // Count the number of Folders
     * const count = await prisma.folder.count({
     *   where: {
     *     // ... the filter for the Folders we want to count
     *   }
     * })
    **/
    count<T extends FolderCountArgs>(
      args?: Subset<T, FolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderAggregateArgs>(args: Subset<T, FolderAggregateArgs>): Prisma.PrismaPromise<GetFolderAggregateType<T>>

    /**
     * Group by Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderGroupByArgs['orderBy'] }
        : { orderBy?: FolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Folder model
   */
  readonly fields: FolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    files<T extends Folder$filesArgs<ExtArgs> = {}>(args?: Subset<T, Folder$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Folder model
   */
  interface FolderFieldRefs {
    readonly id: FieldRef<"Folder", 'String'>
    readonly name: FieldRef<"Folder", 'String'>
    readonly path: FieldRef<"Folder", 'String'>
    readonly createdAt: FieldRef<"Folder", 'DateTime'>
    readonly updatedAt: FieldRef<"Folder", 'DateTime'>
    readonly parentId: FieldRef<"Folder", 'String'>
    readonly projectId: FieldRef<"Folder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Folder findUnique
   */
  export type FolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findUniqueOrThrow
   */
  export type FolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findFirst
   */
  export type FolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findFirstOrThrow
   */
  export type FolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findMany
   */
  export type FolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folders to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder create
   */
  export type FolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to create a Folder.
     */
    data: XOR<FolderCreateInput, FolderUncheckedCreateInput>
  }

  /**
   * Folder createMany
   */
  export type FolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
  }

  /**
   * Folder createManyAndReturn
   */
  export type FolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder update
   */
  export type FolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to update a Folder.
     */
    data: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
    /**
     * Choose, which Folder to update.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder updateMany
   */
  export type FolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
  }

  /**
   * Folder updateManyAndReturn
   */
  export type FolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder upsert
   */
  export type FolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The filter to search for the Folder to update in case it exists.
     */
    where: FolderWhereUniqueInput
    /**
     * In case the Folder found by the `where` argument doesn't exist, create a new Folder with this data.
     */
    create: XOR<FolderCreateInput, FolderUncheckedCreateInput>
    /**
     * In case the Folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
  }

  /**
   * Folder delete
   */
  export type FolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter which Folder to delete.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder deleteMany
   */
  export type FolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folders to delete
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to delete.
     */
    limit?: number
  }

  /**
   * Folder.files
   */
  export type Folder$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Folder without action
   */
  export type FolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
    version: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
    version: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.FileType | null
    size: number | null
    url: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    folderId: string | null
    projectId: string | null
    subtaskId: string | null
    sprintId: string | null
    uploaderId: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.FileType | null
    size: number | null
    url: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    folderId: string | null
    projectId: string | null
    subtaskId: string | null
    sprintId: string | null
    uploaderId: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    size: number
    url: number
    version: number
    createdAt: number
    updatedAt: number
    folderId: number
    projectId: number
    subtaskId: number
    sprintId: number
    uploaderId: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
    version?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
    version?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    size?: true
    url?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    folderId?: true
    projectId?: true
    subtaskId?: true
    sprintId?: true
    uploaderId?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    size?: true
    url?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    folderId?: true
    projectId?: true
    subtaskId?: true
    sprintId?: true
    uploaderId?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    size?: true
    url?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    folderId?: true
    projectId?: true
    subtaskId?: true
    sprintId?: true
    uploaderId?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.FileType
    size: number
    url: string
    version: number
    createdAt: Date
    updatedAt: Date
    folderId: string | null
    projectId: string
    subtaskId: string | null
    sprintId: string | null
    uploaderId: string
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    size?: boolean
    url?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    folderId?: boolean
    projectId?: boolean
    subtaskId?: boolean
    sprintId?: boolean
    uploaderId?: boolean
    folder?: boolean | File$folderArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    subtask?: boolean | File$subtaskArgs<ExtArgs>
    sprint?: boolean | File$sprintArgs<ExtArgs>
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
    dependencies?: boolean | File$dependenciesArgs<ExtArgs>
    relationsFrom?: boolean | File$relationsFromArgs<ExtArgs>
    relationsTo?: boolean | File$relationsToArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    size?: boolean
    url?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    folderId?: boolean
    projectId?: boolean
    subtaskId?: boolean
    sprintId?: boolean
    uploaderId?: boolean
    folder?: boolean | File$folderArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    subtask?: boolean | File$subtaskArgs<ExtArgs>
    sprint?: boolean | File$sprintArgs<ExtArgs>
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    size?: boolean
    url?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    folderId?: boolean
    projectId?: boolean
    subtaskId?: boolean
    sprintId?: boolean
    uploaderId?: boolean
    folder?: boolean | File$folderArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    subtask?: boolean | File$subtaskArgs<ExtArgs>
    sprint?: boolean | File$sprintArgs<ExtArgs>
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    size?: boolean
    url?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    folderId?: boolean
    projectId?: boolean
    subtaskId?: boolean
    sprintId?: boolean
    uploaderId?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "size" | "url" | "version" | "createdAt" | "updatedAt" | "folderId" | "projectId" | "subtaskId" | "sprintId" | "uploaderId", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | File$folderArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    subtask?: boolean | File$subtaskArgs<ExtArgs>
    sprint?: boolean | File$sprintArgs<ExtArgs>
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
    dependencies?: boolean | File$dependenciesArgs<ExtArgs>
    relationsFrom?: boolean | File$relationsFromArgs<ExtArgs>
    relationsTo?: boolean | File$relationsToArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | File$folderArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    subtask?: boolean | File$subtaskArgs<ExtArgs>
    sprint?: boolean | File$sprintArgs<ExtArgs>
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | File$folderArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    subtask?: boolean | File$subtaskArgs<ExtArgs>
    sprint?: boolean | File$sprintArgs<ExtArgs>
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      folder: Prisma.$FolderPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs>
      subtask: Prisma.$SubtaskPayload<ExtArgs> | null
      sprint: Prisma.$SprintPayload<ExtArgs> | null
      uploader: Prisma.$MemberPayload<ExtArgs>
      dependencies: Prisma.$DependencyPayload<ExtArgs>[]
      relationsFrom: Prisma.$FileRelationPayload<ExtArgs>[]
      relationsTo: Prisma.$FileRelationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.FileType
      size: number
      url: string
      version: number
      createdAt: Date
      updatedAt: Date
      folderId: string | null
      projectId: string
      subtaskId: string | null
      sprintId: string | null
      uploaderId: string
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    folder<T extends File$folderArgs<ExtArgs> = {}>(args?: Subset<T, File$folderArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subtask<T extends File$subtaskArgs<ExtArgs> = {}>(args?: Subset<T, File$subtaskArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sprint<T extends File$sprintArgs<ExtArgs> = {}>(args?: Subset<T, File$sprintArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    uploader<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dependencies<T extends File$dependenciesArgs<ExtArgs> = {}>(args?: Subset<T, File$dependenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relationsFrom<T extends File$relationsFromArgs<ExtArgs> = {}>(args?: Subset<T, File$relationsFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relationsTo<T extends File$relationsToArgs<ExtArgs> = {}>(args?: Subset<T, File$relationsToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly name: FieldRef<"File", 'String'>
    readonly description: FieldRef<"File", 'String'>
    readonly type: FieldRef<"File", 'FileType'>
    readonly size: FieldRef<"File", 'Int'>
    readonly url: FieldRef<"File", 'String'>
    readonly version: FieldRef<"File", 'Int'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
    readonly folderId: FieldRef<"File", 'String'>
    readonly projectId: FieldRef<"File", 'String'>
    readonly subtaskId: FieldRef<"File", 'String'>
    readonly sprintId: FieldRef<"File", 'String'>
    readonly uploaderId: FieldRef<"File", 'String'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.folder
   */
  export type File$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * File.subtask
   */
  export type File$subtaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
  }

  /**
   * File.sprint
   */
  export type File$sprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
  }

  /**
   * File.dependencies
   */
  export type File$dependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    where?: DependencyWhereInput
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    cursor?: DependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * File.relationsFrom
   */
  export type File$relationsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
    where?: FileRelationWhereInput
    orderBy?: FileRelationOrderByWithRelationInput | FileRelationOrderByWithRelationInput[]
    cursor?: FileRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileRelationScalarFieldEnum | FileRelationScalarFieldEnum[]
  }

  /**
   * File.relationsTo
   */
  export type File$relationsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
    where?: FileRelationWhereInput
    orderBy?: FileRelationOrderByWithRelationInput | FileRelationOrderByWithRelationInput[]
    cursor?: FileRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileRelationScalarFieldEnum | FileRelationScalarFieldEnum[]
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model Dependency
   */

  export type AggregateDependency = {
    _count: DependencyCountAggregateOutputType | null
    _min: DependencyMinAggregateOutputType | null
    _max: DependencyMaxAggregateOutputType | null
  }

  export type DependencyMinAggregateOutputType = {
    id: string | null
    fileId: string | null
    componentName: string | null
    version: string | null
    createdAt: Date | null
  }

  export type DependencyMaxAggregateOutputType = {
    id: string | null
    fileId: string | null
    componentName: string | null
    version: string | null
    createdAt: Date | null
  }

  export type DependencyCountAggregateOutputType = {
    id: number
    fileId: number
    componentName: number
    version: number
    createdAt: number
    _all: number
  }


  export type DependencyMinAggregateInputType = {
    id?: true
    fileId?: true
    componentName?: true
    version?: true
    createdAt?: true
  }

  export type DependencyMaxAggregateInputType = {
    id?: true
    fileId?: true
    componentName?: true
    version?: true
    createdAt?: true
  }

  export type DependencyCountAggregateInputType = {
    id?: true
    fileId?: true
    componentName?: true
    version?: true
    createdAt?: true
    _all?: true
  }

  export type DependencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dependency to aggregate.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dependencies
    **/
    _count?: true | DependencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DependencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DependencyMaxAggregateInputType
  }

  export type GetDependencyAggregateType<T extends DependencyAggregateArgs> = {
        [P in keyof T & keyof AggregateDependency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDependency[P]>
      : GetScalarType<T[P], AggregateDependency[P]>
  }




  export type DependencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DependencyWhereInput
    orderBy?: DependencyOrderByWithAggregationInput | DependencyOrderByWithAggregationInput[]
    by: DependencyScalarFieldEnum[] | DependencyScalarFieldEnum
    having?: DependencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DependencyCountAggregateInputType | true
    _min?: DependencyMinAggregateInputType
    _max?: DependencyMaxAggregateInputType
  }

  export type DependencyGroupByOutputType = {
    id: string
    fileId: string
    componentName: string
    version: string | null
    createdAt: Date
    _count: DependencyCountAggregateOutputType | null
    _min: DependencyMinAggregateOutputType | null
    _max: DependencyMaxAggregateOutputType | null
  }

  type GetDependencyGroupByPayload<T extends DependencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DependencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DependencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DependencyGroupByOutputType[P]>
            : GetScalarType<T[P], DependencyGroupByOutputType[P]>
        }
      >
    >


  export type DependencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    componentName?: boolean
    version?: boolean
    createdAt?: boolean
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dependency"]>

  export type DependencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    componentName?: boolean
    version?: boolean
    createdAt?: boolean
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dependency"]>

  export type DependencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    componentName?: boolean
    version?: boolean
    createdAt?: boolean
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dependency"]>

  export type DependencySelectScalar = {
    id?: boolean
    fileId?: boolean
    componentName?: boolean
    version?: boolean
    createdAt?: boolean
  }

  export type DependencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileId" | "componentName" | "version" | "createdAt", ExtArgs["result"]["dependency"]>
  export type DependencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileDefaultArgs<ExtArgs>
  }
  export type DependencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileDefaultArgs<ExtArgs>
  }
  export type DependencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileDefaultArgs<ExtArgs>
  }

  export type $DependencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dependency"
    objects: {
      file: Prisma.$FilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileId: string
      componentName: string
      version: string | null
      createdAt: Date
    }, ExtArgs["result"]["dependency"]>
    composites: {}
  }

  type DependencyGetPayload<S extends boolean | null | undefined | DependencyDefaultArgs> = $Result.GetResult<Prisma.$DependencyPayload, S>

  type DependencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DependencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DependencyCountAggregateInputType | true
    }

  export interface DependencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dependency'], meta: { name: 'Dependency' } }
    /**
     * Find zero or one Dependency that matches the filter.
     * @param {DependencyFindUniqueArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DependencyFindUniqueArgs>(args: SelectSubset<T, DependencyFindUniqueArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dependency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DependencyFindUniqueOrThrowArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DependencyFindUniqueOrThrowArgs>(args: SelectSubset<T, DependencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dependency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyFindFirstArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DependencyFindFirstArgs>(args?: SelectSubset<T, DependencyFindFirstArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dependency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyFindFirstOrThrowArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DependencyFindFirstOrThrowArgs>(args?: SelectSubset<T, DependencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dependencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dependencies
     * const dependencies = await prisma.dependency.findMany()
     * 
     * // Get first 10 Dependencies
     * const dependencies = await prisma.dependency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dependencyWithIdOnly = await prisma.dependency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DependencyFindManyArgs>(args?: SelectSubset<T, DependencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dependency.
     * @param {DependencyCreateArgs} args - Arguments to create a Dependency.
     * @example
     * // Create one Dependency
     * const Dependency = await prisma.dependency.create({
     *   data: {
     *     // ... data to create a Dependency
     *   }
     * })
     * 
     */
    create<T extends DependencyCreateArgs>(args: SelectSubset<T, DependencyCreateArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dependencies.
     * @param {DependencyCreateManyArgs} args - Arguments to create many Dependencies.
     * @example
     * // Create many Dependencies
     * const dependency = await prisma.dependency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DependencyCreateManyArgs>(args?: SelectSubset<T, DependencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dependencies and returns the data saved in the database.
     * @param {DependencyCreateManyAndReturnArgs} args - Arguments to create many Dependencies.
     * @example
     * // Create many Dependencies
     * const dependency = await prisma.dependency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dependencies and only return the `id`
     * const dependencyWithIdOnly = await prisma.dependency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DependencyCreateManyAndReturnArgs>(args?: SelectSubset<T, DependencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dependency.
     * @param {DependencyDeleteArgs} args - Arguments to delete one Dependency.
     * @example
     * // Delete one Dependency
     * const Dependency = await prisma.dependency.delete({
     *   where: {
     *     // ... filter to delete one Dependency
     *   }
     * })
     * 
     */
    delete<T extends DependencyDeleteArgs>(args: SelectSubset<T, DependencyDeleteArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dependency.
     * @param {DependencyUpdateArgs} args - Arguments to update one Dependency.
     * @example
     * // Update one Dependency
     * const dependency = await prisma.dependency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DependencyUpdateArgs>(args: SelectSubset<T, DependencyUpdateArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dependencies.
     * @param {DependencyDeleteManyArgs} args - Arguments to filter Dependencies to delete.
     * @example
     * // Delete a few Dependencies
     * const { count } = await prisma.dependency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DependencyDeleteManyArgs>(args?: SelectSubset<T, DependencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dependencies
     * const dependency = await prisma.dependency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DependencyUpdateManyArgs>(args: SelectSubset<T, DependencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dependencies and returns the data updated in the database.
     * @param {DependencyUpdateManyAndReturnArgs} args - Arguments to update many Dependencies.
     * @example
     * // Update many Dependencies
     * const dependency = await prisma.dependency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dependencies and only return the `id`
     * const dependencyWithIdOnly = await prisma.dependency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DependencyUpdateManyAndReturnArgs>(args: SelectSubset<T, DependencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dependency.
     * @param {DependencyUpsertArgs} args - Arguments to update or create a Dependency.
     * @example
     * // Update or create a Dependency
     * const dependency = await prisma.dependency.upsert({
     *   create: {
     *     // ... data to create a Dependency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dependency we want to update
     *   }
     * })
     */
    upsert<T extends DependencyUpsertArgs>(args: SelectSubset<T, DependencyUpsertArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyCountArgs} args - Arguments to filter Dependencies to count.
     * @example
     * // Count the number of Dependencies
     * const count = await prisma.dependency.count({
     *   where: {
     *     // ... the filter for the Dependencies we want to count
     *   }
     * })
    **/
    count<T extends DependencyCountArgs>(
      args?: Subset<T, DependencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DependencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DependencyAggregateArgs>(args: Subset<T, DependencyAggregateArgs>): Prisma.PrismaPromise<GetDependencyAggregateType<T>>

    /**
     * Group by Dependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DependencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DependencyGroupByArgs['orderBy'] }
        : { orderBy?: DependencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DependencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDependencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dependency model
   */
  readonly fields: DependencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dependency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DependencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends FileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FileDefaultArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dependency model
   */
  interface DependencyFieldRefs {
    readonly id: FieldRef<"Dependency", 'String'>
    readonly fileId: FieldRef<"Dependency", 'String'>
    readonly componentName: FieldRef<"Dependency", 'String'>
    readonly version: FieldRef<"Dependency", 'String'>
    readonly createdAt: FieldRef<"Dependency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dependency findUnique
   */
  export type DependencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency findUniqueOrThrow
   */
  export type DependencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency findFirst
   */
  export type DependencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dependencies.
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dependencies.
     */
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * Dependency findFirstOrThrow
   */
  export type DependencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dependencies.
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dependencies.
     */
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * Dependency findMany
   */
  export type DependencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependencies to fetch.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dependencies.
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * Dependency create
   */
  export type DependencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Dependency.
     */
    data: XOR<DependencyCreateInput, DependencyUncheckedCreateInput>
  }

  /**
   * Dependency createMany
   */
  export type DependencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dependencies.
     */
    data: DependencyCreateManyInput | DependencyCreateManyInput[]
  }

  /**
   * Dependency createManyAndReturn
   */
  export type DependencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * The data used to create many Dependencies.
     */
    data: DependencyCreateManyInput | DependencyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dependency update
   */
  export type DependencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Dependency.
     */
    data: XOR<DependencyUpdateInput, DependencyUncheckedUpdateInput>
    /**
     * Choose, which Dependency to update.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency updateMany
   */
  export type DependencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dependencies.
     */
    data: XOR<DependencyUpdateManyMutationInput, DependencyUncheckedUpdateManyInput>
    /**
     * Filter which Dependencies to update
     */
    where?: DependencyWhereInput
    /**
     * Limit how many Dependencies to update.
     */
    limit?: number
  }

  /**
   * Dependency updateManyAndReturn
   */
  export type DependencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * The data used to update Dependencies.
     */
    data: XOR<DependencyUpdateManyMutationInput, DependencyUncheckedUpdateManyInput>
    /**
     * Filter which Dependencies to update
     */
    where?: DependencyWhereInput
    /**
     * Limit how many Dependencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dependency upsert
   */
  export type DependencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Dependency to update in case it exists.
     */
    where: DependencyWhereUniqueInput
    /**
     * In case the Dependency found by the `where` argument doesn't exist, create a new Dependency with this data.
     */
    create: XOR<DependencyCreateInput, DependencyUncheckedCreateInput>
    /**
     * In case the Dependency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DependencyUpdateInput, DependencyUncheckedUpdateInput>
  }

  /**
   * Dependency delete
   */
  export type DependencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter which Dependency to delete.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency deleteMany
   */
  export type DependencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dependencies to delete
     */
    where?: DependencyWhereInput
    /**
     * Limit how many Dependencies to delete.
     */
    limit?: number
  }

  /**
   * Dependency without action
   */
  export type DependencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
  }


  /**
   * Model FileRelation
   */

  export type AggregateFileRelation = {
    _count: FileRelationCountAggregateOutputType | null
    _min: FileRelationMinAggregateOutputType | null
    _max: FileRelationMaxAggregateOutputType | null
  }

  export type FileRelationMinAggregateOutputType = {
    id: string | null
    fromFileId: string | null
    toFileId: string | null
    type: $Enums.RelationType | null
    createdAt: Date | null
  }

  export type FileRelationMaxAggregateOutputType = {
    id: string | null
    fromFileId: string | null
    toFileId: string | null
    type: $Enums.RelationType | null
    createdAt: Date | null
  }

  export type FileRelationCountAggregateOutputType = {
    id: number
    fromFileId: number
    toFileId: number
    type: number
    createdAt: number
    _all: number
  }


  export type FileRelationMinAggregateInputType = {
    id?: true
    fromFileId?: true
    toFileId?: true
    type?: true
    createdAt?: true
  }

  export type FileRelationMaxAggregateInputType = {
    id?: true
    fromFileId?: true
    toFileId?: true
    type?: true
    createdAt?: true
  }

  export type FileRelationCountAggregateInputType = {
    id?: true
    fromFileId?: true
    toFileId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type FileRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileRelation to aggregate.
     */
    where?: FileRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileRelations to fetch.
     */
    orderBy?: FileRelationOrderByWithRelationInput | FileRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileRelations
    **/
    _count?: true | FileRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileRelationMaxAggregateInputType
  }

  export type GetFileRelationAggregateType<T extends FileRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateFileRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileRelation[P]>
      : GetScalarType<T[P], AggregateFileRelation[P]>
  }




  export type FileRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileRelationWhereInput
    orderBy?: FileRelationOrderByWithAggregationInput | FileRelationOrderByWithAggregationInput[]
    by: FileRelationScalarFieldEnum[] | FileRelationScalarFieldEnum
    having?: FileRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileRelationCountAggregateInputType | true
    _min?: FileRelationMinAggregateInputType
    _max?: FileRelationMaxAggregateInputType
  }

  export type FileRelationGroupByOutputType = {
    id: string
    fromFileId: string
    toFileId: string
    type: $Enums.RelationType
    createdAt: Date
    _count: FileRelationCountAggregateOutputType | null
    _min: FileRelationMinAggregateOutputType | null
    _max: FileRelationMaxAggregateOutputType | null
  }

  type GetFileRelationGroupByPayload<T extends FileRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileRelationGroupByOutputType[P]>
            : GetScalarType<T[P], FileRelationGroupByOutputType[P]>
        }
      >
    >


  export type FileRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromFileId?: boolean
    toFileId?: boolean
    type?: boolean
    createdAt?: boolean
    fromFile?: boolean | FileDefaultArgs<ExtArgs>
    toFile?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileRelation"]>

  export type FileRelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromFileId?: boolean
    toFileId?: boolean
    type?: boolean
    createdAt?: boolean
    fromFile?: boolean | FileDefaultArgs<ExtArgs>
    toFile?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileRelation"]>

  export type FileRelationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromFileId?: boolean
    toFileId?: boolean
    type?: boolean
    createdAt?: boolean
    fromFile?: boolean | FileDefaultArgs<ExtArgs>
    toFile?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileRelation"]>

  export type FileRelationSelectScalar = {
    id?: boolean
    fromFileId?: boolean
    toFileId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type FileRelationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromFileId" | "toFileId" | "type" | "createdAt", ExtArgs["result"]["fileRelation"]>
  export type FileRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromFile?: boolean | FileDefaultArgs<ExtArgs>
    toFile?: boolean | FileDefaultArgs<ExtArgs>
  }
  export type FileRelationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromFile?: boolean | FileDefaultArgs<ExtArgs>
    toFile?: boolean | FileDefaultArgs<ExtArgs>
  }
  export type FileRelationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromFile?: boolean | FileDefaultArgs<ExtArgs>
    toFile?: boolean | FileDefaultArgs<ExtArgs>
  }

  export type $FileRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileRelation"
    objects: {
      fromFile: Prisma.$FilePayload<ExtArgs>
      toFile: Prisma.$FilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromFileId: string
      toFileId: string
      type: $Enums.RelationType
      createdAt: Date
    }, ExtArgs["result"]["fileRelation"]>
    composites: {}
  }

  type FileRelationGetPayload<S extends boolean | null | undefined | FileRelationDefaultArgs> = $Result.GetResult<Prisma.$FileRelationPayload, S>

  type FileRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileRelationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileRelationCountAggregateInputType | true
    }

  export interface FileRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileRelation'], meta: { name: 'FileRelation' } }
    /**
     * Find zero or one FileRelation that matches the filter.
     * @param {FileRelationFindUniqueArgs} args - Arguments to find a FileRelation
     * @example
     * // Get one FileRelation
     * const fileRelation = await prisma.fileRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileRelationFindUniqueArgs>(args: SelectSubset<T, FileRelationFindUniqueArgs<ExtArgs>>): Prisma__FileRelationClient<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileRelation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileRelationFindUniqueOrThrowArgs} args - Arguments to find a FileRelation
     * @example
     * // Get one FileRelation
     * const fileRelation = await prisma.fileRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileRelationFindUniqueOrThrowArgs>(args: SelectSubset<T, FileRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileRelationClient<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileRelationFindFirstArgs} args - Arguments to find a FileRelation
     * @example
     * // Get one FileRelation
     * const fileRelation = await prisma.fileRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileRelationFindFirstArgs>(args?: SelectSubset<T, FileRelationFindFirstArgs<ExtArgs>>): Prisma__FileRelationClient<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileRelationFindFirstOrThrowArgs} args - Arguments to find a FileRelation
     * @example
     * // Get one FileRelation
     * const fileRelation = await prisma.fileRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileRelationFindFirstOrThrowArgs>(args?: SelectSubset<T, FileRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileRelationClient<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileRelations
     * const fileRelations = await prisma.fileRelation.findMany()
     * 
     * // Get first 10 FileRelations
     * const fileRelations = await prisma.fileRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileRelationWithIdOnly = await prisma.fileRelation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileRelationFindManyArgs>(args?: SelectSubset<T, FileRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileRelation.
     * @param {FileRelationCreateArgs} args - Arguments to create a FileRelation.
     * @example
     * // Create one FileRelation
     * const FileRelation = await prisma.fileRelation.create({
     *   data: {
     *     // ... data to create a FileRelation
     *   }
     * })
     * 
     */
    create<T extends FileRelationCreateArgs>(args: SelectSubset<T, FileRelationCreateArgs<ExtArgs>>): Prisma__FileRelationClient<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileRelations.
     * @param {FileRelationCreateManyArgs} args - Arguments to create many FileRelations.
     * @example
     * // Create many FileRelations
     * const fileRelation = await prisma.fileRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileRelationCreateManyArgs>(args?: SelectSubset<T, FileRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileRelations and returns the data saved in the database.
     * @param {FileRelationCreateManyAndReturnArgs} args - Arguments to create many FileRelations.
     * @example
     * // Create many FileRelations
     * const fileRelation = await prisma.fileRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileRelations and only return the `id`
     * const fileRelationWithIdOnly = await prisma.fileRelation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileRelationCreateManyAndReturnArgs>(args?: SelectSubset<T, FileRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileRelation.
     * @param {FileRelationDeleteArgs} args - Arguments to delete one FileRelation.
     * @example
     * // Delete one FileRelation
     * const FileRelation = await prisma.fileRelation.delete({
     *   where: {
     *     // ... filter to delete one FileRelation
     *   }
     * })
     * 
     */
    delete<T extends FileRelationDeleteArgs>(args: SelectSubset<T, FileRelationDeleteArgs<ExtArgs>>): Prisma__FileRelationClient<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileRelation.
     * @param {FileRelationUpdateArgs} args - Arguments to update one FileRelation.
     * @example
     * // Update one FileRelation
     * const fileRelation = await prisma.fileRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileRelationUpdateArgs>(args: SelectSubset<T, FileRelationUpdateArgs<ExtArgs>>): Prisma__FileRelationClient<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileRelations.
     * @param {FileRelationDeleteManyArgs} args - Arguments to filter FileRelations to delete.
     * @example
     * // Delete a few FileRelations
     * const { count } = await prisma.fileRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileRelationDeleteManyArgs>(args?: SelectSubset<T, FileRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileRelations
     * const fileRelation = await prisma.fileRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileRelationUpdateManyArgs>(args: SelectSubset<T, FileRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileRelations and returns the data updated in the database.
     * @param {FileRelationUpdateManyAndReturnArgs} args - Arguments to update many FileRelations.
     * @example
     * // Update many FileRelations
     * const fileRelation = await prisma.fileRelation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileRelations and only return the `id`
     * const fileRelationWithIdOnly = await prisma.fileRelation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileRelationUpdateManyAndReturnArgs>(args: SelectSubset<T, FileRelationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileRelation.
     * @param {FileRelationUpsertArgs} args - Arguments to update or create a FileRelation.
     * @example
     * // Update or create a FileRelation
     * const fileRelation = await prisma.fileRelation.upsert({
     *   create: {
     *     // ... data to create a FileRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileRelation we want to update
     *   }
     * })
     */
    upsert<T extends FileRelationUpsertArgs>(args: SelectSubset<T, FileRelationUpsertArgs<ExtArgs>>): Prisma__FileRelationClient<$Result.GetResult<Prisma.$FileRelationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileRelationCountArgs} args - Arguments to filter FileRelations to count.
     * @example
     * // Count the number of FileRelations
     * const count = await prisma.fileRelation.count({
     *   where: {
     *     // ... the filter for the FileRelations we want to count
     *   }
     * })
    **/
    count<T extends FileRelationCountArgs>(
      args?: Subset<T, FileRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileRelationAggregateArgs>(args: Subset<T, FileRelationAggregateArgs>): Prisma.PrismaPromise<GetFileRelationAggregateType<T>>

    /**
     * Group by FileRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileRelationGroupByArgs['orderBy'] }
        : { orderBy?: FileRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileRelation model
   */
  readonly fields: FileRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromFile<T extends FileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FileDefaultArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toFile<T extends FileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FileDefaultArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileRelation model
   */
  interface FileRelationFieldRefs {
    readonly id: FieldRef<"FileRelation", 'String'>
    readonly fromFileId: FieldRef<"FileRelation", 'String'>
    readonly toFileId: FieldRef<"FileRelation", 'String'>
    readonly type: FieldRef<"FileRelation", 'RelationType'>
    readonly createdAt: FieldRef<"FileRelation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileRelation findUnique
   */
  export type FileRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
    /**
     * Filter, which FileRelation to fetch.
     */
    where: FileRelationWhereUniqueInput
  }

  /**
   * FileRelation findUniqueOrThrow
   */
  export type FileRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
    /**
     * Filter, which FileRelation to fetch.
     */
    where: FileRelationWhereUniqueInput
  }

  /**
   * FileRelation findFirst
   */
  export type FileRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
    /**
     * Filter, which FileRelation to fetch.
     */
    where?: FileRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileRelations to fetch.
     */
    orderBy?: FileRelationOrderByWithRelationInput | FileRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileRelations.
     */
    cursor?: FileRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileRelations.
     */
    distinct?: FileRelationScalarFieldEnum | FileRelationScalarFieldEnum[]
  }

  /**
   * FileRelation findFirstOrThrow
   */
  export type FileRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
    /**
     * Filter, which FileRelation to fetch.
     */
    where?: FileRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileRelations to fetch.
     */
    orderBy?: FileRelationOrderByWithRelationInput | FileRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileRelations.
     */
    cursor?: FileRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileRelations.
     */
    distinct?: FileRelationScalarFieldEnum | FileRelationScalarFieldEnum[]
  }

  /**
   * FileRelation findMany
   */
  export type FileRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
    /**
     * Filter, which FileRelations to fetch.
     */
    where?: FileRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileRelations to fetch.
     */
    orderBy?: FileRelationOrderByWithRelationInput | FileRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileRelations.
     */
    cursor?: FileRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileRelations.
     */
    skip?: number
    distinct?: FileRelationScalarFieldEnum | FileRelationScalarFieldEnum[]
  }

  /**
   * FileRelation create
   */
  export type FileRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a FileRelation.
     */
    data: XOR<FileRelationCreateInput, FileRelationUncheckedCreateInput>
  }

  /**
   * FileRelation createMany
   */
  export type FileRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileRelations.
     */
    data: FileRelationCreateManyInput | FileRelationCreateManyInput[]
  }

  /**
   * FileRelation createManyAndReturn
   */
  export type FileRelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * The data used to create many FileRelations.
     */
    data: FileRelationCreateManyInput | FileRelationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileRelation update
   */
  export type FileRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a FileRelation.
     */
    data: XOR<FileRelationUpdateInput, FileRelationUncheckedUpdateInput>
    /**
     * Choose, which FileRelation to update.
     */
    where: FileRelationWhereUniqueInput
  }

  /**
   * FileRelation updateMany
   */
  export type FileRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileRelations.
     */
    data: XOR<FileRelationUpdateManyMutationInput, FileRelationUncheckedUpdateManyInput>
    /**
     * Filter which FileRelations to update
     */
    where?: FileRelationWhereInput
    /**
     * Limit how many FileRelations to update.
     */
    limit?: number
  }

  /**
   * FileRelation updateManyAndReturn
   */
  export type FileRelationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * The data used to update FileRelations.
     */
    data: XOR<FileRelationUpdateManyMutationInput, FileRelationUncheckedUpdateManyInput>
    /**
     * Filter which FileRelations to update
     */
    where?: FileRelationWhereInput
    /**
     * Limit how many FileRelations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileRelation upsert
   */
  export type FileRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the FileRelation to update in case it exists.
     */
    where: FileRelationWhereUniqueInput
    /**
     * In case the FileRelation found by the `where` argument doesn't exist, create a new FileRelation with this data.
     */
    create: XOR<FileRelationCreateInput, FileRelationUncheckedCreateInput>
    /**
     * In case the FileRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileRelationUpdateInput, FileRelationUncheckedUpdateInput>
  }

  /**
   * FileRelation delete
   */
  export type FileRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
    /**
     * Filter which FileRelation to delete.
     */
    where: FileRelationWhereUniqueInput
  }

  /**
   * FileRelation deleteMany
   */
  export type FileRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileRelations to delete
     */
    where?: FileRelationWhereInput
    /**
     * Limit how many FileRelations to delete.
     */
    limit?: number
  }

  /**
   * FileRelation without action
   */
  export type FileRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileRelation
     */
    select?: FileRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileRelation
     */
    omit?: FileRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileRelationInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    projectId: string | null
    themaId: string | null
    epicId: string | null
    userStoryId: string | null
    taskId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    projectId: string | null
    themaId: string | null
    epicId: string | null
    userStoryId: string | null
    taskId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    authorId: number
    projectId: number
    themaId: number
    epicId: number
    userStoryId: number
    taskId: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    projectId?: true
    themaId?: true
    epicId?: true
    userStoryId?: true
    taskId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    projectId?: true
    themaId?: true
    epicId?: true
    userStoryId?: true
    taskId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    projectId?: true
    themaId?: true
    epicId?: true
    userStoryId?: true
    taskId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    authorId: string
    projectId: string | null
    themaId: string | null
    epicId: string | null
    userStoryId: string | null
    taskId: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    projectId?: boolean
    themaId?: boolean
    epicId?: boolean
    userStoryId?: boolean
    taskId?: boolean
    author?: boolean | MemberDefaultArgs<ExtArgs>
    project?: boolean | Comment$projectArgs<ExtArgs>
    thema?: boolean | Comment$themaArgs<ExtArgs>
    epic?: boolean | Comment$epicArgs<ExtArgs>
    userStory?: boolean | Comment$userStoryArgs<ExtArgs>
    task?: boolean | Comment$taskArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    projectId?: boolean
    themaId?: boolean
    epicId?: boolean
    userStoryId?: boolean
    taskId?: boolean
    author?: boolean | MemberDefaultArgs<ExtArgs>
    project?: boolean | Comment$projectArgs<ExtArgs>
    thema?: boolean | Comment$themaArgs<ExtArgs>
    epic?: boolean | Comment$epicArgs<ExtArgs>
    userStory?: boolean | Comment$userStoryArgs<ExtArgs>
    task?: boolean | Comment$taskArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    projectId?: boolean
    themaId?: boolean
    epicId?: boolean
    userStoryId?: boolean
    taskId?: boolean
    author?: boolean | MemberDefaultArgs<ExtArgs>
    project?: boolean | Comment$projectArgs<ExtArgs>
    thema?: boolean | Comment$themaArgs<ExtArgs>
    epic?: boolean | Comment$epicArgs<ExtArgs>
    userStory?: boolean | Comment$userStoryArgs<ExtArgs>
    task?: boolean | Comment$taskArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    projectId?: boolean
    themaId?: boolean
    epicId?: boolean
    userStoryId?: boolean
    taskId?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt" | "authorId" | "projectId" | "themaId" | "epicId" | "userStoryId" | "taskId", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | MemberDefaultArgs<ExtArgs>
    project?: boolean | Comment$projectArgs<ExtArgs>
    thema?: boolean | Comment$themaArgs<ExtArgs>
    epic?: boolean | Comment$epicArgs<ExtArgs>
    userStory?: boolean | Comment$userStoryArgs<ExtArgs>
    task?: boolean | Comment$taskArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | MemberDefaultArgs<ExtArgs>
    project?: boolean | Comment$projectArgs<ExtArgs>
    thema?: boolean | Comment$themaArgs<ExtArgs>
    epic?: boolean | Comment$epicArgs<ExtArgs>
    userStory?: boolean | Comment$userStoryArgs<ExtArgs>
    task?: boolean | Comment$taskArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | MemberDefaultArgs<ExtArgs>
    project?: boolean | Comment$projectArgs<ExtArgs>
    thema?: boolean | Comment$themaArgs<ExtArgs>
    epic?: boolean | Comment$epicArgs<ExtArgs>
    userStory?: boolean | Comment$userStoryArgs<ExtArgs>
    task?: boolean | Comment$taskArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      author: Prisma.$MemberPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      thema: Prisma.$ThemaPayload<ExtArgs> | null
      epic: Prisma.$EpicPayload<ExtArgs> | null
      userStory: Prisma.$UserStoryPayload<ExtArgs> | null
      task: Prisma.$TaskPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
      authorId: string
      projectId: string | null
      themaId: string | null
      epicId: string | null
      userStoryId: string | null
      taskId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends Comment$projectArgs<ExtArgs> = {}>(args?: Subset<T, Comment$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    thema<T extends Comment$themaArgs<ExtArgs> = {}>(args?: Subset<T, Comment$themaArgs<ExtArgs>>): Prisma__ThemaClient<$Result.GetResult<Prisma.$ThemaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    epic<T extends Comment$epicArgs<ExtArgs> = {}>(args?: Subset<T, Comment$epicArgs<ExtArgs>>): Prisma__EpicClient<$Result.GetResult<Prisma.$EpicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userStory<T extends Comment$userStoryArgs<ExtArgs> = {}>(args?: Subset<T, Comment$userStoryArgs<ExtArgs>>): Prisma__UserStoryClient<$Result.GetResult<Prisma.$UserStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    task<T extends Comment$taskArgs<ExtArgs> = {}>(args?: Subset<T, Comment$taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly projectId: FieldRef<"Comment", 'String'>
    readonly themaId: FieldRef<"Comment", 'String'>
    readonly epicId: FieldRef<"Comment", 'String'>
    readonly userStoryId: FieldRef<"Comment", 'String'>
    readonly taskId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.project
   */
  export type Comment$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Comment.thema
   */
  export type Comment$themaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thema
     */
    select?: ThemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Thema
     */
    omit?: ThemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemaInclude<ExtArgs> | null
    where?: ThemaWhereInput
  }

  /**
   * Comment.epic
   */
  export type Comment$epicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Epic
     */
    select?: EpicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Epic
     */
    omit?: EpicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpicInclude<ExtArgs> | null
    where?: EpicWhereInput
  }

  /**
   * Comment.userStory
   */
  export type Comment$userStoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStory
     */
    select?: UserStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStory
     */
    omit?: UserStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoryInclude<ExtArgs> | null
    where?: UserStoryWhereInput
  }

  /**
   * Comment.task
   */
  export type Comment$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model TimeLog
   */

  export type AggregateTimeLog = {
    _count: TimeLogCountAggregateOutputType | null
    _min: TimeLogMinAggregateOutputType | null
    _max: TimeLogMaxAggregateOutputType | null
  }

  export type TimeLogMinAggregateOutputType = {
    id: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    taskId: string | null
    memberId: string | null
  }

  export type TimeLogMaxAggregateOutputType = {
    id: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    taskId: string | null
    memberId: string | null
  }

  export type TimeLogCountAggregateOutputType = {
    id: number
    description: number
    startTime: number
    endTime: number
    createdAt: number
    taskId: number
    memberId: number
    _all: number
  }


  export type TimeLogMinAggregateInputType = {
    id?: true
    description?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    taskId?: true
    memberId?: true
  }

  export type TimeLogMaxAggregateInputType = {
    id?: true
    description?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    taskId?: true
    memberId?: true
  }

  export type TimeLogCountAggregateInputType = {
    id?: true
    description?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    taskId?: true
    memberId?: true
    _all?: true
  }

  export type TimeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeLog to aggregate.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeLogs
    **/
    _count?: true | TimeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeLogMaxAggregateInputType
  }

  export type GetTimeLogAggregateType<T extends TimeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeLog[P]>
      : GetScalarType<T[P], AggregateTimeLog[P]>
  }




  export type TimeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithAggregationInput | TimeLogOrderByWithAggregationInput[]
    by: TimeLogScalarFieldEnum[] | TimeLogScalarFieldEnum
    having?: TimeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeLogCountAggregateInputType | true
    _min?: TimeLogMinAggregateInputType
    _max?: TimeLogMaxAggregateInputType
  }

  export type TimeLogGroupByOutputType = {
    id: string
    description: string | null
    startTime: Date
    endTime: Date | null
    createdAt: Date
    taskId: string
    memberId: string
    _count: TimeLogCountAggregateOutputType | null
    _min: TimeLogMinAggregateOutputType | null
    _max: TimeLogMaxAggregateOutputType | null
  }

  type GetTimeLogGroupByPayload<T extends TimeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeLogGroupByOutputType[P]>
            : GetScalarType<T[P], TimeLogGroupByOutputType[P]>
        }
      >
    >


  export type TimeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    taskId?: boolean
    memberId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeLog"]>

  export type TimeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    taskId?: boolean
    memberId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeLog"]>

  export type TimeLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    taskId?: boolean
    memberId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeLog"]>

  export type TimeLogSelectScalar = {
    id?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    taskId?: boolean
    memberId?: boolean
  }

  export type TimeLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "startTime" | "endTime" | "createdAt" | "taskId" | "memberId", ExtArgs["result"]["timeLog"]>
  export type TimeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type TimeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type TimeLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $TimeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeLog"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string | null
      startTime: Date
      endTime: Date | null
      createdAt: Date
      taskId: string
      memberId: string
    }, ExtArgs["result"]["timeLog"]>
    composites: {}
  }

  type TimeLogGetPayload<S extends boolean | null | undefined | TimeLogDefaultArgs> = $Result.GetResult<Prisma.$TimeLogPayload, S>

  type TimeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeLogCountAggregateInputType | true
    }

  export interface TimeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeLog'], meta: { name: 'TimeLog' } }
    /**
     * Find zero or one TimeLog that matches the filter.
     * @param {TimeLogFindUniqueArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeLogFindUniqueArgs>(args: SelectSubset<T, TimeLogFindUniqueArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeLogFindUniqueOrThrowArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindFirstArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeLogFindFirstArgs>(args?: SelectSubset<T, TimeLogFindFirstArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindFirstOrThrowArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeLogs
     * const timeLogs = await prisma.timeLog.findMany()
     * 
     * // Get first 10 TimeLogs
     * const timeLogs = await prisma.timeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeLogWithIdOnly = await prisma.timeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeLogFindManyArgs>(args?: SelectSubset<T, TimeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeLog.
     * @param {TimeLogCreateArgs} args - Arguments to create a TimeLog.
     * @example
     * // Create one TimeLog
     * const TimeLog = await prisma.timeLog.create({
     *   data: {
     *     // ... data to create a TimeLog
     *   }
     * })
     * 
     */
    create<T extends TimeLogCreateArgs>(args: SelectSubset<T, TimeLogCreateArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeLogs.
     * @param {TimeLogCreateManyArgs} args - Arguments to create many TimeLogs.
     * @example
     * // Create many TimeLogs
     * const timeLog = await prisma.timeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeLogCreateManyArgs>(args?: SelectSubset<T, TimeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeLogs and returns the data saved in the database.
     * @param {TimeLogCreateManyAndReturnArgs} args - Arguments to create many TimeLogs.
     * @example
     * // Create many TimeLogs
     * const timeLog = await prisma.timeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeLogs and only return the `id`
     * const timeLogWithIdOnly = await prisma.timeLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeLog.
     * @param {TimeLogDeleteArgs} args - Arguments to delete one TimeLog.
     * @example
     * // Delete one TimeLog
     * const TimeLog = await prisma.timeLog.delete({
     *   where: {
     *     // ... filter to delete one TimeLog
     *   }
     * })
     * 
     */
    delete<T extends TimeLogDeleteArgs>(args: SelectSubset<T, TimeLogDeleteArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeLog.
     * @param {TimeLogUpdateArgs} args - Arguments to update one TimeLog.
     * @example
     * // Update one TimeLog
     * const timeLog = await prisma.timeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeLogUpdateArgs>(args: SelectSubset<T, TimeLogUpdateArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeLogs.
     * @param {TimeLogDeleteManyArgs} args - Arguments to filter TimeLogs to delete.
     * @example
     * // Delete a few TimeLogs
     * const { count } = await prisma.timeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeLogDeleteManyArgs>(args?: SelectSubset<T, TimeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeLogs
     * const timeLog = await prisma.timeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeLogUpdateManyArgs>(args: SelectSubset<T, TimeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeLogs and returns the data updated in the database.
     * @param {TimeLogUpdateManyAndReturnArgs} args - Arguments to update many TimeLogs.
     * @example
     * // Update many TimeLogs
     * const timeLog = await prisma.timeLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeLogs and only return the `id`
     * const timeLogWithIdOnly = await prisma.timeLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeLogUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeLog.
     * @param {TimeLogUpsertArgs} args - Arguments to update or create a TimeLog.
     * @example
     * // Update or create a TimeLog
     * const timeLog = await prisma.timeLog.upsert({
     *   create: {
     *     // ... data to create a TimeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeLog we want to update
     *   }
     * })
     */
    upsert<T extends TimeLogUpsertArgs>(args: SelectSubset<T, TimeLogUpsertArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogCountArgs} args - Arguments to filter TimeLogs to count.
     * @example
     * // Count the number of TimeLogs
     * const count = await prisma.timeLog.count({
     *   where: {
     *     // ... the filter for the TimeLogs we want to count
     *   }
     * })
    **/
    count<T extends TimeLogCountArgs>(
      args?: Subset<T, TimeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeLogAggregateArgs>(args: Subset<T, TimeLogAggregateArgs>): Prisma.PrismaPromise<GetTimeLogAggregateType<T>>

    /**
     * Group by TimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeLogGroupByArgs['orderBy'] }
        : { orderBy?: TimeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeLog model
   */
  readonly fields: TimeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeLog model
   */
  interface TimeLogFieldRefs {
    readonly id: FieldRef<"TimeLog", 'String'>
    readonly description: FieldRef<"TimeLog", 'String'>
    readonly startTime: FieldRef<"TimeLog", 'DateTime'>
    readonly endTime: FieldRef<"TimeLog", 'DateTime'>
    readonly createdAt: FieldRef<"TimeLog", 'DateTime'>
    readonly taskId: FieldRef<"TimeLog", 'String'>
    readonly memberId: FieldRef<"TimeLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimeLog findUnique
   */
  export type TimeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog findUniqueOrThrow
   */
  export type TimeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog findFirst
   */
  export type TimeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeLogs.
     */
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog findFirstOrThrow
   */
  export type TimeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeLogs.
     */
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog findMany
   */
  export type TimeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLogs to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog create
   */
  export type TimeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeLog.
     */
    data: XOR<TimeLogCreateInput, TimeLogUncheckedCreateInput>
  }

  /**
   * TimeLog createMany
   */
  export type TimeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeLogs.
     */
    data: TimeLogCreateManyInput | TimeLogCreateManyInput[]
  }

  /**
   * TimeLog createManyAndReturn
   */
  export type TimeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * The data used to create many TimeLogs.
     */
    data: TimeLogCreateManyInput | TimeLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeLog update
   */
  export type TimeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeLog.
     */
    data: XOR<TimeLogUpdateInput, TimeLogUncheckedUpdateInput>
    /**
     * Choose, which TimeLog to update.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog updateMany
   */
  export type TimeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeLogs.
     */
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyInput>
    /**
     * Filter which TimeLogs to update
     */
    where?: TimeLogWhereInput
    /**
     * Limit how many TimeLogs to update.
     */
    limit?: number
  }

  /**
   * TimeLog updateManyAndReturn
   */
  export type TimeLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * The data used to update TimeLogs.
     */
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyInput>
    /**
     * Filter which TimeLogs to update
     */
    where?: TimeLogWhereInput
    /**
     * Limit how many TimeLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeLog upsert
   */
  export type TimeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeLog to update in case it exists.
     */
    where: TimeLogWhereUniqueInput
    /**
     * In case the TimeLog found by the `where` argument doesn't exist, create a new TimeLog with this data.
     */
    create: XOR<TimeLogCreateInput, TimeLogUncheckedCreateInput>
    /**
     * In case the TimeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeLogUpdateInput, TimeLogUncheckedUpdateInput>
  }

  /**
   * TimeLog delete
   */
  export type TimeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter which TimeLog to delete.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog deleteMany
   */
  export type TimeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeLogs to delete
     */
    where?: TimeLogWhereInput
    /**
     * Limit how many TimeLogs to delete.
     */
    limit?: number
  }

  /**
   * TimeLog without action
   */
  export type TimeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    action: $Enums.ActionType | null
    entityId: string | null
    timestamp: Date | null
    memberId: string | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    action: $Enums.ActionType | null
    entityId: string | null
    timestamp: Date | null
    memberId: string | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    action: number
    entityId: number
    timestamp: number
    memberId: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    action?: true
    entityId?: true
    timestamp?: true
    memberId?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    action?: true
    entityId?: true
    timestamp?: true
    memberId?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    action?: true
    entityId?: true
    timestamp?: true
    memberId?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    action: $Enums.ActionType
    entityId: string
    timestamp: Date
    memberId: string
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityId?: boolean
    timestamp?: boolean
    memberId?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityId?: boolean
    timestamp?: boolean
    memberId?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityId?: boolean
    timestamp?: boolean
    memberId?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    action?: boolean
    entityId?: boolean
    timestamp?: boolean
    memberId?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "entityId" | "timestamp" | "memberId", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: $Enums.ActionType
      entityId: string
      timestamp: Date
      memberId: string
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'ActionType'>
    readonly entityId: FieldRef<"ActivityLog", 'String'>
    readonly timestamp: FieldRef<"ActivityLog", 'DateTime'>
    readonly memberId: FieldRef<"ActivityLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    role: 'role',
    lang: 'lang',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    idToken: 'idToken',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const UserAggregateScalarFieldEnum: {
    id: 'id',
    userName: 'userName',
    userEmail: 'userEmail',
    userImage: 'userImage',
    userRole: 'userRole',
    userLang: 'userLang',
    userCreatedAt: 'userCreatedAt',
    userUpdatedAt: 'userUpdatedAt',
    sessions: 'sessions',
    accounts: 'accounts',
    memberProjects: 'memberProjects',
    projects: 'projects',
    files: 'files',
    tasks: 'tasks',
    subtasks: 'subtasks',
    comments: 'comments',
    timeLogs: 'timeLogs',
    epics: 'epics',
    userStories: 'userStories',
    sprints: 'sprints',
    themas: 'themas',
    activities: 'activities',
    fileDependencies: 'fileDependencies',
    fileRelations: 'fileRelations'
  };

  export type UserAggregateScalarFieldEnum = (typeof UserAggregateScalarFieldEnum)[keyof typeof UserAggregateScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    status: 'status',
    priority: 'priority',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    role: 'role',
    joinedAt: 'joinedAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    projectId: 'projectId'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const ThemaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    priority: 'priority',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    creatorId: 'creatorId'
  };

  export type ThemaScalarFieldEnum = (typeof ThemaScalarFieldEnum)[keyof typeof ThemaScalarFieldEnum]


  export const EpicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    priority: 'priority',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    creatorId: 'creatorId'
  };

  export type EpicScalarFieldEnum = (typeof EpicScalarFieldEnum)[keyof typeof EpicScalarFieldEnum]


  export const UserStoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    epicId: 'epicId',
    creatorId: 'creatorId',
    sprintId: 'sprintId'
  };

  export type UserStoryScalarFieldEnum = (typeof UserStoryScalarFieldEnum)[keyof typeof UserStoryScalarFieldEnum]


  export const SprintScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    creatorId: 'creatorId'
  };

  export type SprintScalarFieldEnum = (typeof SprintScalarFieldEnum)[keyof typeof SprintScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    estimatedDuration: 'estimatedDuration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    themaId: 'themaId',
    userStoryId: 'userStoryId',
    sprintId: 'sprintId',
    assigneeId: 'assigneeId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const SubtaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    taskId: 'taskId',
    sprintId: 'sprintId',
    assigneeId: 'assigneeId'
  };

  export type SubtaskScalarFieldEnum = (typeof SubtaskScalarFieldEnum)[keyof typeof SubtaskScalarFieldEnum]


  export const FolderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    path: 'path',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentId: 'parentId',
    projectId: 'projectId'
  };

  export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    size: 'size',
    url: 'url',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    folderId: 'folderId',
    projectId: 'projectId',
    subtaskId: 'subtaskId',
    sprintId: 'sprintId',
    uploaderId: 'uploaderId'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const DependencyScalarFieldEnum: {
    id: 'id',
    fileId: 'fileId',
    componentName: 'componentName',
    version: 'version',
    createdAt: 'createdAt'
  };

  export type DependencyScalarFieldEnum = (typeof DependencyScalarFieldEnum)[keyof typeof DependencyScalarFieldEnum]


  export const FileRelationScalarFieldEnum: {
    id: 'id',
    fromFileId: 'fromFileId',
    toFileId: 'toFileId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type FileRelationScalarFieldEnum = (typeof FileRelationScalarFieldEnum)[keyof typeof FileRelationScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId',
    projectId: 'projectId',
    themaId: 'themaId',
    epicId: 'epicId',
    userStoryId: 'userStoryId',
    taskId: 'taskId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const TimeLogScalarFieldEnum: {
    id: 'id',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    taskId: 'taskId',
    memberId: 'memberId'
  };

  export type TimeLogScalarFieldEnum = (typeof TimeLogScalarFieldEnum)[keyof typeof TimeLogScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityId: 'entityId',
    timestamp: 'timestamp',
    memberId: 'memberId'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'RelationType'
   */
  export type EnumRelationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationType'>
    


  /**
   * Reference to a field of type 'ActionType'
   */
  export type EnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    lang?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    memberships?: MemberListRelationFilter
    verifications?: VerificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    lang?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    memberships?: MemberOrderByRelationAggregateInput
    verifications?: VerificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    lang?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    memberships?: MemberListRelationFilter
    verifications?: VerificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    lang?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    lang?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
    userId?: StringFilter<"Verification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
    userId?: StringFilter<"Verification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    userId?: StringWithAggregatesFilter<"Verification"> | string
  }

  export type UserAggregateWhereInput = {
    AND?: UserAggregateWhereInput | UserAggregateWhereInput[]
    OR?: UserAggregateWhereInput[]
    NOT?: UserAggregateWhereInput | UserAggregateWhereInput[]
    id?: StringFilter<"UserAggregate"> | string
    userName?: StringNullableFilter<"UserAggregate"> | string | null
    userEmail?: StringNullableFilter<"UserAggregate"> | string | null
    userImage?: StringNullableFilter<"UserAggregate"> | string | null
    userRole?: EnumRoleFilter<"UserAggregate"> | $Enums.Role
    userLang?: StringNullableFilter<"UserAggregate"> | string | null
    userCreatedAt?: DateTimeFilter<"UserAggregate"> | Date | string
    userUpdatedAt?: DateTimeFilter<"UserAggregate"> | Date | string
    sessions?: JsonFilter<"UserAggregate">
    accounts?: JsonFilter<"UserAggregate">
    memberProjects?: JsonFilter<"UserAggregate">
    projects?: JsonFilter<"UserAggregate">
    files?: JsonFilter<"UserAggregate">
    tasks?: JsonFilter<"UserAggregate">
    subtasks?: JsonFilter<"UserAggregate">
    comments?: JsonFilter<"UserAggregate">
    timeLogs?: JsonFilter<"UserAggregate">
    epics?: JsonFilter<"UserAggregate">
    userStories?: JsonFilter<"UserAggregate">
    sprints?: JsonFilter<"UserAggregate">
    themas?: JsonFilter<"UserAggregate">
    activities?: JsonFilter<"UserAggregate">
    fileDependencies?: JsonFilter<"UserAggregate">
    fileRelations?: JsonFilter<"UserAggregate">
  }

  export type UserAggregateOrderByWithRelationInput = {
    id?: SortOrder
    userName?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    userImage?: SortOrderInput | SortOrder
    userRole?: SortOrder
    userLang?: SortOrderInput | SortOrder
    userCreatedAt?: SortOrder
    userUpdatedAt?: SortOrder
    sessions?: SortOrder
    accounts?: SortOrder
    memberProjects?: SortOrder
    projects?: SortOrder
    files?: SortOrder
    tasks?: SortOrder
    subtasks?: SortOrder
    comments?: SortOrder
    timeLogs?: SortOrder
    epics?: SortOrder
    userStories?: SortOrder
    sprints?: SortOrder
    themas?: SortOrder
    activities?: SortOrder
    fileDependencies?: SortOrder
    fileRelations?: SortOrder
  }

  export type UserAggregateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userEmail?: string
    AND?: UserAggregateWhereInput | UserAggregateWhereInput[]
    OR?: UserAggregateWhereInput[]
    NOT?: UserAggregateWhereInput | UserAggregateWhereInput[]
    userName?: StringNullableFilter<"UserAggregate"> | string | null
    userImage?: StringNullableFilter<"UserAggregate"> | string | null
    userRole?: EnumRoleFilter<"UserAggregate"> | $Enums.Role
    userLang?: StringNullableFilter<"UserAggregate"> | string | null
    userCreatedAt?: DateTimeFilter<"UserAggregate"> | Date | string
    userUpdatedAt?: DateTimeFilter<"UserAggregate"> | Date | string
    sessions?: JsonFilter<"UserAggregate">
    accounts?: JsonFilter<"UserAggregate">
    memberProjects?: JsonFilter<"UserAggregate">
    projects?: JsonFilter<"UserAggregate">
    files?: JsonFilter<"UserAggregate">
    tasks?: JsonFilter<"UserAggregate">
    subtasks?: JsonFilter<"UserAggregate">
    comments?: JsonFilter<"UserAggregate">
    timeLogs?: JsonFilter<"UserAggregate">
    epics?: JsonFilter<"UserAggregate">
    userStories?: JsonFilter<"UserAggregate">
    sprints?: JsonFilter<"UserAggregate">
    themas?: JsonFilter<"UserAggregate">
    activities?: JsonFilter<"UserAggregate">
    fileDependencies?: JsonFilter<"UserAggregate">
    fileRelations?: JsonFilter<"UserAggregate">
  }, "id" | "userEmail">

  export type UserAggregateOrderByWithAggregationInput = {
    id?: SortOrder
    userName?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    userImage?: SortOrderInput | SortOrder
    userRole?: SortOrder
    userLang?: SortOrderInput | SortOrder
    userCreatedAt?: SortOrder
    userUpdatedAt?: SortOrder
    sessions?: SortOrder
    accounts?: SortOrder
    memberProjects?: SortOrder
    projects?: SortOrder
    files?: SortOrder
    tasks?: SortOrder
    subtasks?: SortOrder
    comments?: SortOrder
    timeLogs?: SortOrder
    epics?: SortOrder
    userStories?: SortOrder
    sprints?: SortOrder
    themas?: SortOrder
    activities?: SortOrder
    fileDependencies?: SortOrder
    fileRelations?: SortOrder
    _count?: UserAggregateCountOrderByAggregateInput
    _max?: UserAggregateMaxOrderByAggregateInput
    _min?: UserAggregateMinOrderByAggregateInput
  }

  export type UserAggregateScalarWhereWithAggregatesInput = {
    AND?: UserAggregateScalarWhereWithAggregatesInput | UserAggregateScalarWhereWithAggregatesInput[]
    OR?: UserAggregateScalarWhereWithAggregatesInput[]
    NOT?: UserAggregateScalarWhereWithAggregatesInput | UserAggregateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAggregate"> | string
    userName?: StringNullableWithAggregatesFilter<"UserAggregate"> | string | null
    userEmail?: StringNullableWithAggregatesFilter<"UserAggregate"> | string | null
    userImage?: StringNullableWithAggregatesFilter<"UserAggregate"> | string | null
    userRole?: EnumRoleWithAggregatesFilter<"UserAggregate"> | $Enums.Role
    userLang?: StringNullableWithAggregatesFilter<"UserAggregate"> | string | null
    userCreatedAt?: DateTimeWithAggregatesFilter<"UserAggregate"> | Date | string
    userUpdatedAt?: DateTimeWithAggregatesFilter<"UserAggregate"> | Date | string
    sessions?: JsonWithAggregatesFilter<"UserAggregate">
    accounts?: JsonWithAggregatesFilter<"UserAggregate">
    memberProjects?: JsonWithAggregatesFilter<"UserAggregate">
    projects?: JsonWithAggregatesFilter<"UserAggregate">
    files?: JsonWithAggregatesFilter<"UserAggregate">
    tasks?: JsonWithAggregatesFilter<"UserAggregate">
    subtasks?: JsonWithAggregatesFilter<"UserAggregate">
    comments?: JsonWithAggregatesFilter<"UserAggregate">
    timeLogs?: JsonWithAggregatesFilter<"UserAggregate">
    epics?: JsonWithAggregatesFilter<"UserAggregate">
    userStories?: JsonWithAggregatesFilter<"UserAggregate">
    sprints?: JsonWithAggregatesFilter<"UserAggregate">
    themas?: JsonWithAggregatesFilter<"UserAggregate">
    activities?: JsonWithAggregatesFilter<"UserAggregate">
    fileDependencies?: JsonWithAggregatesFilter<"UserAggregate">
    fileRelations?: JsonWithAggregatesFilter<"UserAggregate">
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    image?: StringNullableFilter<"Project"> | string | null
    status?: EnumStatusFilter<"Project"> | $Enums.Status
    priority?: IntFilter<"Project"> | number
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    creatorId?: StringNullableFilter<"Project"> | string | null
    themas?: ThemaListRelationFilter
    epics?: EpicListRelationFilter
    userStories?: UserStoryListRelationFilter
    sprints?: SprintListRelationFilter
    members?: MemberListRelationFilter
    folders?: FolderListRelationFilter
    files?: FileListRelationFilter
    comments?: CommentListRelationFilter
    creator?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    themas?: ThemaOrderByRelationAggregateInput
    epics?: EpicOrderByRelationAggregateInput
    userStories?: UserStoryOrderByRelationAggregateInput
    sprints?: SprintOrderByRelationAggregateInput
    members?: MemberOrderByRelationAggregateInput
    folders?: FolderOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    creator?: MemberOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    image?: StringNullableFilter<"Project"> | string | null
    status?: EnumStatusFilter<"Project"> | $Enums.Status
    priority?: IntFilter<"Project"> | number
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    creatorId?: StringNullableFilter<"Project"> | string | null
    themas?: ThemaListRelationFilter
    epics?: EpicListRelationFilter
    userStories?: UserStoryListRelationFilter
    sprints?: SprintListRelationFilter
    members?: MemberListRelationFilter
    folders?: FolderListRelationFilter
    files?: FileListRelationFilter
    comments?: CommentListRelationFilter
    creator?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    image?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Project"> | $Enums.Status
    priority?: IntWithAggregatesFilter<"Project"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    creatorId?: StringNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: StringFilter<"Member"> | string
    role?: EnumRoleFilter<"Member"> | $Enums.Role
    joinedAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    userId?: StringFilter<"Member"> | string
    projectId?: StringFilter<"Member"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    files?: FileListRelationFilter
    tasks?: TaskListRelationFilter
    subtasks?: SubtaskListRelationFilter
    comments?: CommentListRelationFilter
    timeLogs?: TimeLogListRelationFilter
    userStories?: UserStoryListRelationFilter
    themas?: ThemaListRelationFilter
    epics?: EpicListRelationFilter
    sprints?: SprintListRelationFilter
    activities?: ActivityLogListRelationFilter
    createdProjects?: ProjectListRelationFilter
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    files?: FileOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    subtasks?: SubtaskOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    timeLogs?: TimeLogOrderByRelationAggregateInput
    userStories?: UserStoryOrderByRelationAggregateInput
    themas?: ThemaOrderByRelationAggregateInput
    epics?: EpicOrderByRelationAggregateInput
    sprints?: SprintOrderByRelationAggregateInput
    activities?: ActivityLogOrderByRelationAggregateInput
    createdProjects?: ProjectOrderByRelationAggregateInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_projectId?: MemberUserIdProjectIdCompoundUniqueInput
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    role?: EnumRoleFilter<"Member"> | $Enums.Role
    joinedAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    userId?: StringFilter<"Member"> | string
    projectId?: StringFilter<"Member"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    files?: FileListRelationFilter
    tasks?: TaskListRelationFilter
    subtasks?: SubtaskListRelationFilter
    comments?: CommentListRelationFilter
    timeLogs?: TimeLogListRelationFilter
    userStories?: UserStoryListRelationFilter
    themas?: ThemaListRelationFilter
    epics?: EpicListRelationFilter
    sprints?: SprintListRelationFilter
    activities?: ActivityLogListRelationFilter
    createdProjects?: ProjectListRelationFilter
  }, "id" | "userId_projectId">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Member"> | string
    role?: EnumRoleWithAggregatesFilter<"Member"> | $Enums.Role
    joinedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    userId?: StringWithAggregatesFilter<"Member"> | string
    projectId?: StringWithAggregatesFilter<"Member"> | string
  }

  export type ThemaWhereInput = {
    AND?: ThemaWhereInput | ThemaWhereInput[]
    OR?: ThemaWhereInput[]
    NOT?: ThemaWhereInput | ThemaWhereInput[]
    id?: StringFilter<"Thema"> | string
    name?: StringFilter<"Thema"> | string
    description?: StringNullableFilter<"Thema"> | string | null
    status?: EnumStatusFilter<"Thema"> | $Enums.Status
    priority?: IntFilter<"Thema"> | number
    startDate?: DateTimeNullableFilter<"Thema"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Thema"> | Date | string | null
    createdAt?: DateTimeFilter<"Thema"> | Date | string
    updatedAt?: DateTimeFilter<"Thema"> | Date | string
    projectId?: StringFilter<"Thema"> | string
    creatorId?: StringFilter<"Thema"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    tasks?: TaskListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type ThemaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: MemberOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type ThemaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ThemaWhereInput | ThemaWhereInput[]
    OR?: ThemaWhereInput[]
    NOT?: ThemaWhereInput | ThemaWhereInput[]
    name?: StringFilter<"Thema"> | string
    description?: StringNullableFilter<"Thema"> | string | null
    status?: EnumStatusFilter<"Thema"> | $Enums.Status
    priority?: IntFilter<"Thema"> | number
    startDate?: DateTimeNullableFilter<"Thema"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Thema"> | Date | string | null
    createdAt?: DateTimeFilter<"Thema"> | Date | string
    updatedAt?: DateTimeFilter<"Thema"> | Date | string
    projectId?: StringFilter<"Thema"> | string
    creatorId?: StringFilter<"Thema"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    tasks?: TaskListRelationFilter
    comments?: CommentListRelationFilter
  }, "id">

  export type ThemaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
    _count?: ThemaCountOrderByAggregateInput
    _avg?: ThemaAvgOrderByAggregateInput
    _max?: ThemaMaxOrderByAggregateInput
    _min?: ThemaMinOrderByAggregateInput
    _sum?: ThemaSumOrderByAggregateInput
  }

  export type ThemaScalarWhereWithAggregatesInput = {
    AND?: ThemaScalarWhereWithAggregatesInput | ThemaScalarWhereWithAggregatesInput[]
    OR?: ThemaScalarWhereWithAggregatesInput[]
    NOT?: ThemaScalarWhereWithAggregatesInput | ThemaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Thema"> | string
    name?: StringWithAggregatesFilter<"Thema"> | string
    description?: StringNullableWithAggregatesFilter<"Thema"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Thema"> | $Enums.Status
    priority?: IntWithAggregatesFilter<"Thema"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"Thema"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Thema"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Thema"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Thema"> | Date | string
    projectId?: StringWithAggregatesFilter<"Thema"> | string
    creatorId?: StringWithAggregatesFilter<"Thema"> | string
  }

  export type EpicWhereInput = {
    AND?: EpicWhereInput | EpicWhereInput[]
    OR?: EpicWhereInput[]
    NOT?: EpicWhereInput | EpicWhereInput[]
    id?: StringFilter<"Epic"> | string
    name?: StringFilter<"Epic"> | string
    description?: StringNullableFilter<"Epic"> | string | null
    status?: EnumStatusFilter<"Epic"> | $Enums.Status
    priority?: IntFilter<"Epic"> | number
    startDate?: DateTimeNullableFilter<"Epic"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Epic"> | Date | string | null
    createdAt?: DateTimeFilter<"Epic"> | Date | string
    updatedAt?: DateTimeFilter<"Epic"> | Date | string
    projectId?: StringFilter<"Epic"> | string
    creatorId?: StringFilter<"Epic"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    userStories?: UserStoryListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type EpicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: MemberOrderByWithRelationInput
    userStories?: UserStoryOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type EpicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EpicWhereInput | EpicWhereInput[]
    OR?: EpicWhereInput[]
    NOT?: EpicWhereInput | EpicWhereInput[]
    name?: StringFilter<"Epic"> | string
    description?: StringNullableFilter<"Epic"> | string | null
    status?: EnumStatusFilter<"Epic"> | $Enums.Status
    priority?: IntFilter<"Epic"> | number
    startDate?: DateTimeNullableFilter<"Epic"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Epic"> | Date | string | null
    createdAt?: DateTimeFilter<"Epic"> | Date | string
    updatedAt?: DateTimeFilter<"Epic"> | Date | string
    projectId?: StringFilter<"Epic"> | string
    creatorId?: StringFilter<"Epic"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    userStories?: UserStoryListRelationFilter
    comments?: CommentListRelationFilter
  }, "id">

  export type EpicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
    _count?: EpicCountOrderByAggregateInput
    _avg?: EpicAvgOrderByAggregateInput
    _max?: EpicMaxOrderByAggregateInput
    _min?: EpicMinOrderByAggregateInput
    _sum?: EpicSumOrderByAggregateInput
  }

  export type EpicScalarWhereWithAggregatesInput = {
    AND?: EpicScalarWhereWithAggregatesInput | EpicScalarWhereWithAggregatesInput[]
    OR?: EpicScalarWhereWithAggregatesInput[]
    NOT?: EpicScalarWhereWithAggregatesInput | EpicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Epic"> | string
    name?: StringWithAggregatesFilter<"Epic"> | string
    description?: StringNullableWithAggregatesFilter<"Epic"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Epic"> | $Enums.Status
    priority?: IntWithAggregatesFilter<"Epic"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"Epic"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Epic"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Epic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Epic"> | Date | string
    projectId?: StringWithAggregatesFilter<"Epic"> | string
    creatorId?: StringWithAggregatesFilter<"Epic"> | string
  }

  export type UserStoryWhereInput = {
    AND?: UserStoryWhereInput | UserStoryWhereInput[]
    OR?: UserStoryWhereInput[]
    NOT?: UserStoryWhereInput | UserStoryWhereInput[]
    id?: StringFilter<"UserStory"> | string
    title?: StringFilter<"UserStory"> | string
    description?: StringNullableFilter<"UserStory"> | string | null
    status?: EnumStatusFilter<"UserStory"> | $Enums.Status
    priority?: IntFilter<"UserStory"> | number
    createdAt?: DateTimeFilter<"UserStory"> | Date | string
    updatedAt?: DateTimeFilter<"UserStory"> | Date | string
    projectId?: StringFilter<"UserStory"> | string
    epicId?: StringNullableFilter<"UserStory"> | string | null
    creatorId?: StringFilter<"UserStory"> | string
    sprintId?: StringNullableFilter<"UserStory"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    epic?: XOR<EpicNullableScalarRelationFilter, EpicWhereInput> | null
    creator?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    tasks?: TaskListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type UserStoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    epicId?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    epic?: EpicOrderByWithRelationInput
    creator?: MemberOrderByWithRelationInput
    sprint?: SprintOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type UserStoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserStoryWhereInput | UserStoryWhereInput[]
    OR?: UserStoryWhereInput[]
    NOT?: UserStoryWhereInput | UserStoryWhereInput[]
    title?: StringFilter<"UserStory"> | string
    description?: StringNullableFilter<"UserStory"> | string | null
    status?: EnumStatusFilter<"UserStory"> | $Enums.Status
    priority?: IntFilter<"UserStory"> | number
    createdAt?: DateTimeFilter<"UserStory"> | Date | string
    updatedAt?: DateTimeFilter<"UserStory"> | Date | string
    projectId?: StringFilter<"UserStory"> | string
    epicId?: StringNullableFilter<"UserStory"> | string | null
    creatorId?: StringFilter<"UserStory"> | string
    sprintId?: StringNullableFilter<"UserStory"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    epic?: XOR<EpicNullableScalarRelationFilter, EpicWhereInput> | null
    creator?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    tasks?: TaskListRelationFilter
    comments?: CommentListRelationFilter
  }, "id">

  export type UserStoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    epicId?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    _count?: UserStoryCountOrderByAggregateInput
    _avg?: UserStoryAvgOrderByAggregateInput
    _max?: UserStoryMaxOrderByAggregateInput
    _min?: UserStoryMinOrderByAggregateInput
    _sum?: UserStorySumOrderByAggregateInput
  }

  export type UserStoryScalarWhereWithAggregatesInput = {
    AND?: UserStoryScalarWhereWithAggregatesInput | UserStoryScalarWhereWithAggregatesInput[]
    OR?: UserStoryScalarWhereWithAggregatesInput[]
    NOT?: UserStoryScalarWhereWithAggregatesInput | UserStoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserStory"> | string
    title?: StringWithAggregatesFilter<"UserStory"> | string
    description?: StringNullableWithAggregatesFilter<"UserStory"> | string | null
    status?: EnumStatusWithAggregatesFilter<"UserStory"> | $Enums.Status
    priority?: IntWithAggregatesFilter<"UserStory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserStory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserStory"> | Date | string
    projectId?: StringWithAggregatesFilter<"UserStory"> | string
    epicId?: StringNullableWithAggregatesFilter<"UserStory"> | string | null
    creatorId?: StringWithAggregatesFilter<"UserStory"> | string
    sprintId?: StringNullableWithAggregatesFilter<"UserStory"> | string | null
  }

  export type SprintWhereInput = {
    AND?: SprintWhereInput | SprintWhereInput[]
    OR?: SprintWhereInput[]
    NOT?: SprintWhereInput | SprintWhereInput[]
    id?: StringFilter<"Sprint"> | string
    name?: StringFilter<"Sprint"> | string
    description?: StringNullableFilter<"Sprint"> | string | null
    status?: EnumStatusFilter<"Sprint"> | $Enums.Status
    startDate?: DateTimeNullableFilter<"Sprint"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Sprint"> | Date | string | null
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    projectId?: StringFilter<"Sprint"> | string
    creatorId?: StringFilter<"Sprint"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    userStories?: UserStoryListRelationFilter
    tasks?: TaskListRelationFilter
    subtasks?: SubtaskListRelationFilter
    files?: FileListRelationFilter
  }

  export type SprintOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: MemberOrderByWithRelationInput
    userStories?: UserStoryOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    subtasks?: SubtaskOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
  }

  export type SprintWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SprintWhereInput | SprintWhereInput[]
    OR?: SprintWhereInput[]
    NOT?: SprintWhereInput | SprintWhereInput[]
    name?: StringFilter<"Sprint"> | string
    description?: StringNullableFilter<"Sprint"> | string | null
    status?: EnumStatusFilter<"Sprint"> | $Enums.Status
    startDate?: DateTimeNullableFilter<"Sprint"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Sprint"> | Date | string | null
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    projectId?: StringFilter<"Sprint"> | string
    creatorId?: StringFilter<"Sprint"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    userStories?: UserStoryListRelationFilter
    tasks?: TaskListRelationFilter
    subtasks?: SubtaskListRelationFilter
    files?: FileListRelationFilter
  }, "id">

  export type SprintOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
    _count?: SprintCountOrderByAggregateInput
    _max?: SprintMaxOrderByAggregateInput
    _min?: SprintMinOrderByAggregateInput
  }

  export type SprintScalarWhereWithAggregatesInput = {
    AND?: SprintScalarWhereWithAggregatesInput | SprintScalarWhereWithAggregatesInput[]
    OR?: SprintScalarWhereWithAggregatesInput[]
    NOT?: SprintScalarWhereWithAggregatesInput | SprintScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sprint"> | string
    name?: StringWithAggregatesFilter<"Sprint"> | string
    description?: StringNullableWithAggregatesFilter<"Sprint"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Sprint"> | $Enums.Status
    startDate?: DateTimeNullableWithAggregatesFilter<"Sprint"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Sprint"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    projectId?: StringWithAggregatesFilter<"Sprint"> | string
    creatorId?: StringWithAggregatesFilter<"Sprint"> | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumStatusFilter<"Task"> | $Enums.Status
    priority?: IntFilter<"Task"> | number
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedDuration?: IntNullableFilter<"Task"> | number | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    themaId?: StringNullableFilter<"Task"> | string | null
    userStoryId?: StringNullableFilter<"Task"> | string | null
    sprintId?: StringNullableFilter<"Task"> | string | null
    assigneeId?: StringNullableFilter<"Task"> | string | null
    thema?: XOR<ThemaNullableScalarRelationFilter, ThemaWhereInput> | null
    userStory?: XOR<UserStoryNullableScalarRelationFilter, UserStoryWhereInput> | null
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    assignee?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    subtasks?: SubtaskListRelationFilter
    dependencies?: TaskListRelationFilter
    blockedBy?: TaskListRelationFilter
    comments?: CommentListRelationFilter
    timeLogs?: TimeLogListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    themaId?: SortOrderInput | SortOrder
    userStoryId?: SortOrderInput | SortOrder
    sprintId?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    thema?: ThemaOrderByWithRelationInput
    userStory?: UserStoryOrderByWithRelationInput
    sprint?: SprintOrderByWithRelationInput
    assignee?: MemberOrderByWithRelationInput
    subtasks?: SubtaskOrderByRelationAggregateInput
    dependencies?: TaskOrderByRelationAggregateInput
    blockedBy?: TaskOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    timeLogs?: TimeLogOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumStatusFilter<"Task"> | $Enums.Status
    priority?: IntFilter<"Task"> | number
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedDuration?: IntNullableFilter<"Task"> | number | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    themaId?: StringNullableFilter<"Task"> | string | null
    userStoryId?: StringNullableFilter<"Task"> | string | null
    sprintId?: StringNullableFilter<"Task"> | string | null
    assigneeId?: StringNullableFilter<"Task"> | string | null
    thema?: XOR<ThemaNullableScalarRelationFilter, ThemaWhereInput> | null
    userStory?: XOR<UserStoryNullableScalarRelationFilter, UserStoryWhereInput> | null
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    assignee?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    subtasks?: SubtaskListRelationFilter
    dependencies?: TaskListRelationFilter
    blockedBy?: TaskListRelationFilter
    comments?: CommentListRelationFilter
    timeLogs?: TimeLogListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    themaId?: SortOrderInput | SortOrder
    userStoryId?: SortOrderInput | SortOrder
    sprintId?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Task"> | $Enums.Status
    priority?: IntWithAggregatesFilter<"Task"> | number
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    estimatedDuration?: IntNullableWithAggregatesFilter<"Task"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    themaId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    userStoryId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    sprintId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    assigneeId?: StringNullableWithAggregatesFilter<"Task"> | string | null
  }

  export type SubtaskWhereInput = {
    AND?: SubtaskWhereInput | SubtaskWhereInput[]
    OR?: SubtaskWhereInput[]
    NOT?: SubtaskWhereInput | SubtaskWhereInput[]
    id?: StringFilter<"Subtask"> | string
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: EnumStatusFilter<"Subtask"> | $Enums.Status
    createdAt?: DateTimeFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeFilter<"Subtask"> | Date | string
    taskId?: StringFilter<"Subtask"> | string
    sprintId?: StringNullableFilter<"Subtask"> | string | null
    assigneeId?: StringNullableFilter<"Subtask"> | string | null
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    assignee?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    files?: FileListRelationFilter
  }

  export type SubtaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    task?: TaskOrderByWithRelationInput
    sprint?: SprintOrderByWithRelationInput
    assignee?: MemberOrderByWithRelationInput
    files?: FileOrderByRelationAggregateInput
  }

  export type SubtaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubtaskWhereInput | SubtaskWhereInput[]
    OR?: SubtaskWhereInput[]
    NOT?: SubtaskWhereInput | SubtaskWhereInput[]
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: EnumStatusFilter<"Subtask"> | $Enums.Status
    createdAt?: DateTimeFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeFilter<"Subtask"> | Date | string
    taskId?: StringFilter<"Subtask"> | string
    sprintId?: StringNullableFilter<"Subtask"> | string | null
    assigneeId?: StringNullableFilter<"Subtask"> | string | null
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    assignee?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    files?: FileListRelationFilter
  }, "id">

  export type SubtaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    _count?: SubtaskCountOrderByAggregateInput
    _max?: SubtaskMaxOrderByAggregateInput
    _min?: SubtaskMinOrderByAggregateInput
  }

  export type SubtaskScalarWhereWithAggregatesInput = {
    AND?: SubtaskScalarWhereWithAggregatesInput | SubtaskScalarWhereWithAggregatesInput[]
    OR?: SubtaskScalarWhereWithAggregatesInput[]
    NOT?: SubtaskScalarWhereWithAggregatesInput | SubtaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subtask"> | string
    title?: StringWithAggregatesFilter<"Subtask"> | string
    description?: StringNullableWithAggregatesFilter<"Subtask"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Subtask"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subtask"> | Date | string
    taskId?: StringWithAggregatesFilter<"Subtask"> | string
    sprintId?: StringNullableWithAggregatesFilter<"Subtask"> | string | null
    assigneeId?: StringNullableWithAggregatesFilter<"Subtask"> | string | null
  }

  export type FolderWhereInput = {
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    id?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    path?: StringFilter<"Folder"> | string
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    parentId?: StringNullableFilter<"Folder"> | string | null
    projectId?: StringFilter<"Folder"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    files?: FileListRelationFilter
  }

  export type FolderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    files?: FileOrderByRelationAggregateInput
  }

  export type FolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    name?: StringFilter<"Folder"> | string
    path?: StringFilter<"Folder"> | string
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    parentId?: StringNullableFilter<"Folder"> | string | null
    projectId?: StringFilter<"Folder"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    files?: FileListRelationFilter
  }, "id">

  export type FolderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    _count?: FolderCountOrderByAggregateInput
    _max?: FolderMaxOrderByAggregateInput
    _min?: FolderMinOrderByAggregateInput
  }

  export type FolderScalarWhereWithAggregatesInput = {
    AND?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    OR?: FolderScalarWhereWithAggregatesInput[]
    NOT?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Folder"> | string
    name?: StringWithAggregatesFilter<"Folder"> | string
    path?: StringWithAggregatesFilter<"Folder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
    parentId?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    projectId?: StringWithAggregatesFilter<"Folder"> | string
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    description?: StringNullableFilter<"File"> | string | null
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    size?: IntFilter<"File"> | number
    url?: StringFilter<"File"> | string
    version?: IntFilter<"File"> | number
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    folderId?: StringNullableFilter<"File"> | string | null
    projectId?: StringFilter<"File"> | string
    subtaskId?: StringNullableFilter<"File"> | string | null
    sprintId?: StringNullableFilter<"File"> | string | null
    uploaderId?: StringFilter<"File"> | string
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    subtask?: XOR<SubtaskNullableScalarRelationFilter, SubtaskWhereInput> | null
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    uploader?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    dependencies?: DependencyListRelationFilter
    relationsFrom?: FileRelationListRelationFilter
    relationsTo?: FileRelationListRelationFilter
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    size?: SortOrder
    url?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    folderId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    subtaskId?: SortOrderInput | SortOrder
    sprintId?: SortOrderInput | SortOrder
    uploaderId?: SortOrder
    folder?: FolderOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    subtask?: SubtaskOrderByWithRelationInput
    sprint?: SprintOrderByWithRelationInput
    uploader?: MemberOrderByWithRelationInput
    dependencies?: DependencyOrderByRelationAggregateInput
    relationsFrom?: FileRelationOrderByRelationAggregateInput
    relationsTo?: FileRelationOrderByRelationAggregateInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    name?: StringFilter<"File"> | string
    description?: StringNullableFilter<"File"> | string | null
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    size?: IntFilter<"File"> | number
    url?: StringFilter<"File"> | string
    version?: IntFilter<"File"> | number
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    folderId?: StringNullableFilter<"File"> | string | null
    projectId?: StringFilter<"File"> | string
    subtaskId?: StringNullableFilter<"File"> | string | null
    sprintId?: StringNullableFilter<"File"> | string | null
    uploaderId?: StringFilter<"File"> | string
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    subtask?: XOR<SubtaskNullableScalarRelationFilter, SubtaskWhereInput> | null
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    uploader?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    dependencies?: DependencyListRelationFilter
    relationsFrom?: FileRelationListRelationFilter
    relationsTo?: FileRelationListRelationFilter
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    size?: SortOrder
    url?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    folderId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    subtaskId?: SortOrderInput | SortOrder
    sprintId?: SortOrderInput | SortOrder
    uploaderId?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    name?: StringWithAggregatesFilter<"File"> | string
    description?: StringNullableWithAggregatesFilter<"File"> | string | null
    type?: EnumFileTypeWithAggregatesFilter<"File"> | $Enums.FileType
    size?: IntWithAggregatesFilter<"File"> | number
    url?: StringWithAggregatesFilter<"File"> | string
    version?: IntWithAggregatesFilter<"File"> | number
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    folderId?: StringNullableWithAggregatesFilter<"File"> | string | null
    projectId?: StringWithAggregatesFilter<"File"> | string
    subtaskId?: StringNullableWithAggregatesFilter<"File"> | string | null
    sprintId?: StringNullableWithAggregatesFilter<"File"> | string | null
    uploaderId?: StringWithAggregatesFilter<"File"> | string
  }

  export type DependencyWhereInput = {
    AND?: DependencyWhereInput | DependencyWhereInput[]
    OR?: DependencyWhereInput[]
    NOT?: DependencyWhereInput | DependencyWhereInput[]
    id?: StringFilter<"Dependency"> | string
    fileId?: StringFilter<"Dependency"> | string
    componentName?: StringFilter<"Dependency"> | string
    version?: StringNullableFilter<"Dependency"> | string | null
    createdAt?: DateTimeFilter<"Dependency"> | Date | string
    file?: XOR<FileScalarRelationFilter, FileWhereInput>
  }

  export type DependencyOrderByWithRelationInput = {
    id?: SortOrder
    fileId?: SortOrder
    componentName?: SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    file?: FileOrderByWithRelationInput
  }

  export type DependencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DependencyWhereInput | DependencyWhereInput[]
    OR?: DependencyWhereInput[]
    NOT?: DependencyWhereInput | DependencyWhereInput[]
    fileId?: StringFilter<"Dependency"> | string
    componentName?: StringFilter<"Dependency"> | string
    version?: StringNullableFilter<"Dependency"> | string | null
    createdAt?: DateTimeFilter<"Dependency"> | Date | string
    file?: XOR<FileScalarRelationFilter, FileWhereInput>
  }, "id">

  export type DependencyOrderByWithAggregationInput = {
    id?: SortOrder
    fileId?: SortOrder
    componentName?: SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DependencyCountOrderByAggregateInput
    _max?: DependencyMaxOrderByAggregateInput
    _min?: DependencyMinOrderByAggregateInput
  }

  export type DependencyScalarWhereWithAggregatesInput = {
    AND?: DependencyScalarWhereWithAggregatesInput | DependencyScalarWhereWithAggregatesInput[]
    OR?: DependencyScalarWhereWithAggregatesInput[]
    NOT?: DependencyScalarWhereWithAggregatesInput | DependencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dependency"> | string
    fileId?: StringWithAggregatesFilter<"Dependency"> | string
    componentName?: StringWithAggregatesFilter<"Dependency"> | string
    version?: StringNullableWithAggregatesFilter<"Dependency"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Dependency"> | Date | string
  }

  export type FileRelationWhereInput = {
    AND?: FileRelationWhereInput | FileRelationWhereInput[]
    OR?: FileRelationWhereInput[]
    NOT?: FileRelationWhereInput | FileRelationWhereInput[]
    id?: StringFilter<"FileRelation"> | string
    fromFileId?: StringFilter<"FileRelation"> | string
    toFileId?: StringFilter<"FileRelation"> | string
    type?: EnumRelationTypeFilter<"FileRelation"> | $Enums.RelationType
    createdAt?: DateTimeFilter<"FileRelation"> | Date | string
    fromFile?: XOR<FileScalarRelationFilter, FileWhereInput>
    toFile?: XOR<FileScalarRelationFilter, FileWhereInput>
  }

  export type FileRelationOrderByWithRelationInput = {
    id?: SortOrder
    fromFileId?: SortOrder
    toFileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    fromFile?: FileOrderByWithRelationInput
    toFile?: FileOrderByWithRelationInput
  }

  export type FileRelationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fromFileId_toFileId?: FileRelationFromFileIdToFileIdCompoundUniqueInput
    AND?: FileRelationWhereInput | FileRelationWhereInput[]
    OR?: FileRelationWhereInput[]
    NOT?: FileRelationWhereInput | FileRelationWhereInput[]
    fromFileId?: StringFilter<"FileRelation"> | string
    toFileId?: StringFilter<"FileRelation"> | string
    type?: EnumRelationTypeFilter<"FileRelation"> | $Enums.RelationType
    createdAt?: DateTimeFilter<"FileRelation"> | Date | string
    fromFile?: XOR<FileScalarRelationFilter, FileWhereInput>
    toFile?: XOR<FileScalarRelationFilter, FileWhereInput>
  }, "id" | "fromFileId_toFileId">

  export type FileRelationOrderByWithAggregationInput = {
    id?: SortOrder
    fromFileId?: SortOrder
    toFileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: FileRelationCountOrderByAggregateInput
    _max?: FileRelationMaxOrderByAggregateInput
    _min?: FileRelationMinOrderByAggregateInput
  }

  export type FileRelationScalarWhereWithAggregatesInput = {
    AND?: FileRelationScalarWhereWithAggregatesInput | FileRelationScalarWhereWithAggregatesInput[]
    OR?: FileRelationScalarWhereWithAggregatesInput[]
    NOT?: FileRelationScalarWhereWithAggregatesInput | FileRelationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileRelation"> | string
    fromFileId?: StringWithAggregatesFilter<"FileRelation"> | string
    toFileId?: StringWithAggregatesFilter<"FileRelation"> | string
    type?: EnumRelationTypeWithAggregatesFilter<"FileRelation"> | $Enums.RelationType
    createdAt?: DateTimeWithAggregatesFilter<"FileRelation"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    authorId?: StringFilter<"Comment"> | string
    projectId?: StringNullableFilter<"Comment"> | string | null
    themaId?: StringNullableFilter<"Comment"> | string | null
    epicId?: StringNullableFilter<"Comment"> | string | null
    userStoryId?: StringNullableFilter<"Comment"> | string | null
    taskId?: StringNullableFilter<"Comment"> | string | null
    author?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    thema?: XOR<ThemaNullableScalarRelationFilter, ThemaWhereInput> | null
    epic?: XOR<EpicNullableScalarRelationFilter, EpicWhereInput> | null
    userStory?: XOR<UserStoryNullableScalarRelationFilter, UserStoryWhereInput> | null
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    themaId?: SortOrderInput | SortOrder
    epicId?: SortOrderInput | SortOrder
    userStoryId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    author?: MemberOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    thema?: ThemaOrderByWithRelationInput
    epic?: EpicOrderByWithRelationInput
    userStory?: UserStoryOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    authorId?: StringFilter<"Comment"> | string
    projectId?: StringNullableFilter<"Comment"> | string | null
    themaId?: StringNullableFilter<"Comment"> | string | null
    epicId?: StringNullableFilter<"Comment"> | string | null
    userStoryId?: StringNullableFilter<"Comment"> | string | null
    taskId?: StringNullableFilter<"Comment"> | string | null
    author?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    thema?: XOR<ThemaNullableScalarRelationFilter, ThemaWhereInput> | null
    epic?: XOR<EpicNullableScalarRelationFilter, EpicWhereInput> | null
    userStory?: XOR<UserStoryNullableScalarRelationFilter, UserStoryWhereInput> | null
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    themaId?: SortOrderInput | SortOrder
    epicId?: SortOrderInput | SortOrder
    userStoryId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    projectId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    themaId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    epicId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    userStoryId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    taskId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type TimeLogWhereInput = {
    AND?: TimeLogWhereInput | TimeLogWhereInput[]
    OR?: TimeLogWhereInput[]
    NOT?: TimeLogWhereInput | TimeLogWhereInput[]
    id?: StringFilter<"TimeLog"> | string
    description?: StringNullableFilter<"TimeLog"> | string | null
    startTime?: DateTimeFilter<"TimeLog"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    taskId?: StringFilter<"TimeLog"> | string
    memberId?: StringFilter<"TimeLog"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type TimeLogOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    taskId?: SortOrder
    memberId?: SortOrder
    task?: TaskOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type TimeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeLogWhereInput | TimeLogWhereInput[]
    OR?: TimeLogWhereInput[]
    NOT?: TimeLogWhereInput | TimeLogWhereInput[]
    description?: StringNullableFilter<"TimeLog"> | string | null
    startTime?: DateTimeFilter<"TimeLog"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    taskId?: StringFilter<"TimeLog"> | string
    memberId?: StringFilter<"TimeLog"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type TimeLogOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    taskId?: SortOrder
    memberId?: SortOrder
    _count?: TimeLogCountOrderByAggregateInput
    _max?: TimeLogMaxOrderByAggregateInput
    _min?: TimeLogMinOrderByAggregateInput
  }

  export type TimeLogScalarWhereWithAggregatesInput = {
    AND?: TimeLogScalarWhereWithAggregatesInput | TimeLogScalarWhereWithAggregatesInput[]
    OR?: TimeLogScalarWhereWithAggregatesInput[]
    NOT?: TimeLogScalarWhereWithAggregatesInput | TimeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeLog"> | string
    description?: StringNullableWithAggregatesFilter<"TimeLog"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"TimeLog"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"TimeLog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TimeLog"> | Date | string
    taskId?: StringWithAggregatesFilter<"TimeLog"> | string
    memberId?: StringWithAggregatesFilter<"TimeLog"> | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    action?: EnumActionTypeFilter<"ActivityLog"> | $Enums.ActionType
    entityId?: StringFilter<"ActivityLog"> | string
    timestamp?: DateTimeFilter<"ActivityLog"> | Date | string
    memberId?: StringFilter<"ActivityLog"> | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityId?: SortOrder
    timestamp?: SortOrder
    memberId?: SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    action?: EnumActionTypeFilter<"ActivityLog"> | $Enums.ActionType
    entityId?: StringFilter<"ActivityLog"> | string
    timestamp?: DateTimeFilter<"ActivityLog"> | Date | string
    memberId?: StringFilter<"ActivityLog"> | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityId?: SortOrder
    timestamp?: SortOrder
    memberId?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    action?: EnumActionTypeWithAggregatesFilter<"ActivityLog"> | $Enums.ActionType
    entityId?: StringWithAggregatesFilter<"ActivityLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
    memberId?: StringWithAggregatesFilter<"ActivityLog"> | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.Role
    lang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    memberships?: MemberCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.Role
    lang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    memberships?: MemberUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    memberships?: MemberUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MemberUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.Role
    lang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVerificationsInput
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVerificationsNestedInput
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAggregateCreateInput = {
    id?: string
    userName?: string | null
    userEmail?: string | null
    userImage?: string | null
    userRole?: $Enums.Role
    userLang?: string | null
    userCreatedAt?: Date | string
    userUpdatedAt?: Date | string
    sessions: JsonNullValueInput | InputJsonValue
    accounts: JsonNullValueInput | InputJsonValue
    memberProjects: JsonNullValueInput | InputJsonValue
    projects: JsonNullValueInput | InputJsonValue
    files: JsonNullValueInput | InputJsonValue
    tasks: JsonNullValueInput | InputJsonValue
    subtasks: JsonNullValueInput | InputJsonValue
    comments: JsonNullValueInput | InputJsonValue
    timeLogs: JsonNullValueInput | InputJsonValue
    epics: JsonNullValueInput | InputJsonValue
    userStories: JsonNullValueInput | InputJsonValue
    sprints: JsonNullValueInput | InputJsonValue
    themas: JsonNullValueInput | InputJsonValue
    activities: JsonNullValueInput | InputJsonValue
    fileDependencies: JsonNullValueInput | InputJsonValue
    fileRelations: JsonNullValueInput | InputJsonValue
  }

  export type UserAggregateUncheckedCreateInput = {
    id?: string
    userName?: string | null
    userEmail?: string | null
    userImage?: string | null
    userRole?: $Enums.Role
    userLang?: string | null
    userCreatedAt?: Date | string
    userUpdatedAt?: Date | string
    sessions: JsonNullValueInput | InputJsonValue
    accounts: JsonNullValueInput | InputJsonValue
    memberProjects: JsonNullValueInput | InputJsonValue
    projects: JsonNullValueInput | InputJsonValue
    files: JsonNullValueInput | InputJsonValue
    tasks: JsonNullValueInput | InputJsonValue
    subtasks: JsonNullValueInput | InputJsonValue
    comments: JsonNullValueInput | InputJsonValue
    timeLogs: JsonNullValueInput | InputJsonValue
    epics: JsonNullValueInput | InputJsonValue
    userStories: JsonNullValueInput | InputJsonValue
    sprints: JsonNullValueInput | InputJsonValue
    themas: JsonNullValueInput | InputJsonValue
    activities: JsonNullValueInput | InputJsonValue
    fileDependencies: JsonNullValueInput | InputJsonValue
    fileRelations: JsonNullValueInput | InputJsonValue
  }

  export type UserAggregateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userImage?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userLang?: NullableStringFieldUpdateOperationsInput | string | null
    userCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: JsonNullValueInput | InputJsonValue
    accounts?: JsonNullValueInput | InputJsonValue
    memberProjects?: JsonNullValueInput | InputJsonValue
    projects?: JsonNullValueInput | InputJsonValue
    files?: JsonNullValueInput | InputJsonValue
    tasks?: JsonNullValueInput | InputJsonValue
    subtasks?: JsonNullValueInput | InputJsonValue
    comments?: JsonNullValueInput | InputJsonValue
    timeLogs?: JsonNullValueInput | InputJsonValue
    epics?: JsonNullValueInput | InputJsonValue
    userStories?: JsonNullValueInput | InputJsonValue
    sprints?: JsonNullValueInput | InputJsonValue
    themas?: JsonNullValueInput | InputJsonValue
    activities?: JsonNullValueInput | InputJsonValue
    fileDependencies?: JsonNullValueInput | InputJsonValue
    fileRelations?: JsonNullValueInput | InputJsonValue
  }

  export type UserAggregateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userImage?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userLang?: NullableStringFieldUpdateOperationsInput | string | null
    userCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: JsonNullValueInput | InputJsonValue
    accounts?: JsonNullValueInput | InputJsonValue
    memberProjects?: JsonNullValueInput | InputJsonValue
    projects?: JsonNullValueInput | InputJsonValue
    files?: JsonNullValueInput | InputJsonValue
    tasks?: JsonNullValueInput | InputJsonValue
    subtasks?: JsonNullValueInput | InputJsonValue
    comments?: JsonNullValueInput | InputJsonValue
    timeLogs?: JsonNullValueInput | InputJsonValue
    epics?: JsonNullValueInput | InputJsonValue
    userStories?: JsonNullValueInput | InputJsonValue
    sprints?: JsonNullValueInput | InputJsonValue
    themas?: JsonNullValueInput | InputJsonValue
    activities?: JsonNullValueInput | InputJsonValue
    fileDependencies?: JsonNullValueInput | InputJsonValue
    fileRelations?: JsonNullValueInput | InputJsonValue
  }

  export type UserAggregateCreateManyInput = {
    id?: string
    userName?: string | null
    userEmail?: string | null
    userImage?: string | null
    userRole?: $Enums.Role
    userLang?: string | null
    userCreatedAt?: Date | string
    userUpdatedAt?: Date | string
    sessions: JsonNullValueInput | InputJsonValue
    accounts: JsonNullValueInput | InputJsonValue
    memberProjects: JsonNullValueInput | InputJsonValue
    projects: JsonNullValueInput | InputJsonValue
    files: JsonNullValueInput | InputJsonValue
    tasks: JsonNullValueInput | InputJsonValue
    subtasks: JsonNullValueInput | InputJsonValue
    comments: JsonNullValueInput | InputJsonValue
    timeLogs: JsonNullValueInput | InputJsonValue
    epics: JsonNullValueInput | InputJsonValue
    userStories: JsonNullValueInput | InputJsonValue
    sprints: JsonNullValueInput | InputJsonValue
    themas: JsonNullValueInput | InputJsonValue
    activities: JsonNullValueInput | InputJsonValue
    fileDependencies: JsonNullValueInput | InputJsonValue
    fileRelations: JsonNullValueInput | InputJsonValue
  }

  export type UserAggregateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userImage?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userLang?: NullableStringFieldUpdateOperationsInput | string | null
    userCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: JsonNullValueInput | InputJsonValue
    accounts?: JsonNullValueInput | InputJsonValue
    memberProjects?: JsonNullValueInput | InputJsonValue
    projects?: JsonNullValueInput | InputJsonValue
    files?: JsonNullValueInput | InputJsonValue
    tasks?: JsonNullValueInput | InputJsonValue
    subtasks?: JsonNullValueInput | InputJsonValue
    comments?: JsonNullValueInput | InputJsonValue
    timeLogs?: JsonNullValueInput | InputJsonValue
    epics?: JsonNullValueInput | InputJsonValue
    userStories?: JsonNullValueInput | InputJsonValue
    sprints?: JsonNullValueInput | InputJsonValue
    themas?: JsonNullValueInput | InputJsonValue
    activities?: JsonNullValueInput | InputJsonValue
    fileDependencies?: JsonNullValueInput | InputJsonValue
    fileRelations?: JsonNullValueInput | InputJsonValue
  }

  export type UserAggregateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userImage?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userLang?: NullableStringFieldUpdateOperationsInput | string | null
    userCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: JsonNullValueInput | InputJsonValue
    accounts?: JsonNullValueInput | InputJsonValue
    memberProjects?: JsonNullValueInput | InputJsonValue
    projects?: JsonNullValueInput | InputJsonValue
    files?: JsonNullValueInput | InputJsonValue
    tasks?: JsonNullValueInput | InputJsonValue
    subtasks?: JsonNullValueInput | InputJsonValue
    comments?: JsonNullValueInput | InputJsonValue
    timeLogs?: JsonNullValueInput | InputJsonValue
    epics?: JsonNullValueInput | InputJsonValue
    userStories?: JsonNullValueInput | InputJsonValue
    sprints?: JsonNullValueInput | InputJsonValue
    themas?: JsonNullValueInput | InputJsonValue
    activities?: JsonNullValueInput | InputJsonValue
    fileDependencies?: JsonNullValueInput | InputJsonValue
    fileRelations?: JsonNullValueInput | InputJsonValue
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themas?: ThemaCreateNestedManyWithoutProjectInput
    epics?: EpicCreateNestedManyWithoutProjectInput
    userStories?: UserStoryCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    folders?: FolderCreateNestedManyWithoutProjectInput
    files?: FileCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    creator?: MemberCreateNestedOneWithoutCreatedProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId?: string | null
    themas?: ThemaUncheckedCreateNestedManyWithoutProjectInput
    epics?: EpicUncheckedCreateNestedManyWithoutProjectInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    folders?: FolderUncheckedCreateNestedManyWithoutProjectInput
    files?: FileUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themas?: ThemaUpdateManyWithoutProjectNestedInput
    epics?: EpicUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    folders?: FolderUpdateManyWithoutProjectNestedInput
    files?: FileUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    creator?: MemberUpdateOneWithoutCreatedProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    themas?: ThemaUncheckedUpdateManyWithoutProjectNestedInput
    epics?: EpicUncheckedUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    folders?: FolderUncheckedUpdateManyWithoutProjectNestedInput
    files?: FileUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberCreateInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MemberCreateManyInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ThemaCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutThemasInput
    creator: MemberCreateNestedOneWithoutThemasInput
    tasks?: TaskCreateNestedManyWithoutThemaInput
    comments?: CommentCreateNestedManyWithoutThemaInput
  }

  export type ThemaUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutThemaInput
    comments?: CommentUncheckedCreateNestedManyWithoutThemaInput
  }

  export type ThemaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutThemasNestedInput
    creator?: MemberUpdateOneRequiredWithoutThemasNestedInput
    tasks?: TaskUpdateManyWithoutThemaNestedInput
    comments?: CommentUpdateManyWithoutThemaNestedInput
  }

  export type ThemaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutThemaNestedInput
    comments?: CommentUncheckedUpdateManyWithoutThemaNestedInput
  }

  export type ThemaCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
  }

  export type ThemaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type EpicCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutEpicsInput
    creator: MemberCreateNestedOneWithoutEpicsInput
    userStories?: UserStoryCreateNestedManyWithoutEpicInput
    comments?: CommentCreateNestedManyWithoutEpicInput
  }

  export type EpicUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    userStories?: UserStoryUncheckedCreateNestedManyWithoutEpicInput
    comments?: CommentUncheckedCreateNestedManyWithoutEpicInput
  }

  export type EpicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutEpicsNestedInput
    creator?: MemberUpdateOneRequiredWithoutEpicsNestedInput
    userStories?: UserStoryUpdateManyWithoutEpicNestedInput
    comments?: CommentUpdateManyWithoutEpicNestedInput
  }

  export type EpicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    userStories?: UserStoryUncheckedUpdateManyWithoutEpicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutEpicNestedInput
  }

  export type EpicCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
  }

  export type EpicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EpicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type UserStoryCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUserStoriesInput
    epic?: EpicCreateNestedOneWithoutUserStoriesInput
    creator: MemberCreateNestedOneWithoutUserStoriesInput
    sprint?: SprintCreateNestedOneWithoutUserStoriesInput
    tasks?: TaskCreateNestedManyWithoutUserStoryInput
    comments?: CommentCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    epicId?: string | null
    creatorId: string
    sprintId?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutUserStoryInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUserStoriesNestedInput
    epic?: EpicUpdateOneWithoutUserStoriesNestedInput
    creator?: MemberUpdateOneRequiredWithoutUserStoriesNestedInput
    sprint?: SprintUpdateOneWithoutUserStoriesNestedInput
    tasks?: TaskUpdateManyWithoutUserStoryNestedInput
    comments?: CommentUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutUserStoryNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    epicId?: string | null
    creatorId: string
    sprintId?: string | null
  }

  export type UserStoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SprintCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    creator: MemberCreateNestedOneWithoutSprintsInput
    userStories?: UserStoryCreateNestedManyWithoutSprintInput
    tasks?: TaskCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskCreateNestedManyWithoutSprintInput
    files?: FileCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    userStories?: UserStoryUncheckedCreateNestedManyWithoutSprintInput
    tasks?: TaskUncheckedCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutSprintInput
    files?: FileUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    creator?: MemberUpdateOneRequiredWithoutSprintsNestedInput
    userStories?: UserStoryUpdateManyWithoutSprintNestedInput
    tasks?: TaskUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUpdateManyWithoutSprintNestedInput
    files?: FileUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    userStories?: UserStoryUncheckedUpdateManyWithoutSprintNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutSprintNestedInput
    files?: FileUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type SprintCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
  }

  export type SprintUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thema?: ThemaCreateNestedOneWithoutTasksInput
    userStory?: UserStoryCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    assignee?: MemberCreateNestedOneWithoutTasksInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    dependencies?: TaskCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskCreateNestedManyWithoutDependenciesInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    userStoryId?: string | null
    sprintId?: string | null
    assigneeId?: string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    dependencies?: TaskUncheckedCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskUncheckedCreateNestedManyWithoutDependenciesInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thema?: ThemaUpdateOneWithoutTasksNestedInput
    userStory?: UserStoryUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    assignee?: MemberUpdateOneWithoutTasksNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUncheckedUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUncheckedUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    userStoryId?: string | null
    sprintId?: string | null
    assigneeId?: string | null
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubtaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutSubtasksInput
    sprint?: SprintCreateNestedOneWithoutSubtasksInput
    assignee?: MemberCreateNestedOneWithoutSubtasksInput
    files?: FileCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    taskId: string
    sprintId?: string | null
    assigneeId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    sprint?: SprintUpdateOneWithoutSubtasksNestedInput
    assignee?: MemberUpdateOneWithoutSubtasksNestedInput
    files?: FileUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    taskId: string
    sprintId?: string | null
    assigneeId?: string | null
  }

  export type SubtaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FolderCreateInput = {
    id?: string
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    project: ProjectCreateNestedOneWithoutFoldersInput
    files?: FileCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateInput = {
    id?: string
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutFoldersNestedInput
    files?: FileUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderCreateManyInput = {
    id?: string
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    projectId: string
  }

  export type FolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type FileCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: FolderCreateNestedOneWithoutFilesInput
    project: ProjectCreateNestedOneWithoutFilesInput
    subtask?: SubtaskCreateNestedOneWithoutFilesInput
    sprint?: SprintCreateNestedOneWithoutFilesInput
    uploader: MemberCreateNestedOneWithoutFilesInput
    dependencies?: DependencyCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationCreateNestedManyWithoutToFileInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    projectId: string
    subtaskId?: string | null
    sprintId?: string | null
    uploaderId: string
    dependencies?: DependencyUncheckedCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationUncheckedCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationUncheckedCreateNestedManyWithoutToFileInput
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutFilesNestedInput
    project?: ProjectUpdateOneRequiredWithoutFilesNestedInput
    subtask?: SubtaskUpdateOneWithoutFilesNestedInput
    sprint?: SprintUpdateOneWithoutFilesNestedInput
    uploader?: MemberUpdateOneRequiredWithoutFilesNestedInput
    dependencies?: DependencyUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    dependencies?: DependencyUncheckedUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUncheckedUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUncheckedUpdateManyWithoutToFileNestedInput
  }

  export type FileCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    projectId: string
    subtaskId?: string | null
    sprintId?: string | null
    uploaderId: string
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
  }

  export type DependencyCreateInput = {
    id?: string
    componentName: string
    version?: string | null
    createdAt?: Date | string
    file: FileCreateNestedOneWithoutDependenciesInput
  }

  export type DependencyUncheckedCreateInput = {
    id?: string
    fileId: string
    componentName: string
    version?: string | null
    createdAt?: Date | string
  }

  export type DependencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentName?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileUpdateOneRequiredWithoutDependenciesNestedInput
  }

  export type DependencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    componentName?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependencyCreateManyInput = {
    id?: string
    fileId: string
    componentName: string
    version?: string | null
    createdAt?: Date | string
  }

  export type DependencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentName?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    componentName?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileRelationCreateInput = {
    id?: string
    type: $Enums.RelationType
    createdAt?: Date | string
    fromFile: FileCreateNestedOneWithoutRelationsFromInput
    toFile: FileCreateNestedOneWithoutRelationsToInput
  }

  export type FileRelationUncheckedCreateInput = {
    id?: string
    fromFileId: string
    toFileId: string
    type: $Enums.RelationType
    createdAt?: Date | string
  }

  export type FileRelationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFile?: FileUpdateOneRequiredWithoutRelationsFromNestedInput
    toFile?: FileUpdateOneRequiredWithoutRelationsToNestedInput
  }

  export type FileRelationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromFileId?: StringFieldUpdateOperationsInput | string
    toFileId?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileRelationCreateManyInput = {
    id?: string
    fromFileId: string
    toFileId: string
    type: $Enums.RelationType
    createdAt?: Date | string
  }

  export type FileRelationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileRelationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromFileId?: StringFieldUpdateOperationsInput | string
    toFileId?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: MemberCreateNestedOneWithoutCommentsInput
    project?: ProjectCreateNestedOneWithoutCommentsInput
    thema?: ThemaCreateNestedOneWithoutCommentsInput
    epic?: EpicCreateNestedOneWithoutCommentsInput
    userStory?: UserStoryCreateNestedOneWithoutCommentsInput
    task?: TaskCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    projectId?: string | null
    themaId?: string | null
    epicId?: string | null
    userStoryId?: string | null
    taskId?: string | null
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    project?: ProjectUpdateOneWithoutCommentsNestedInput
    thema?: ThemaUpdateOneWithoutCommentsNestedInput
    epic?: EpicUpdateOneWithoutCommentsNestedInput
    userStory?: UserStoryUpdateOneWithoutCommentsNestedInput
    task?: TaskUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    projectId?: string | null
    themaId?: string | null
    epicId?: string | null
    userStoryId?: string | null
    taskId?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeLogCreateInput = {
    id?: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutTimeLogsInput
    member: MemberCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateInput = {
    id?: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    taskId: string
    memberId: string
  }

  export type TimeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTimeLogsNestedInput
    member?: MemberUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogCreateManyInput = {
    id?: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    taskId: string
    memberId: string
  }

  export type TimeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityLogCreateInput = {
    id?: string
    action: $Enums.ActionType
    entityId: string
    timestamp?: Date | string
    member: MemberCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    action: $Enums.ActionType
    entityId: string
    timestamp?: Date | string
    memberId: string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entityId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entityId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    action: $Enums.ActionType
    entityId: string
    timestamp?: Date | string
    memberId: string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entityId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entityId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type VerificationListRelationFilter = {
    every?: VerificationWhereInput
    some?: VerificationWhereInput
    none?: VerificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    lang?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    lang?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    lang?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserAggregateCountOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    userImage?: SortOrder
    userRole?: SortOrder
    userLang?: SortOrder
    userCreatedAt?: SortOrder
    userUpdatedAt?: SortOrder
    sessions?: SortOrder
    accounts?: SortOrder
    memberProjects?: SortOrder
    projects?: SortOrder
    files?: SortOrder
    tasks?: SortOrder
    subtasks?: SortOrder
    comments?: SortOrder
    timeLogs?: SortOrder
    epics?: SortOrder
    userStories?: SortOrder
    sprints?: SortOrder
    themas?: SortOrder
    activities?: SortOrder
    fileDependencies?: SortOrder
    fileRelations?: SortOrder
  }

  export type UserAggregateMaxOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    userImage?: SortOrder
    userRole?: SortOrder
    userLang?: SortOrder
    userCreatedAt?: SortOrder
    userUpdatedAt?: SortOrder
  }

  export type UserAggregateMinOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    userImage?: SortOrder
    userRole?: SortOrder
    userLang?: SortOrder
    userCreatedAt?: SortOrder
    userUpdatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ThemaListRelationFilter = {
    every?: ThemaWhereInput
    some?: ThemaWhereInput
    none?: ThemaWhereInput
  }

  export type EpicListRelationFilter = {
    every?: EpicWhereInput
    some?: EpicWhereInput
    none?: EpicWhereInput
  }

  export type UserStoryListRelationFilter = {
    every?: UserStoryWhereInput
    some?: UserStoryWhereInput
    none?: UserStoryWhereInput
  }

  export type SprintListRelationFilter = {
    every?: SprintWhereInput
    some?: SprintWhereInput
    none?: SprintWhereInput
  }

  export type FolderListRelationFilter = {
    every?: FolderWhereInput
    some?: FolderWhereInput
    none?: FolderWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type MemberNullableScalarRelationFilter = {
    is?: MemberWhereInput | null
    isNot?: MemberWhereInput | null
  }

  export type ThemaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EpicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserStoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SprintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type SubtaskListRelationFilter = {
    every?: SubtaskWhereInput
    some?: SubtaskWhereInput
    none?: SubtaskWhereInput
  }

  export type TimeLogListRelationFilter = {
    every?: TimeLogWhereInput
    some?: TimeLogWhereInput
    none?: TimeLogWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubtaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberUserIdProjectIdCompoundUniqueInput = {
    userId: string
    projectId: string
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type MemberScalarRelationFilter = {
    is?: MemberWhereInput
    isNot?: MemberWhereInput
  }

  export type ThemaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
  }

  export type ThemaAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type ThemaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
  }

  export type ThemaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
  }

  export type ThemaSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EpicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
  }

  export type EpicAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EpicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
  }

  export type EpicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
  }

  export type EpicSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EpicNullableScalarRelationFilter = {
    is?: EpicWhereInput | null
    isNot?: EpicWhereInput | null
  }

  export type SprintNullableScalarRelationFilter = {
    is?: SprintWhereInput | null
    isNot?: SprintWhereInput | null
  }

  export type UserStoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    epicId?: SortOrder
    creatorId?: SortOrder
    sprintId?: SortOrder
  }

  export type UserStoryAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type UserStoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    epicId?: SortOrder
    creatorId?: SortOrder
    sprintId?: SortOrder
  }

  export type UserStoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    epicId?: SortOrder
    creatorId?: SortOrder
    sprintId?: SortOrder
  }

  export type UserStorySumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type SprintCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
  }

  export type SprintMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
  }

  export type SprintMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ThemaNullableScalarRelationFilter = {
    is?: ThemaWhereInput | null
    isNot?: ThemaWhereInput | null
  }

  export type UserStoryNullableScalarRelationFilter = {
    is?: UserStoryWhereInput | null
    isNot?: UserStoryWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    themaId?: SortOrder
    userStoryId?: SortOrder
    sprintId?: SortOrder
    assigneeId?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    priority?: SortOrder
    estimatedDuration?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    themaId?: SortOrder
    userStoryId?: SortOrder
    sprintId?: SortOrder
    assigneeId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    themaId?: SortOrder
    userStoryId?: SortOrder
    sprintId?: SortOrder
    assigneeId?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    priority?: SortOrder
    estimatedDuration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type SubtaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    sprintId?: SortOrder
    assigneeId?: SortOrder
  }

  export type SubtaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    sprintId?: SortOrder
    assigneeId?: SortOrder
  }

  export type SubtaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    sprintId?: SortOrder
    assigneeId?: SortOrder
  }

  export type FolderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    projectId?: SortOrder
  }

  export type FolderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    projectId?: SortOrder
  }

  export type FolderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    projectId?: SortOrder
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[]
    notIn?: $Enums.FileType[]
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type FolderNullableScalarRelationFilter = {
    is?: FolderWhereInput | null
    isNot?: FolderWhereInput | null
  }

  export type SubtaskNullableScalarRelationFilter = {
    is?: SubtaskWhereInput | null
    isNot?: SubtaskWhereInput | null
  }

  export type DependencyListRelationFilter = {
    every?: DependencyWhereInput
    some?: DependencyWhereInput
    none?: DependencyWhereInput
  }

  export type FileRelationListRelationFilter = {
    every?: FileRelationWhereInput
    some?: FileRelationWhereInput
    none?: FileRelationWhereInput
  }

  export type DependencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    size?: SortOrder
    url?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    folderId?: SortOrder
    projectId?: SortOrder
    subtaskId?: SortOrder
    sprintId?: SortOrder
    uploaderId?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
    version?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    size?: SortOrder
    url?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    folderId?: SortOrder
    projectId?: SortOrder
    subtaskId?: SortOrder
    sprintId?: SortOrder
    uploaderId?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    size?: SortOrder
    url?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    folderId?: SortOrder
    projectId?: SortOrder
    subtaskId?: SortOrder
    sprintId?: SortOrder
    uploaderId?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
    version?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[]
    notIn?: $Enums.FileType[]
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type FileScalarRelationFilter = {
    is?: FileWhereInput
    isNot?: FileWhereInput
  }

  export type DependencyCountOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    componentName?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
  }

  export type DependencyMaxOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    componentName?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
  }

  export type DependencyMinOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    componentName?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRelationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[]
    notIn?: $Enums.RelationType[]
    not?: NestedEnumRelationTypeFilter<$PrismaModel> | $Enums.RelationType
  }

  export type FileRelationFromFileIdToFileIdCompoundUniqueInput = {
    fromFileId: string
    toFileId: string
  }

  export type FileRelationCountOrderByAggregateInput = {
    id?: SortOrder
    fromFileId?: SortOrder
    toFileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type FileRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    fromFileId?: SortOrder
    toFileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type FileRelationMinOrderByAggregateInput = {
    id?: SortOrder
    fromFileId?: SortOrder
    toFileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRelationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[]
    notIn?: $Enums.RelationType[]
    not?: NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationTypeFilter<$PrismaModel>
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type TaskNullableScalarRelationFilter = {
    is?: TaskWhereInput | null
    isNot?: TaskWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    themaId?: SortOrder
    epicId?: SortOrder
    userStoryId?: SortOrder
    taskId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    themaId?: SortOrder
    epicId?: SortOrder
    userStoryId?: SortOrder
    taskId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    themaId?: SortOrder
    epicId?: SortOrder
    userStoryId?: SortOrder
    taskId?: SortOrder
  }

  export type TimeLogCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    taskId?: SortOrder
    memberId?: SortOrder
  }

  export type TimeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    taskId?: SortOrder
    memberId?: SortOrder
  }

  export type TimeLogMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    taskId?: SortOrder
    memberId?: SortOrder
  }

  export type EnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[]
    notIn?: $Enums.ActionType[]
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityId?: SortOrder
    timestamp?: SortOrder
    memberId?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityId?: SortOrder
    timestamp?: SortOrder
    memberId?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityId?: SortOrder
    timestamp?: SortOrder
    memberId?: SortOrder
  }

  export type EnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[]
    notIn?: $Enums.ActionType[]
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type VerificationCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type VerificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type VerificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    upsert?: VerificationUpsertWithWhereUniqueWithoutUserInput | VerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    set?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    disconnect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    delete?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    update?: VerificationUpdateWithWhereUniqueWithoutUserInput | VerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationUpdateManyWithWhereWithoutUserInput | VerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type VerificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    upsert?: VerificationUpsertWithWhereUniqueWithoutUserInput | VerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    set?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    disconnect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    delete?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    update?: VerificationUpdateWithWhereUniqueWithoutUserInput | VerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationUpdateManyWithWhereWithoutUserInput | VerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutVerificationsInput = {
    create?: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVerificationsNestedInput = {
    create?: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationsInput
    upsert?: UserUpsertWithoutVerificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerificationsInput, UserUpdateWithoutVerificationsInput>, UserUncheckedUpdateWithoutVerificationsInput>
  }

  export type ThemaCreateNestedManyWithoutProjectInput = {
    create?: XOR<ThemaCreateWithoutProjectInput, ThemaUncheckedCreateWithoutProjectInput> | ThemaCreateWithoutProjectInput[] | ThemaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ThemaCreateOrConnectWithoutProjectInput | ThemaCreateOrConnectWithoutProjectInput[]
    createMany?: ThemaCreateManyProjectInputEnvelope
    connect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
  }

  export type EpicCreateNestedManyWithoutProjectInput = {
    create?: XOR<EpicCreateWithoutProjectInput, EpicUncheckedCreateWithoutProjectInput> | EpicCreateWithoutProjectInput[] | EpicUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EpicCreateOrConnectWithoutProjectInput | EpicCreateOrConnectWithoutProjectInput[]
    createMany?: EpicCreateManyProjectInputEnvelope
    connect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
  }

  export type UserStoryCreateNestedManyWithoutProjectInput = {
    create?: XOR<UserStoryCreateWithoutProjectInput, UserStoryUncheckedCreateWithoutProjectInput> | UserStoryCreateWithoutProjectInput[] | UserStoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutProjectInput | UserStoryCreateOrConnectWithoutProjectInput[]
    createMany?: UserStoryCreateManyProjectInputEnvelope
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
  }

  export type SprintCreateNestedManyWithoutProjectInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type FolderCreateNestedManyWithoutProjectInput = {
    create?: XOR<FolderCreateWithoutProjectInput, FolderUncheckedCreateWithoutProjectInput> | FolderCreateWithoutProjectInput[] | FolderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutProjectInput | FolderCreateOrConnectWithoutProjectInput[]
    createMany?: FolderCreateManyProjectInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutProjectInput = {
    create?: XOR<FileCreateWithoutProjectInput, FileUncheckedCreateWithoutProjectInput> | FileCreateWithoutProjectInput[] | FileUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FileCreateOrConnectWithoutProjectInput | FileCreateOrConnectWithoutProjectInput[]
    createMany?: FileCreateManyProjectInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutProjectInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type MemberCreateNestedOneWithoutCreatedProjectsInput = {
    create?: XOR<MemberCreateWithoutCreatedProjectsInput, MemberUncheckedCreateWithoutCreatedProjectsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCreatedProjectsInput
    connect?: MemberWhereUniqueInput
  }

  export type ThemaUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ThemaCreateWithoutProjectInput, ThemaUncheckedCreateWithoutProjectInput> | ThemaCreateWithoutProjectInput[] | ThemaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ThemaCreateOrConnectWithoutProjectInput | ThemaCreateOrConnectWithoutProjectInput[]
    createMany?: ThemaCreateManyProjectInputEnvelope
    connect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
  }

  export type EpicUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<EpicCreateWithoutProjectInput, EpicUncheckedCreateWithoutProjectInput> | EpicCreateWithoutProjectInput[] | EpicUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EpicCreateOrConnectWithoutProjectInput | EpicCreateOrConnectWithoutProjectInput[]
    createMany?: EpicCreateManyProjectInputEnvelope
    connect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
  }

  export type UserStoryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<UserStoryCreateWithoutProjectInput, UserStoryUncheckedCreateWithoutProjectInput> | UserStoryCreateWithoutProjectInput[] | UserStoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutProjectInput | UserStoryCreateOrConnectWithoutProjectInput[]
    createMany?: UserStoryCreateManyProjectInputEnvelope
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
  }

  export type SprintUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type FolderUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<FolderCreateWithoutProjectInput, FolderUncheckedCreateWithoutProjectInput> | FolderCreateWithoutProjectInput[] | FolderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutProjectInput | FolderCreateOrConnectWithoutProjectInput[]
    createMany?: FolderCreateManyProjectInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<FileCreateWithoutProjectInput, FileUncheckedCreateWithoutProjectInput> | FileCreateWithoutProjectInput[] | FileUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FileCreateOrConnectWithoutProjectInput | FileCreateOrConnectWithoutProjectInput[]
    createMany?: FileCreateManyProjectInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ThemaUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ThemaCreateWithoutProjectInput, ThemaUncheckedCreateWithoutProjectInput> | ThemaCreateWithoutProjectInput[] | ThemaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ThemaCreateOrConnectWithoutProjectInput | ThemaCreateOrConnectWithoutProjectInput[]
    upsert?: ThemaUpsertWithWhereUniqueWithoutProjectInput | ThemaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ThemaCreateManyProjectInputEnvelope
    set?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    disconnect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    delete?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    connect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    update?: ThemaUpdateWithWhereUniqueWithoutProjectInput | ThemaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ThemaUpdateManyWithWhereWithoutProjectInput | ThemaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ThemaScalarWhereInput | ThemaScalarWhereInput[]
  }

  export type EpicUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EpicCreateWithoutProjectInput, EpicUncheckedCreateWithoutProjectInput> | EpicCreateWithoutProjectInput[] | EpicUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EpicCreateOrConnectWithoutProjectInput | EpicCreateOrConnectWithoutProjectInput[]
    upsert?: EpicUpsertWithWhereUniqueWithoutProjectInput | EpicUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EpicCreateManyProjectInputEnvelope
    set?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    disconnect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    delete?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    connect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    update?: EpicUpdateWithWhereUniqueWithoutProjectInput | EpicUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EpicUpdateManyWithWhereWithoutProjectInput | EpicUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EpicScalarWhereInput | EpicScalarWhereInput[]
  }

  export type UserStoryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UserStoryCreateWithoutProjectInput, UserStoryUncheckedCreateWithoutProjectInput> | UserStoryCreateWithoutProjectInput[] | UserStoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutProjectInput | UserStoryCreateOrConnectWithoutProjectInput[]
    upsert?: UserStoryUpsertWithWhereUniqueWithoutProjectInput | UserStoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UserStoryCreateManyProjectInputEnvelope
    set?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    disconnect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    delete?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    update?: UserStoryUpdateWithWhereUniqueWithoutProjectInput | UserStoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UserStoryUpdateManyWithWhereWithoutProjectInput | UserStoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UserStoryScalarWhereInput | UserStoryScalarWhereInput[]
  }

  export type SprintUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    upsert?: SprintUpsertWithWhereUniqueWithoutProjectInput | SprintUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    set?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    disconnect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    delete?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    update?: SprintUpdateWithWhereUniqueWithoutProjectInput | SprintUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SprintUpdateManyWithWhereWithoutProjectInput | SprintUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SprintScalarWhereInput | SprintScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutProjectInput | MemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutProjectInput | MemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutProjectInput | MemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type FolderUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FolderCreateWithoutProjectInput, FolderUncheckedCreateWithoutProjectInput> | FolderCreateWithoutProjectInput[] | FolderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutProjectInput | FolderCreateOrConnectWithoutProjectInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutProjectInput | FolderUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FolderCreateManyProjectInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutProjectInput | FolderUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutProjectInput | FolderUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type FileUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FileCreateWithoutProjectInput, FileUncheckedCreateWithoutProjectInput> | FileCreateWithoutProjectInput[] | FileUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FileCreateOrConnectWithoutProjectInput | FileCreateOrConnectWithoutProjectInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutProjectInput | FileUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FileCreateManyProjectInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutProjectInput | FileUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FileUpdateManyWithWhereWithoutProjectInput | FileUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProjectInput | CommentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProjectInput | CommentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProjectInput | CommentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type MemberUpdateOneWithoutCreatedProjectsNestedInput = {
    create?: XOR<MemberCreateWithoutCreatedProjectsInput, MemberUncheckedCreateWithoutCreatedProjectsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCreatedProjectsInput
    upsert?: MemberUpsertWithoutCreatedProjectsInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutCreatedProjectsInput, MemberUpdateWithoutCreatedProjectsInput>, MemberUncheckedUpdateWithoutCreatedProjectsInput>
  }

  export type ThemaUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ThemaCreateWithoutProjectInput, ThemaUncheckedCreateWithoutProjectInput> | ThemaCreateWithoutProjectInput[] | ThemaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ThemaCreateOrConnectWithoutProjectInput | ThemaCreateOrConnectWithoutProjectInput[]
    upsert?: ThemaUpsertWithWhereUniqueWithoutProjectInput | ThemaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ThemaCreateManyProjectInputEnvelope
    set?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    disconnect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    delete?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    connect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    update?: ThemaUpdateWithWhereUniqueWithoutProjectInput | ThemaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ThemaUpdateManyWithWhereWithoutProjectInput | ThemaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ThemaScalarWhereInput | ThemaScalarWhereInput[]
  }

  export type EpicUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EpicCreateWithoutProjectInput, EpicUncheckedCreateWithoutProjectInput> | EpicCreateWithoutProjectInput[] | EpicUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EpicCreateOrConnectWithoutProjectInput | EpicCreateOrConnectWithoutProjectInput[]
    upsert?: EpicUpsertWithWhereUniqueWithoutProjectInput | EpicUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EpicCreateManyProjectInputEnvelope
    set?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    disconnect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    delete?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    connect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    update?: EpicUpdateWithWhereUniqueWithoutProjectInput | EpicUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EpicUpdateManyWithWhereWithoutProjectInput | EpicUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EpicScalarWhereInput | EpicScalarWhereInput[]
  }

  export type UserStoryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UserStoryCreateWithoutProjectInput, UserStoryUncheckedCreateWithoutProjectInput> | UserStoryCreateWithoutProjectInput[] | UserStoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutProjectInput | UserStoryCreateOrConnectWithoutProjectInput[]
    upsert?: UserStoryUpsertWithWhereUniqueWithoutProjectInput | UserStoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UserStoryCreateManyProjectInputEnvelope
    set?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    disconnect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    delete?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    update?: UserStoryUpdateWithWhereUniqueWithoutProjectInput | UserStoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UserStoryUpdateManyWithWhereWithoutProjectInput | UserStoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UserStoryScalarWhereInput | UserStoryScalarWhereInput[]
  }

  export type SprintUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    upsert?: SprintUpsertWithWhereUniqueWithoutProjectInput | SprintUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    set?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    disconnect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    delete?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    update?: SprintUpdateWithWhereUniqueWithoutProjectInput | SprintUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SprintUpdateManyWithWhereWithoutProjectInput | SprintUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SprintScalarWhereInput | SprintScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutProjectInput | MemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutProjectInput | MemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutProjectInput | MemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type FolderUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FolderCreateWithoutProjectInput, FolderUncheckedCreateWithoutProjectInput> | FolderCreateWithoutProjectInput[] | FolderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutProjectInput | FolderCreateOrConnectWithoutProjectInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutProjectInput | FolderUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FolderCreateManyProjectInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutProjectInput | FolderUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutProjectInput | FolderUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FileCreateWithoutProjectInput, FileUncheckedCreateWithoutProjectInput> | FileCreateWithoutProjectInput[] | FileUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FileCreateOrConnectWithoutProjectInput | FileCreateOrConnectWithoutProjectInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutProjectInput | FileUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FileCreateManyProjectInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutProjectInput | FileUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FileUpdateManyWithWhereWithoutProjectInput | FileUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput> | CommentCreateWithoutProjectInput[] | CommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProjectInput | CommentCreateOrConnectWithoutProjectInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProjectInput | CommentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CommentCreateManyProjectInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProjectInput | CommentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProjectInput | CommentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutUploaderInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[]
    createMany?: FileCreateManyUploaderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type SubtaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput> | SubtaskCreateWithoutAssigneeInput[] | SubtaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssigneeInput | SubtaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: SubtaskCreateManyAssigneeInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TimeLogCreateNestedManyWithoutMemberInput = {
    create?: XOR<TimeLogCreateWithoutMemberInput, TimeLogUncheckedCreateWithoutMemberInput> | TimeLogCreateWithoutMemberInput[] | TimeLogUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutMemberInput | TimeLogCreateOrConnectWithoutMemberInput[]
    createMany?: TimeLogCreateManyMemberInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type UserStoryCreateNestedManyWithoutCreatorInput = {
    create?: XOR<UserStoryCreateWithoutCreatorInput, UserStoryUncheckedCreateWithoutCreatorInput> | UserStoryCreateWithoutCreatorInput[] | UserStoryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutCreatorInput | UserStoryCreateOrConnectWithoutCreatorInput[]
    createMany?: UserStoryCreateManyCreatorInputEnvelope
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
  }

  export type ThemaCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ThemaCreateWithoutCreatorInput, ThemaUncheckedCreateWithoutCreatorInput> | ThemaCreateWithoutCreatorInput[] | ThemaUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemaCreateOrConnectWithoutCreatorInput | ThemaCreateOrConnectWithoutCreatorInput[]
    createMany?: ThemaCreateManyCreatorInputEnvelope
    connect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
  }

  export type EpicCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EpicCreateWithoutCreatorInput, EpicUncheckedCreateWithoutCreatorInput> | EpicCreateWithoutCreatorInput[] | EpicUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EpicCreateOrConnectWithoutCreatorInput | EpicCreateOrConnectWithoutCreatorInput[]
    createMany?: EpicCreateManyCreatorInputEnvelope
    connect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
  }

  export type SprintCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SprintCreateWithoutCreatorInput, SprintUncheckedCreateWithoutCreatorInput> | SprintCreateWithoutCreatorInput[] | SprintUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutCreatorInput | SprintCreateOrConnectWithoutCreatorInput[]
    createMany?: SprintCreateManyCreatorInputEnvelope
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutMemberInput = {
    create?: XOR<ActivityLogCreateWithoutMemberInput, ActivityLogUncheckedCreateWithoutMemberInput> | ActivityLogCreateWithoutMemberInput[] | ActivityLogUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutMemberInput | ActivityLogCreateOrConnectWithoutMemberInput[]
    createMany?: ActivityLogCreateManyMemberInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[]
    createMany?: FileCreateManyUploaderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type SubtaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput> | SubtaskCreateWithoutAssigneeInput[] | SubtaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssigneeInput | SubtaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: SubtaskCreateManyAssigneeInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TimeLogUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<TimeLogCreateWithoutMemberInput, TimeLogUncheckedCreateWithoutMemberInput> | TimeLogCreateWithoutMemberInput[] | TimeLogUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutMemberInput | TimeLogCreateOrConnectWithoutMemberInput[]
    createMany?: TimeLogCreateManyMemberInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type UserStoryUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<UserStoryCreateWithoutCreatorInput, UserStoryUncheckedCreateWithoutCreatorInput> | UserStoryCreateWithoutCreatorInput[] | UserStoryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutCreatorInput | UserStoryCreateOrConnectWithoutCreatorInput[]
    createMany?: UserStoryCreateManyCreatorInputEnvelope
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
  }

  export type ThemaUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ThemaCreateWithoutCreatorInput, ThemaUncheckedCreateWithoutCreatorInput> | ThemaCreateWithoutCreatorInput[] | ThemaUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemaCreateOrConnectWithoutCreatorInput | ThemaCreateOrConnectWithoutCreatorInput[]
    createMany?: ThemaCreateManyCreatorInputEnvelope
    connect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
  }

  export type EpicUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EpicCreateWithoutCreatorInput, EpicUncheckedCreateWithoutCreatorInput> | EpicCreateWithoutCreatorInput[] | EpicUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EpicCreateOrConnectWithoutCreatorInput | EpicCreateOrConnectWithoutCreatorInput[]
    createMany?: EpicCreateManyCreatorInputEnvelope
    connect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
  }

  export type SprintUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SprintCreateWithoutCreatorInput, SprintUncheckedCreateWithoutCreatorInput> | SprintCreateWithoutCreatorInput[] | SprintUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutCreatorInput | SprintCreateOrConnectWithoutCreatorInput[]
    createMany?: SprintCreateManyCreatorInputEnvelope
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<ActivityLogCreateWithoutMemberInput, ActivityLogUncheckedCreateWithoutMemberInput> | ActivityLogCreateWithoutMemberInput[] | ActivityLogUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutMemberInput | ActivityLogCreateOrConnectWithoutMemberInput[]
    createMany?: ActivityLogCreateManyMemberInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type FileUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUploaderInput | FileUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: FileCreateManyUploaderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUploaderInput | FileUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUploaderInput | FileUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type SubtaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput> | SubtaskCreateWithoutAssigneeInput[] | SubtaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssigneeInput | SubtaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutAssigneeInput | SubtaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: SubtaskCreateManyAssigneeInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutAssigneeInput | SubtaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutAssigneeInput | SubtaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TimeLogUpdateManyWithoutMemberNestedInput = {
    create?: XOR<TimeLogCreateWithoutMemberInput, TimeLogUncheckedCreateWithoutMemberInput> | TimeLogCreateWithoutMemberInput[] | TimeLogUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutMemberInput | TimeLogCreateOrConnectWithoutMemberInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutMemberInput | TimeLogUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: TimeLogCreateManyMemberInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutMemberInput | TimeLogUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutMemberInput | TimeLogUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type UserStoryUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<UserStoryCreateWithoutCreatorInput, UserStoryUncheckedCreateWithoutCreatorInput> | UserStoryCreateWithoutCreatorInput[] | UserStoryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutCreatorInput | UserStoryCreateOrConnectWithoutCreatorInput[]
    upsert?: UserStoryUpsertWithWhereUniqueWithoutCreatorInput | UserStoryUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: UserStoryCreateManyCreatorInputEnvelope
    set?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    disconnect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    delete?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    update?: UserStoryUpdateWithWhereUniqueWithoutCreatorInput | UserStoryUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: UserStoryUpdateManyWithWhereWithoutCreatorInput | UserStoryUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: UserStoryScalarWhereInput | UserStoryScalarWhereInput[]
  }

  export type ThemaUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ThemaCreateWithoutCreatorInput, ThemaUncheckedCreateWithoutCreatorInput> | ThemaCreateWithoutCreatorInput[] | ThemaUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemaCreateOrConnectWithoutCreatorInput | ThemaCreateOrConnectWithoutCreatorInput[]
    upsert?: ThemaUpsertWithWhereUniqueWithoutCreatorInput | ThemaUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ThemaCreateManyCreatorInputEnvelope
    set?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    disconnect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    delete?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    connect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    update?: ThemaUpdateWithWhereUniqueWithoutCreatorInput | ThemaUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ThemaUpdateManyWithWhereWithoutCreatorInput | ThemaUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ThemaScalarWhereInput | ThemaScalarWhereInput[]
  }

  export type EpicUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EpicCreateWithoutCreatorInput, EpicUncheckedCreateWithoutCreatorInput> | EpicCreateWithoutCreatorInput[] | EpicUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EpicCreateOrConnectWithoutCreatorInput | EpicCreateOrConnectWithoutCreatorInput[]
    upsert?: EpicUpsertWithWhereUniqueWithoutCreatorInput | EpicUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EpicCreateManyCreatorInputEnvelope
    set?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    disconnect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    delete?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    connect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    update?: EpicUpdateWithWhereUniqueWithoutCreatorInput | EpicUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EpicUpdateManyWithWhereWithoutCreatorInput | EpicUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EpicScalarWhereInput | EpicScalarWhereInput[]
  }

  export type SprintUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SprintCreateWithoutCreatorInput, SprintUncheckedCreateWithoutCreatorInput> | SprintCreateWithoutCreatorInput[] | SprintUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutCreatorInput | SprintCreateOrConnectWithoutCreatorInput[]
    upsert?: SprintUpsertWithWhereUniqueWithoutCreatorInput | SprintUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SprintCreateManyCreatorInputEnvelope
    set?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    disconnect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    delete?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    update?: SprintUpdateWithWhereUniqueWithoutCreatorInput | SprintUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SprintUpdateManyWithWhereWithoutCreatorInput | SprintUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SprintScalarWhereInput | SprintScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ActivityLogCreateWithoutMemberInput, ActivityLogUncheckedCreateWithoutMemberInput> | ActivityLogCreateWithoutMemberInput[] | ActivityLogUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutMemberInput | ActivityLogCreateOrConnectWithoutMemberInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutMemberInput | ActivityLogUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ActivityLogCreateManyMemberInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutMemberInput | ActivityLogUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutMemberInput | ActivityLogUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatorInput | ProjectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatorInput | ProjectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatorInput | ProjectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUploaderInput | FileUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: FileCreateManyUploaderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUploaderInput | FileUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUploaderInput | FileUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput> | SubtaskCreateWithoutAssigneeInput[] | SubtaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssigneeInput | SubtaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutAssigneeInput | SubtaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: SubtaskCreateManyAssigneeInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutAssigneeInput | SubtaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutAssigneeInput | SubtaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TimeLogUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<TimeLogCreateWithoutMemberInput, TimeLogUncheckedCreateWithoutMemberInput> | TimeLogCreateWithoutMemberInput[] | TimeLogUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutMemberInput | TimeLogCreateOrConnectWithoutMemberInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutMemberInput | TimeLogUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: TimeLogCreateManyMemberInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutMemberInput | TimeLogUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutMemberInput | TimeLogUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type UserStoryUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<UserStoryCreateWithoutCreatorInput, UserStoryUncheckedCreateWithoutCreatorInput> | UserStoryCreateWithoutCreatorInput[] | UserStoryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutCreatorInput | UserStoryCreateOrConnectWithoutCreatorInput[]
    upsert?: UserStoryUpsertWithWhereUniqueWithoutCreatorInput | UserStoryUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: UserStoryCreateManyCreatorInputEnvelope
    set?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    disconnect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    delete?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    update?: UserStoryUpdateWithWhereUniqueWithoutCreatorInput | UserStoryUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: UserStoryUpdateManyWithWhereWithoutCreatorInput | UserStoryUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: UserStoryScalarWhereInput | UserStoryScalarWhereInput[]
  }

  export type ThemaUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ThemaCreateWithoutCreatorInput, ThemaUncheckedCreateWithoutCreatorInput> | ThemaCreateWithoutCreatorInput[] | ThemaUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemaCreateOrConnectWithoutCreatorInput | ThemaCreateOrConnectWithoutCreatorInput[]
    upsert?: ThemaUpsertWithWhereUniqueWithoutCreatorInput | ThemaUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ThemaCreateManyCreatorInputEnvelope
    set?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    disconnect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    delete?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    connect?: ThemaWhereUniqueInput | ThemaWhereUniqueInput[]
    update?: ThemaUpdateWithWhereUniqueWithoutCreatorInput | ThemaUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ThemaUpdateManyWithWhereWithoutCreatorInput | ThemaUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ThemaScalarWhereInput | ThemaScalarWhereInput[]
  }

  export type EpicUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EpicCreateWithoutCreatorInput, EpicUncheckedCreateWithoutCreatorInput> | EpicCreateWithoutCreatorInput[] | EpicUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EpicCreateOrConnectWithoutCreatorInput | EpicCreateOrConnectWithoutCreatorInput[]
    upsert?: EpicUpsertWithWhereUniqueWithoutCreatorInput | EpicUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EpicCreateManyCreatorInputEnvelope
    set?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    disconnect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    delete?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    connect?: EpicWhereUniqueInput | EpicWhereUniqueInput[]
    update?: EpicUpdateWithWhereUniqueWithoutCreatorInput | EpicUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EpicUpdateManyWithWhereWithoutCreatorInput | EpicUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EpicScalarWhereInput | EpicScalarWhereInput[]
  }

  export type SprintUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SprintCreateWithoutCreatorInput, SprintUncheckedCreateWithoutCreatorInput> | SprintCreateWithoutCreatorInput[] | SprintUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutCreatorInput | SprintCreateOrConnectWithoutCreatorInput[]
    upsert?: SprintUpsertWithWhereUniqueWithoutCreatorInput | SprintUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SprintCreateManyCreatorInputEnvelope
    set?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    disconnect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    delete?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    update?: SprintUpdateWithWhereUniqueWithoutCreatorInput | SprintUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SprintUpdateManyWithWhereWithoutCreatorInput | SprintUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SprintScalarWhereInput | SprintScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ActivityLogCreateWithoutMemberInput, ActivityLogUncheckedCreateWithoutMemberInput> | ActivityLogCreateWithoutMemberInput[] | ActivityLogUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutMemberInput | ActivityLogCreateOrConnectWithoutMemberInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutMemberInput | ActivityLogUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ActivityLogCreateManyMemberInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutMemberInput | ActivityLogUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutMemberInput | ActivityLogUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatorInput | ProjectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatorInput | ProjectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatorInput | ProjectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutThemasInput = {
    create?: XOR<ProjectCreateWithoutThemasInput, ProjectUncheckedCreateWithoutThemasInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutThemasInput
    connect?: ProjectWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutThemasInput = {
    create?: XOR<MemberCreateWithoutThemasInput, MemberUncheckedCreateWithoutThemasInput>
    connectOrCreate?: MemberCreateOrConnectWithoutThemasInput
    connect?: MemberWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutThemaInput = {
    create?: XOR<TaskCreateWithoutThemaInput, TaskUncheckedCreateWithoutThemaInput> | TaskCreateWithoutThemaInput[] | TaskUncheckedCreateWithoutThemaInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutThemaInput | TaskCreateOrConnectWithoutThemaInput[]
    createMany?: TaskCreateManyThemaInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutThemaInput = {
    create?: XOR<CommentCreateWithoutThemaInput, CommentUncheckedCreateWithoutThemaInput> | CommentCreateWithoutThemaInput[] | CommentUncheckedCreateWithoutThemaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutThemaInput | CommentCreateOrConnectWithoutThemaInput[]
    createMany?: CommentCreateManyThemaInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutThemaInput = {
    create?: XOR<TaskCreateWithoutThemaInput, TaskUncheckedCreateWithoutThemaInput> | TaskCreateWithoutThemaInput[] | TaskUncheckedCreateWithoutThemaInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutThemaInput | TaskCreateOrConnectWithoutThemaInput[]
    createMany?: TaskCreateManyThemaInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutThemaInput = {
    create?: XOR<CommentCreateWithoutThemaInput, CommentUncheckedCreateWithoutThemaInput> | CommentCreateWithoutThemaInput[] | CommentUncheckedCreateWithoutThemaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutThemaInput | CommentCreateOrConnectWithoutThemaInput[]
    createMany?: CommentCreateManyThemaInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutThemasNestedInput = {
    create?: XOR<ProjectCreateWithoutThemasInput, ProjectUncheckedCreateWithoutThemasInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutThemasInput
    upsert?: ProjectUpsertWithoutThemasInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutThemasInput, ProjectUpdateWithoutThemasInput>, ProjectUncheckedUpdateWithoutThemasInput>
  }

  export type MemberUpdateOneRequiredWithoutThemasNestedInput = {
    create?: XOR<MemberCreateWithoutThemasInput, MemberUncheckedCreateWithoutThemasInput>
    connectOrCreate?: MemberCreateOrConnectWithoutThemasInput
    upsert?: MemberUpsertWithoutThemasInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutThemasInput, MemberUpdateWithoutThemasInput>, MemberUncheckedUpdateWithoutThemasInput>
  }

  export type TaskUpdateManyWithoutThemaNestedInput = {
    create?: XOR<TaskCreateWithoutThemaInput, TaskUncheckedCreateWithoutThemaInput> | TaskCreateWithoutThemaInput[] | TaskUncheckedCreateWithoutThemaInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutThemaInput | TaskCreateOrConnectWithoutThemaInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutThemaInput | TaskUpsertWithWhereUniqueWithoutThemaInput[]
    createMany?: TaskCreateManyThemaInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutThemaInput | TaskUpdateWithWhereUniqueWithoutThemaInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutThemaInput | TaskUpdateManyWithWhereWithoutThemaInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutThemaNestedInput = {
    create?: XOR<CommentCreateWithoutThemaInput, CommentUncheckedCreateWithoutThemaInput> | CommentCreateWithoutThemaInput[] | CommentUncheckedCreateWithoutThemaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutThemaInput | CommentCreateOrConnectWithoutThemaInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutThemaInput | CommentUpsertWithWhereUniqueWithoutThemaInput[]
    createMany?: CommentCreateManyThemaInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutThemaInput | CommentUpdateWithWhereUniqueWithoutThemaInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutThemaInput | CommentUpdateManyWithWhereWithoutThemaInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutThemaNestedInput = {
    create?: XOR<TaskCreateWithoutThemaInput, TaskUncheckedCreateWithoutThemaInput> | TaskCreateWithoutThemaInput[] | TaskUncheckedCreateWithoutThemaInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutThemaInput | TaskCreateOrConnectWithoutThemaInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutThemaInput | TaskUpsertWithWhereUniqueWithoutThemaInput[]
    createMany?: TaskCreateManyThemaInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutThemaInput | TaskUpdateWithWhereUniqueWithoutThemaInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutThemaInput | TaskUpdateManyWithWhereWithoutThemaInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutThemaNestedInput = {
    create?: XOR<CommentCreateWithoutThemaInput, CommentUncheckedCreateWithoutThemaInput> | CommentCreateWithoutThemaInput[] | CommentUncheckedCreateWithoutThemaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutThemaInput | CommentCreateOrConnectWithoutThemaInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutThemaInput | CommentUpsertWithWhereUniqueWithoutThemaInput[]
    createMany?: CommentCreateManyThemaInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutThemaInput | CommentUpdateWithWhereUniqueWithoutThemaInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutThemaInput | CommentUpdateManyWithWhereWithoutThemaInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutEpicsInput = {
    create?: XOR<ProjectCreateWithoutEpicsInput, ProjectUncheckedCreateWithoutEpicsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEpicsInput
    connect?: ProjectWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutEpicsInput = {
    create?: XOR<MemberCreateWithoutEpicsInput, MemberUncheckedCreateWithoutEpicsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutEpicsInput
    connect?: MemberWhereUniqueInput
  }

  export type UserStoryCreateNestedManyWithoutEpicInput = {
    create?: XOR<UserStoryCreateWithoutEpicInput, UserStoryUncheckedCreateWithoutEpicInput> | UserStoryCreateWithoutEpicInput[] | UserStoryUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutEpicInput | UserStoryCreateOrConnectWithoutEpicInput[]
    createMany?: UserStoryCreateManyEpicInputEnvelope
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutEpicInput = {
    create?: XOR<CommentCreateWithoutEpicInput, CommentUncheckedCreateWithoutEpicInput> | CommentCreateWithoutEpicInput[] | CommentUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEpicInput | CommentCreateOrConnectWithoutEpicInput[]
    createMany?: CommentCreateManyEpicInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type UserStoryUncheckedCreateNestedManyWithoutEpicInput = {
    create?: XOR<UserStoryCreateWithoutEpicInput, UserStoryUncheckedCreateWithoutEpicInput> | UserStoryCreateWithoutEpicInput[] | UserStoryUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutEpicInput | UserStoryCreateOrConnectWithoutEpicInput[]
    createMany?: UserStoryCreateManyEpicInputEnvelope
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutEpicInput = {
    create?: XOR<CommentCreateWithoutEpicInput, CommentUncheckedCreateWithoutEpicInput> | CommentCreateWithoutEpicInput[] | CommentUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEpicInput | CommentCreateOrConnectWithoutEpicInput[]
    createMany?: CommentCreateManyEpicInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutEpicsNestedInput = {
    create?: XOR<ProjectCreateWithoutEpicsInput, ProjectUncheckedCreateWithoutEpicsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEpicsInput
    upsert?: ProjectUpsertWithoutEpicsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutEpicsInput, ProjectUpdateWithoutEpicsInput>, ProjectUncheckedUpdateWithoutEpicsInput>
  }

  export type MemberUpdateOneRequiredWithoutEpicsNestedInput = {
    create?: XOR<MemberCreateWithoutEpicsInput, MemberUncheckedCreateWithoutEpicsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutEpicsInput
    upsert?: MemberUpsertWithoutEpicsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutEpicsInput, MemberUpdateWithoutEpicsInput>, MemberUncheckedUpdateWithoutEpicsInput>
  }

  export type UserStoryUpdateManyWithoutEpicNestedInput = {
    create?: XOR<UserStoryCreateWithoutEpicInput, UserStoryUncheckedCreateWithoutEpicInput> | UserStoryCreateWithoutEpicInput[] | UserStoryUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutEpicInput | UserStoryCreateOrConnectWithoutEpicInput[]
    upsert?: UserStoryUpsertWithWhereUniqueWithoutEpicInput | UserStoryUpsertWithWhereUniqueWithoutEpicInput[]
    createMany?: UserStoryCreateManyEpicInputEnvelope
    set?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    disconnect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    delete?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    update?: UserStoryUpdateWithWhereUniqueWithoutEpicInput | UserStoryUpdateWithWhereUniqueWithoutEpicInput[]
    updateMany?: UserStoryUpdateManyWithWhereWithoutEpicInput | UserStoryUpdateManyWithWhereWithoutEpicInput[]
    deleteMany?: UserStoryScalarWhereInput | UserStoryScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutEpicNestedInput = {
    create?: XOR<CommentCreateWithoutEpicInput, CommentUncheckedCreateWithoutEpicInput> | CommentCreateWithoutEpicInput[] | CommentUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEpicInput | CommentCreateOrConnectWithoutEpicInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutEpicInput | CommentUpsertWithWhereUniqueWithoutEpicInput[]
    createMany?: CommentCreateManyEpicInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutEpicInput | CommentUpdateWithWhereUniqueWithoutEpicInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutEpicInput | CommentUpdateManyWithWhereWithoutEpicInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserStoryUncheckedUpdateManyWithoutEpicNestedInput = {
    create?: XOR<UserStoryCreateWithoutEpicInput, UserStoryUncheckedCreateWithoutEpicInput> | UserStoryCreateWithoutEpicInput[] | UserStoryUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutEpicInput | UserStoryCreateOrConnectWithoutEpicInput[]
    upsert?: UserStoryUpsertWithWhereUniqueWithoutEpicInput | UserStoryUpsertWithWhereUniqueWithoutEpicInput[]
    createMany?: UserStoryCreateManyEpicInputEnvelope
    set?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    disconnect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    delete?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    update?: UserStoryUpdateWithWhereUniqueWithoutEpicInput | UserStoryUpdateWithWhereUniqueWithoutEpicInput[]
    updateMany?: UserStoryUpdateManyWithWhereWithoutEpicInput | UserStoryUpdateManyWithWhereWithoutEpicInput[]
    deleteMany?: UserStoryScalarWhereInput | UserStoryScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutEpicNestedInput = {
    create?: XOR<CommentCreateWithoutEpicInput, CommentUncheckedCreateWithoutEpicInput> | CommentCreateWithoutEpicInput[] | CommentUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutEpicInput | CommentCreateOrConnectWithoutEpicInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutEpicInput | CommentUpsertWithWhereUniqueWithoutEpicInput[]
    createMany?: CommentCreateManyEpicInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutEpicInput | CommentUpdateWithWhereUniqueWithoutEpicInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutEpicInput | CommentUpdateManyWithWhereWithoutEpicInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutUserStoriesInput = {
    create?: XOR<ProjectCreateWithoutUserStoriesInput, ProjectUncheckedCreateWithoutUserStoriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUserStoriesInput
    connect?: ProjectWhereUniqueInput
  }

  export type EpicCreateNestedOneWithoutUserStoriesInput = {
    create?: XOR<EpicCreateWithoutUserStoriesInput, EpicUncheckedCreateWithoutUserStoriesInput>
    connectOrCreate?: EpicCreateOrConnectWithoutUserStoriesInput
    connect?: EpicWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutUserStoriesInput = {
    create?: XOR<MemberCreateWithoutUserStoriesInput, MemberUncheckedCreateWithoutUserStoriesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutUserStoriesInput
    connect?: MemberWhereUniqueInput
  }

  export type SprintCreateNestedOneWithoutUserStoriesInput = {
    create?: XOR<SprintCreateWithoutUserStoriesInput, SprintUncheckedCreateWithoutUserStoriesInput>
    connectOrCreate?: SprintCreateOrConnectWithoutUserStoriesInput
    connect?: SprintWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutUserStoryInput = {
    create?: XOR<TaskCreateWithoutUserStoryInput, TaskUncheckedCreateWithoutUserStoryInput> | TaskCreateWithoutUserStoryInput[] | TaskUncheckedCreateWithoutUserStoryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserStoryInput | TaskCreateOrConnectWithoutUserStoryInput[]
    createMany?: TaskCreateManyUserStoryInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserStoryInput = {
    create?: XOR<CommentCreateWithoutUserStoryInput, CommentUncheckedCreateWithoutUserStoryInput> | CommentCreateWithoutUserStoryInput[] | CommentUncheckedCreateWithoutUserStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserStoryInput | CommentCreateOrConnectWithoutUserStoryInput[]
    createMany?: CommentCreateManyUserStoryInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutUserStoryInput = {
    create?: XOR<TaskCreateWithoutUserStoryInput, TaskUncheckedCreateWithoutUserStoryInput> | TaskCreateWithoutUserStoryInput[] | TaskUncheckedCreateWithoutUserStoryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserStoryInput | TaskCreateOrConnectWithoutUserStoryInput[]
    createMany?: TaskCreateManyUserStoryInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserStoryInput = {
    create?: XOR<CommentCreateWithoutUserStoryInput, CommentUncheckedCreateWithoutUserStoryInput> | CommentCreateWithoutUserStoryInput[] | CommentUncheckedCreateWithoutUserStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserStoryInput | CommentCreateOrConnectWithoutUserStoryInput[]
    createMany?: CommentCreateManyUserStoryInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutUserStoriesNestedInput = {
    create?: XOR<ProjectCreateWithoutUserStoriesInput, ProjectUncheckedCreateWithoutUserStoriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUserStoriesInput
    upsert?: ProjectUpsertWithoutUserStoriesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutUserStoriesInput, ProjectUpdateWithoutUserStoriesInput>, ProjectUncheckedUpdateWithoutUserStoriesInput>
  }

  export type EpicUpdateOneWithoutUserStoriesNestedInput = {
    create?: XOR<EpicCreateWithoutUserStoriesInput, EpicUncheckedCreateWithoutUserStoriesInput>
    connectOrCreate?: EpicCreateOrConnectWithoutUserStoriesInput
    upsert?: EpicUpsertWithoutUserStoriesInput
    disconnect?: EpicWhereInput | boolean
    delete?: EpicWhereInput | boolean
    connect?: EpicWhereUniqueInput
    update?: XOR<XOR<EpicUpdateToOneWithWhereWithoutUserStoriesInput, EpicUpdateWithoutUserStoriesInput>, EpicUncheckedUpdateWithoutUserStoriesInput>
  }

  export type MemberUpdateOneRequiredWithoutUserStoriesNestedInput = {
    create?: XOR<MemberCreateWithoutUserStoriesInput, MemberUncheckedCreateWithoutUserStoriesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutUserStoriesInput
    upsert?: MemberUpsertWithoutUserStoriesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutUserStoriesInput, MemberUpdateWithoutUserStoriesInput>, MemberUncheckedUpdateWithoutUserStoriesInput>
  }

  export type SprintUpdateOneWithoutUserStoriesNestedInput = {
    create?: XOR<SprintCreateWithoutUserStoriesInput, SprintUncheckedCreateWithoutUserStoriesInput>
    connectOrCreate?: SprintCreateOrConnectWithoutUserStoriesInput
    upsert?: SprintUpsertWithoutUserStoriesInput
    disconnect?: SprintWhereInput | boolean
    delete?: SprintWhereInput | boolean
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutUserStoriesInput, SprintUpdateWithoutUserStoriesInput>, SprintUncheckedUpdateWithoutUserStoriesInput>
  }

  export type TaskUpdateManyWithoutUserStoryNestedInput = {
    create?: XOR<TaskCreateWithoutUserStoryInput, TaskUncheckedCreateWithoutUserStoryInput> | TaskCreateWithoutUserStoryInput[] | TaskUncheckedCreateWithoutUserStoryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserStoryInput | TaskCreateOrConnectWithoutUserStoryInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserStoryInput | TaskUpsertWithWhereUniqueWithoutUserStoryInput[]
    createMany?: TaskCreateManyUserStoryInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserStoryInput | TaskUpdateWithWhereUniqueWithoutUserStoryInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserStoryInput | TaskUpdateManyWithWhereWithoutUserStoryInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserStoryNestedInput = {
    create?: XOR<CommentCreateWithoutUserStoryInput, CommentUncheckedCreateWithoutUserStoryInput> | CommentCreateWithoutUserStoryInput[] | CommentUncheckedCreateWithoutUserStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserStoryInput | CommentCreateOrConnectWithoutUserStoryInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserStoryInput | CommentUpsertWithWhereUniqueWithoutUserStoryInput[]
    createMany?: CommentCreateManyUserStoryInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserStoryInput | CommentUpdateWithWhereUniqueWithoutUserStoryInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserStoryInput | CommentUpdateManyWithWhereWithoutUserStoryInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutUserStoryNestedInput = {
    create?: XOR<TaskCreateWithoutUserStoryInput, TaskUncheckedCreateWithoutUserStoryInput> | TaskCreateWithoutUserStoryInput[] | TaskUncheckedCreateWithoutUserStoryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserStoryInput | TaskCreateOrConnectWithoutUserStoryInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserStoryInput | TaskUpsertWithWhereUniqueWithoutUserStoryInput[]
    createMany?: TaskCreateManyUserStoryInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserStoryInput | TaskUpdateWithWhereUniqueWithoutUserStoryInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserStoryInput | TaskUpdateManyWithWhereWithoutUserStoryInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserStoryNestedInput = {
    create?: XOR<CommentCreateWithoutUserStoryInput, CommentUncheckedCreateWithoutUserStoryInput> | CommentCreateWithoutUserStoryInput[] | CommentUncheckedCreateWithoutUserStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserStoryInput | CommentCreateOrConnectWithoutUserStoryInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserStoryInput | CommentUpsertWithWhereUniqueWithoutUserStoryInput[]
    createMany?: CommentCreateManyUserStoryInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserStoryInput | CommentUpdateWithWhereUniqueWithoutUserStoryInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserStoryInput | CommentUpdateManyWithWhereWithoutUserStoryInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutSprintsInput = {
    create?: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSprintsInput
    connect?: ProjectWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutSprintsInput = {
    create?: XOR<MemberCreateWithoutSprintsInput, MemberUncheckedCreateWithoutSprintsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSprintsInput
    connect?: MemberWhereUniqueInput
  }

  export type UserStoryCreateNestedManyWithoutSprintInput = {
    create?: XOR<UserStoryCreateWithoutSprintInput, UserStoryUncheckedCreateWithoutSprintInput> | UserStoryCreateWithoutSprintInput[] | UserStoryUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutSprintInput | UserStoryCreateOrConnectWithoutSprintInput[]
    createMany?: UserStoryCreateManySprintInputEnvelope
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutSprintInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type SubtaskCreateNestedManyWithoutSprintInput = {
    create?: XOR<SubtaskCreateWithoutSprintInput, SubtaskUncheckedCreateWithoutSprintInput> | SubtaskCreateWithoutSprintInput[] | SubtaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutSprintInput | SubtaskCreateOrConnectWithoutSprintInput[]
    createMany?: SubtaskCreateManySprintInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutSprintInput = {
    create?: XOR<FileCreateWithoutSprintInput, FileUncheckedCreateWithoutSprintInput> | FileCreateWithoutSprintInput[] | FileUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSprintInput | FileCreateOrConnectWithoutSprintInput[]
    createMany?: FileCreateManySprintInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type UserStoryUncheckedCreateNestedManyWithoutSprintInput = {
    create?: XOR<UserStoryCreateWithoutSprintInput, UserStoryUncheckedCreateWithoutSprintInput> | UserStoryCreateWithoutSprintInput[] | UserStoryUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutSprintInput | UserStoryCreateOrConnectWithoutSprintInput[]
    createMany?: UserStoryCreateManySprintInputEnvelope
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutSprintInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type SubtaskUncheckedCreateNestedManyWithoutSprintInput = {
    create?: XOR<SubtaskCreateWithoutSprintInput, SubtaskUncheckedCreateWithoutSprintInput> | SubtaskCreateWithoutSprintInput[] | SubtaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutSprintInput | SubtaskCreateOrConnectWithoutSprintInput[]
    createMany?: SubtaskCreateManySprintInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutSprintInput = {
    create?: XOR<FileCreateWithoutSprintInput, FileUncheckedCreateWithoutSprintInput> | FileCreateWithoutSprintInput[] | FileUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSprintInput | FileCreateOrConnectWithoutSprintInput[]
    createMany?: FileCreateManySprintInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutSprintsNestedInput = {
    create?: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSprintsInput
    upsert?: ProjectUpsertWithoutSprintsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSprintsInput, ProjectUpdateWithoutSprintsInput>, ProjectUncheckedUpdateWithoutSprintsInput>
  }

  export type MemberUpdateOneRequiredWithoutSprintsNestedInput = {
    create?: XOR<MemberCreateWithoutSprintsInput, MemberUncheckedCreateWithoutSprintsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSprintsInput
    upsert?: MemberUpsertWithoutSprintsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutSprintsInput, MemberUpdateWithoutSprintsInput>, MemberUncheckedUpdateWithoutSprintsInput>
  }

  export type UserStoryUpdateManyWithoutSprintNestedInput = {
    create?: XOR<UserStoryCreateWithoutSprintInput, UserStoryUncheckedCreateWithoutSprintInput> | UserStoryCreateWithoutSprintInput[] | UserStoryUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutSprintInput | UserStoryCreateOrConnectWithoutSprintInput[]
    upsert?: UserStoryUpsertWithWhereUniqueWithoutSprintInput | UserStoryUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: UserStoryCreateManySprintInputEnvelope
    set?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    disconnect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    delete?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    update?: UserStoryUpdateWithWhereUniqueWithoutSprintInput | UserStoryUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: UserStoryUpdateManyWithWhereWithoutSprintInput | UserStoryUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: UserStoryScalarWhereInput | UserStoryScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutSprintNestedInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutSprintInput | TaskUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutSprintInput | TaskUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutSprintInput | TaskUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type SubtaskUpdateManyWithoutSprintNestedInput = {
    create?: XOR<SubtaskCreateWithoutSprintInput, SubtaskUncheckedCreateWithoutSprintInput> | SubtaskCreateWithoutSprintInput[] | SubtaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutSprintInput | SubtaskCreateOrConnectWithoutSprintInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutSprintInput | SubtaskUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: SubtaskCreateManySprintInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutSprintInput | SubtaskUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutSprintInput | SubtaskUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type FileUpdateManyWithoutSprintNestedInput = {
    create?: XOR<FileCreateWithoutSprintInput, FileUncheckedCreateWithoutSprintInput> | FileCreateWithoutSprintInput[] | FileUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSprintInput | FileCreateOrConnectWithoutSprintInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutSprintInput | FileUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: FileCreateManySprintInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutSprintInput | FileUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: FileUpdateManyWithWhereWithoutSprintInput | FileUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UserStoryUncheckedUpdateManyWithoutSprintNestedInput = {
    create?: XOR<UserStoryCreateWithoutSprintInput, UserStoryUncheckedCreateWithoutSprintInput> | UserStoryCreateWithoutSprintInput[] | UserStoryUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: UserStoryCreateOrConnectWithoutSprintInput | UserStoryCreateOrConnectWithoutSprintInput[]
    upsert?: UserStoryUpsertWithWhereUniqueWithoutSprintInput | UserStoryUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: UserStoryCreateManySprintInputEnvelope
    set?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    disconnect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    delete?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    connect?: UserStoryWhereUniqueInput | UserStoryWhereUniqueInput[]
    update?: UserStoryUpdateWithWhereUniqueWithoutSprintInput | UserStoryUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: UserStoryUpdateManyWithWhereWithoutSprintInput | UserStoryUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: UserStoryScalarWhereInput | UserStoryScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutSprintNestedInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutSprintInput | TaskUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutSprintInput | TaskUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutSprintInput | TaskUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type SubtaskUncheckedUpdateManyWithoutSprintNestedInput = {
    create?: XOR<SubtaskCreateWithoutSprintInput, SubtaskUncheckedCreateWithoutSprintInput> | SubtaskCreateWithoutSprintInput[] | SubtaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutSprintInput | SubtaskCreateOrConnectWithoutSprintInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutSprintInput | SubtaskUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: SubtaskCreateManySprintInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutSprintInput | SubtaskUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutSprintInput | SubtaskUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutSprintNestedInput = {
    create?: XOR<FileCreateWithoutSprintInput, FileUncheckedCreateWithoutSprintInput> | FileCreateWithoutSprintInput[] | FileUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSprintInput | FileCreateOrConnectWithoutSprintInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutSprintInput | FileUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: FileCreateManySprintInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutSprintInput | FileUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: FileUpdateManyWithWhereWithoutSprintInput | FileUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ThemaCreateNestedOneWithoutTasksInput = {
    create?: XOR<ThemaCreateWithoutTasksInput, ThemaUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ThemaCreateOrConnectWithoutTasksInput
    connect?: ThemaWhereUniqueInput
  }

  export type UserStoryCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserStoryCreateWithoutTasksInput, UserStoryUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserStoryCreateOrConnectWithoutTasksInput
    connect?: UserStoryWhereUniqueInput
  }

  export type SprintCreateNestedOneWithoutTasksInput = {
    create?: XOR<SprintCreateWithoutTasksInput, SprintUncheckedCreateWithoutTasksInput>
    connectOrCreate?: SprintCreateOrConnectWithoutTasksInput
    connect?: SprintWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutTasksInput = {
    create?: XOR<MemberCreateWithoutTasksInput, MemberUncheckedCreateWithoutTasksInput>
    connectOrCreate?: MemberCreateOrConnectWithoutTasksInput
    connect?: MemberWhereUniqueInput
  }

  export type SubtaskCreateNestedManyWithoutTaskInput = {
    create?: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput> | SubtaskCreateWithoutTaskInput[] | SubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTaskInput | SubtaskCreateOrConnectWithoutTaskInput[]
    createMany?: SubtaskCreateManyTaskInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutBlockedByInput = {
    create?: XOR<TaskCreateWithoutBlockedByInput, TaskUncheckedCreateWithoutBlockedByInput> | TaskCreateWithoutBlockedByInput[] | TaskUncheckedCreateWithoutBlockedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutBlockedByInput | TaskCreateOrConnectWithoutBlockedByInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutDependenciesInput = {
    create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput> | TaskCreateWithoutDependenciesInput[] | TaskUncheckedCreateWithoutDependenciesInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput | TaskCreateOrConnectWithoutDependenciesInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutTaskInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TimeLogCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type SubtaskUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput> | SubtaskCreateWithoutTaskInput[] | SubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTaskInput | SubtaskCreateOrConnectWithoutTaskInput[]
    createMany?: SubtaskCreateManyTaskInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutBlockedByInput = {
    create?: XOR<TaskCreateWithoutBlockedByInput, TaskUncheckedCreateWithoutBlockedByInput> | TaskCreateWithoutBlockedByInput[] | TaskUncheckedCreateWithoutBlockedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutBlockedByInput | TaskCreateOrConnectWithoutBlockedByInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutDependenciesInput = {
    create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput> | TaskCreateWithoutDependenciesInput[] | TaskUncheckedCreateWithoutDependenciesInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput | TaskCreateOrConnectWithoutDependenciesInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TimeLogUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ThemaUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ThemaCreateWithoutTasksInput, ThemaUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ThemaCreateOrConnectWithoutTasksInput
    upsert?: ThemaUpsertWithoutTasksInput
    disconnect?: ThemaWhereInput | boolean
    delete?: ThemaWhereInput | boolean
    connect?: ThemaWhereUniqueInput
    update?: XOR<XOR<ThemaUpdateToOneWithWhereWithoutTasksInput, ThemaUpdateWithoutTasksInput>, ThemaUncheckedUpdateWithoutTasksInput>
  }

  export type UserStoryUpdateOneWithoutTasksNestedInput = {
    create?: XOR<UserStoryCreateWithoutTasksInput, UserStoryUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserStoryCreateOrConnectWithoutTasksInput
    upsert?: UserStoryUpsertWithoutTasksInput
    disconnect?: UserStoryWhereInput | boolean
    delete?: UserStoryWhereInput | boolean
    connect?: UserStoryWhereUniqueInput
    update?: XOR<XOR<UserStoryUpdateToOneWithWhereWithoutTasksInput, UserStoryUpdateWithoutTasksInput>, UserStoryUncheckedUpdateWithoutTasksInput>
  }

  export type SprintUpdateOneWithoutTasksNestedInput = {
    create?: XOR<SprintCreateWithoutTasksInput, SprintUncheckedCreateWithoutTasksInput>
    connectOrCreate?: SprintCreateOrConnectWithoutTasksInput
    upsert?: SprintUpsertWithoutTasksInput
    disconnect?: SprintWhereInput | boolean
    delete?: SprintWhereInput | boolean
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutTasksInput, SprintUpdateWithoutTasksInput>, SprintUncheckedUpdateWithoutTasksInput>
  }

  export type MemberUpdateOneWithoutTasksNestedInput = {
    create?: XOR<MemberCreateWithoutTasksInput, MemberUncheckedCreateWithoutTasksInput>
    connectOrCreate?: MemberCreateOrConnectWithoutTasksInput
    upsert?: MemberUpsertWithoutTasksInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutTasksInput, MemberUpdateWithoutTasksInput>, MemberUncheckedUpdateWithoutTasksInput>
  }

  export type SubtaskUpdateManyWithoutTaskNestedInput = {
    create?: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput> | SubtaskCreateWithoutTaskInput[] | SubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTaskInput | SubtaskCreateOrConnectWithoutTaskInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutTaskInput | SubtaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: SubtaskCreateManyTaskInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutTaskInput | SubtaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutTaskInput | SubtaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutBlockedByNestedInput = {
    create?: XOR<TaskCreateWithoutBlockedByInput, TaskUncheckedCreateWithoutBlockedByInput> | TaskCreateWithoutBlockedByInput[] | TaskUncheckedCreateWithoutBlockedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutBlockedByInput | TaskCreateOrConnectWithoutBlockedByInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutBlockedByInput | TaskUpsertWithWhereUniqueWithoutBlockedByInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutBlockedByInput | TaskUpdateWithWhereUniqueWithoutBlockedByInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutBlockedByInput | TaskUpdateManyWithWhereWithoutBlockedByInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutDependenciesNestedInput = {
    create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput> | TaskCreateWithoutDependenciesInput[] | TaskUncheckedCreateWithoutDependenciesInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput | TaskCreateOrConnectWithoutDependenciesInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutDependenciesInput | TaskUpsertWithWhereUniqueWithoutDependenciesInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutDependenciesInput | TaskUpdateWithWhereUniqueWithoutDependenciesInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutDependenciesInput | TaskUpdateManyWithWhereWithoutDependenciesInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTaskInput | CommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTaskInput | CommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTaskInput | CommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TimeLogUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutTaskInput | TimeLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutTaskInput | TimeLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutTaskInput | TimeLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type SubtaskUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput> | SubtaskCreateWithoutTaskInput[] | SubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTaskInput | SubtaskCreateOrConnectWithoutTaskInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutTaskInput | SubtaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: SubtaskCreateManyTaskInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutTaskInput | SubtaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutTaskInput | SubtaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutBlockedByNestedInput = {
    create?: XOR<TaskCreateWithoutBlockedByInput, TaskUncheckedCreateWithoutBlockedByInput> | TaskCreateWithoutBlockedByInput[] | TaskUncheckedCreateWithoutBlockedByInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutBlockedByInput | TaskCreateOrConnectWithoutBlockedByInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutBlockedByInput | TaskUpsertWithWhereUniqueWithoutBlockedByInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutBlockedByInput | TaskUpdateWithWhereUniqueWithoutBlockedByInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutBlockedByInput | TaskUpdateManyWithWhereWithoutBlockedByInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutDependenciesNestedInput = {
    create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput> | TaskCreateWithoutDependenciesInput[] | TaskUncheckedCreateWithoutDependenciesInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput | TaskCreateOrConnectWithoutDependenciesInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutDependenciesInput | TaskUpsertWithWhereUniqueWithoutDependenciesInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutDependenciesInput | TaskUpdateWithWhereUniqueWithoutDependenciesInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutDependenciesInput | TaskUpdateManyWithWhereWithoutDependenciesInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTaskInput | CommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTaskInput | CommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTaskInput | CommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TimeLogUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutTaskInput | TimeLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutTaskInput | TimeLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutTaskInput | TimeLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput
    connect?: TaskWhereUniqueInput
  }

  export type SprintCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<SprintCreateWithoutSubtasksInput, SprintUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: SprintCreateOrConnectWithoutSubtasksInput
    connect?: SprintWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<MemberCreateWithoutSubtasksInput, MemberUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSubtasksInput
    connect?: MemberWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutSubtaskInput = {
    create?: XOR<FileCreateWithoutSubtaskInput, FileUncheckedCreateWithoutSubtaskInput> | FileCreateWithoutSubtaskInput[] | FileUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSubtaskInput | FileCreateOrConnectWithoutSubtaskInput[]
    createMany?: FileCreateManySubtaskInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutSubtaskInput = {
    create?: XOR<FileCreateWithoutSubtaskInput, FileUncheckedCreateWithoutSubtaskInput> | FileCreateWithoutSubtaskInput[] | FileUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSubtaskInput | FileCreateOrConnectWithoutSubtaskInput[]
    createMany?: FileCreateManySubtaskInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type TaskUpdateOneRequiredWithoutSubtasksNestedInput = {
    create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput
    upsert?: TaskUpsertWithoutSubtasksInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutSubtasksInput, TaskUpdateWithoutSubtasksInput>, TaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type SprintUpdateOneWithoutSubtasksNestedInput = {
    create?: XOR<SprintCreateWithoutSubtasksInput, SprintUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: SprintCreateOrConnectWithoutSubtasksInput
    upsert?: SprintUpsertWithoutSubtasksInput
    disconnect?: SprintWhereInput | boolean
    delete?: SprintWhereInput | boolean
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutSubtasksInput, SprintUpdateWithoutSubtasksInput>, SprintUncheckedUpdateWithoutSubtasksInput>
  }

  export type MemberUpdateOneWithoutSubtasksNestedInput = {
    create?: XOR<MemberCreateWithoutSubtasksInput, MemberUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSubtasksInput
    upsert?: MemberUpsertWithoutSubtasksInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutSubtasksInput, MemberUpdateWithoutSubtasksInput>, MemberUncheckedUpdateWithoutSubtasksInput>
  }

  export type FileUpdateManyWithoutSubtaskNestedInput = {
    create?: XOR<FileCreateWithoutSubtaskInput, FileUncheckedCreateWithoutSubtaskInput> | FileCreateWithoutSubtaskInput[] | FileUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSubtaskInput | FileCreateOrConnectWithoutSubtaskInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutSubtaskInput | FileUpsertWithWhereUniqueWithoutSubtaskInput[]
    createMany?: FileCreateManySubtaskInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutSubtaskInput | FileUpdateWithWhereUniqueWithoutSubtaskInput[]
    updateMany?: FileUpdateManyWithWhereWithoutSubtaskInput | FileUpdateManyWithWhereWithoutSubtaskInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutSubtaskNestedInput = {
    create?: XOR<FileCreateWithoutSubtaskInput, FileUncheckedCreateWithoutSubtaskInput> | FileCreateWithoutSubtaskInput[] | FileUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSubtaskInput | FileCreateOrConnectWithoutSubtaskInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutSubtaskInput | FileUpsertWithWhereUniqueWithoutSubtaskInput[]
    createMany?: FileCreateManySubtaskInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutSubtaskInput | FileUpdateWithWhereUniqueWithoutSubtaskInput[]
    updateMany?: FileUpdateManyWithWhereWithoutSubtaskInput | FileUpdateManyWithWhereWithoutSubtaskInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutFoldersInput = {
    create?: XOR<ProjectCreateWithoutFoldersInput, ProjectUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFoldersInput
    connect?: ProjectWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutFolderInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutFoldersNestedInput = {
    create?: XOR<ProjectCreateWithoutFoldersInput, ProjectUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFoldersInput
    upsert?: ProjectUpsertWithoutFoldersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutFoldersInput, ProjectUpdateWithoutFoldersInput>, ProjectUncheckedUpdateWithoutFoldersInput>
  }

  export type FileUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutFolderInput | FileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutFolderInput | FileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutFolderInput | FileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutFolderInput | FileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutFolderInput | FileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutFolderInput | FileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FolderCreateNestedOneWithoutFilesInput = {
    create?: XOR<FolderCreateWithoutFilesInput, FolderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FolderCreateOrConnectWithoutFilesInput
    connect?: FolderWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutFilesInput = {
    create?: XOR<ProjectCreateWithoutFilesInput, ProjectUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFilesInput
    connect?: ProjectWhereUniqueInput
  }

  export type SubtaskCreateNestedOneWithoutFilesInput = {
    create?: XOR<SubtaskCreateWithoutFilesInput, SubtaskUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SubtaskCreateOrConnectWithoutFilesInput
    connect?: SubtaskWhereUniqueInput
  }

  export type SprintCreateNestedOneWithoutFilesInput = {
    create?: XOR<SprintCreateWithoutFilesInput, SprintUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SprintCreateOrConnectWithoutFilesInput
    connect?: SprintWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutFilesInput = {
    create?: XOR<MemberCreateWithoutFilesInput, MemberUncheckedCreateWithoutFilesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutFilesInput
    connect?: MemberWhereUniqueInput
  }

  export type DependencyCreateNestedManyWithoutFileInput = {
    create?: XOR<DependencyCreateWithoutFileInput, DependencyUncheckedCreateWithoutFileInput> | DependencyCreateWithoutFileInput[] | DependencyUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutFileInput | DependencyCreateOrConnectWithoutFileInput[]
    createMany?: DependencyCreateManyFileInputEnvelope
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
  }

  export type FileRelationCreateNestedManyWithoutFromFileInput = {
    create?: XOR<FileRelationCreateWithoutFromFileInput, FileRelationUncheckedCreateWithoutFromFileInput> | FileRelationCreateWithoutFromFileInput[] | FileRelationUncheckedCreateWithoutFromFileInput[]
    connectOrCreate?: FileRelationCreateOrConnectWithoutFromFileInput | FileRelationCreateOrConnectWithoutFromFileInput[]
    createMany?: FileRelationCreateManyFromFileInputEnvelope
    connect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
  }

  export type FileRelationCreateNestedManyWithoutToFileInput = {
    create?: XOR<FileRelationCreateWithoutToFileInput, FileRelationUncheckedCreateWithoutToFileInput> | FileRelationCreateWithoutToFileInput[] | FileRelationUncheckedCreateWithoutToFileInput[]
    connectOrCreate?: FileRelationCreateOrConnectWithoutToFileInput | FileRelationCreateOrConnectWithoutToFileInput[]
    createMany?: FileRelationCreateManyToFileInputEnvelope
    connect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
  }

  export type DependencyUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<DependencyCreateWithoutFileInput, DependencyUncheckedCreateWithoutFileInput> | DependencyCreateWithoutFileInput[] | DependencyUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutFileInput | DependencyCreateOrConnectWithoutFileInput[]
    createMany?: DependencyCreateManyFileInputEnvelope
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
  }

  export type FileRelationUncheckedCreateNestedManyWithoutFromFileInput = {
    create?: XOR<FileRelationCreateWithoutFromFileInput, FileRelationUncheckedCreateWithoutFromFileInput> | FileRelationCreateWithoutFromFileInput[] | FileRelationUncheckedCreateWithoutFromFileInput[]
    connectOrCreate?: FileRelationCreateOrConnectWithoutFromFileInput | FileRelationCreateOrConnectWithoutFromFileInput[]
    createMany?: FileRelationCreateManyFromFileInputEnvelope
    connect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
  }

  export type FileRelationUncheckedCreateNestedManyWithoutToFileInput = {
    create?: XOR<FileRelationCreateWithoutToFileInput, FileRelationUncheckedCreateWithoutToFileInput> | FileRelationCreateWithoutToFileInput[] | FileRelationUncheckedCreateWithoutToFileInput[]
    connectOrCreate?: FileRelationCreateOrConnectWithoutToFileInput | FileRelationCreateOrConnectWithoutToFileInput[]
    createMany?: FileRelationCreateManyToFileInputEnvelope
    connect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type FolderUpdateOneWithoutFilesNestedInput = {
    create?: XOR<FolderCreateWithoutFilesInput, FolderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FolderCreateOrConnectWithoutFilesInput
    upsert?: FolderUpsertWithoutFilesInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutFilesInput, FolderUpdateWithoutFilesInput>, FolderUncheckedUpdateWithoutFilesInput>
  }

  export type ProjectUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<ProjectCreateWithoutFilesInput, ProjectUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFilesInput
    upsert?: ProjectUpsertWithoutFilesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutFilesInput, ProjectUpdateWithoutFilesInput>, ProjectUncheckedUpdateWithoutFilesInput>
  }

  export type SubtaskUpdateOneWithoutFilesNestedInput = {
    create?: XOR<SubtaskCreateWithoutFilesInput, SubtaskUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SubtaskCreateOrConnectWithoutFilesInput
    upsert?: SubtaskUpsertWithoutFilesInput
    disconnect?: SubtaskWhereInput | boolean
    delete?: SubtaskWhereInput | boolean
    connect?: SubtaskWhereUniqueInput
    update?: XOR<XOR<SubtaskUpdateToOneWithWhereWithoutFilesInput, SubtaskUpdateWithoutFilesInput>, SubtaskUncheckedUpdateWithoutFilesInput>
  }

  export type SprintUpdateOneWithoutFilesNestedInput = {
    create?: XOR<SprintCreateWithoutFilesInput, SprintUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SprintCreateOrConnectWithoutFilesInput
    upsert?: SprintUpsertWithoutFilesInput
    disconnect?: SprintWhereInput | boolean
    delete?: SprintWhereInput | boolean
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutFilesInput, SprintUpdateWithoutFilesInput>, SprintUncheckedUpdateWithoutFilesInput>
  }

  export type MemberUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<MemberCreateWithoutFilesInput, MemberUncheckedCreateWithoutFilesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutFilesInput
    upsert?: MemberUpsertWithoutFilesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutFilesInput, MemberUpdateWithoutFilesInput>, MemberUncheckedUpdateWithoutFilesInput>
  }

  export type DependencyUpdateManyWithoutFileNestedInput = {
    create?: XOR<DependencyCreateWithoutFileInput, DependencyUncheckedCreateWithoutFileInput> | DependencyCreateWithoutFileInput[] | DependencyUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutFileInput | DependencyCreateOrConnectWithoutFileInput[]
    upsert?: DependencyUpsertWithWhereUniqueWithoutFileInput | DependencyUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: DependencyCreateManyFileInputEnvelope
    set?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    disconnect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    delete?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    update?: DependencyUpdateWithWhereUniqueWithoutFileInput | DependencyUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: DependencyUpdateManyWithWhereWithoutFileInput | DependencyUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
  }

  export type FileRelationUpdateManyWithoutFromFileNestedInput = {
    create?: XOR<FileRelationCreateWithoutFromFileInput, FileRelationUncheckedCreateWithoutFromFileInput> | FileRelationCreateWithoutFromFileInput[] | FileRelationUncheckedCreateWithoutFromFileInput[]
    connectOrCreate?: FileRelationCreateOrConnectWithoutFromFileInput | FileRelationCreateOrConnectWithoutFromFileInput[]
    upsert?: FileRelationUpsertWithWhereUniqueWithoutFromFileInput | FileRelationUpsertWithWhereUniqueWithoutFromFileInput[]
    createMany?: FileRelationCreateManyFromFileInputEnvelope
    set?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    disconnect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    delete?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    connect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    update?: FileRelationUpdateWithWhereUniqueWithoutFromFileInput | FileRelationUpdateWithWhereUniqueWithoutFromFileInput[]
    updateMany?: FileRelationUpdateManyWithWhereWithoutFromFileInput | FileRelationUpdateManyWithWhereWithoutFromFileInput[]
    deleteMany?: FileRelationScalarWhereInput | FileRelationScalarWhereInput[]
  }

  export type FileRelationUpdateManyWithoutToFileNestedInput = {
    create?: XOR<FileRelationCreateWithoutToFileInput, FileRelationUncheckedCreateWithoutToFileInput> | FileRelationCreateWithoutToFileInput[] | FileRelationUncheckedCreateWithoutToFileInput[]
    connectOrCreate?: FileRelationCreateOrConnectWithoutToFileInput | FileRelationCreateOrConnectWithoutToFileInput[]
    upsert?: FileRelationUpsertWithWhereUniqueWithoutToFileInput | FileRelationUpsertWithWhereUniqueWithoutToFileInput[]
    createMany?: FileRelationCreateManyToFileInputEnvelope
    set?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    disconnect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    delete?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    connect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    update?: FileRelationUpdateWithWhereUniqueWithoutToFileInput | FileRelationUpdateWithWhereUniqueWithoutToFileInput[]
    updateMany?: FileRelationUpdateManyWithWhereWithoutToFileInput | FileRelationUpdateManyWithWhereWithoutToFileInput[]
    deleteMany?: FileRelationScalarWhereInput | FileRelationScalarWhereInput[]
  }

  export type DependencyUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<DependencyCreateWithoutFileInput, DependencyUncheckedCreateWithoutFileInput> | DependencyCreateWithoutFileInput[] | DependencyUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutFileInput | DependencyCreateOrConnectWithoutFileInput[]
    upsert?: DependencyUpsertWithWhereUniqueWithoutFileInput | DependencyUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: DependencyCreateManyFileInputEnvelope
    set?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    disconnect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    delete?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    update?: DependencyUpdateWithWhereUniqueWithoutFileInput | DependencyUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: DependencyUpdateManyWithWhereWithoutFileInput | DependencyUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
  }

  export type FileRelationUncheckedUpdateManyWithoutFromFileNestedInput = {
    create?: XOR<FileRelationCreateWithoutFromFileInput, FileRelationUncheckedCreateWithoutFromFileInput> | FileRelationCreateWithoutFromFileInput[] | FileRelationUncheckedCreateWithoutFromFileInput[]
    connectOrCreate?: FileRelationCreateOrConnectWithoutFromFileInput | FileRelationCreateOrConnectWithoutFromFileInput[]
    upsert?: FileRelationUpsertWithWhereUniqueWithoutFromFileInput | FileRelationUpsertWithWhereUniqueWithoutFromFileInput[]
    createMany?: FileRelationCreateManyFromFileInputEnvelope
    set?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    disconnect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    delete?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    connect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    update?: FileRelationUpdateWithWhereUniqueWithoutFromFileInput | FileRelationUpdateWithWhereUniqueWithoutFromFileInput[]
    updateMany?: FileRelationUpdateManyWithWhereWithoutFromFileInput | FileRelationUpdateManyWithWhereWithoutFromFileInput[]
    deleteMany?: FileRelationScalarWhereInput | FileRelationScalarWhereInput[]
  }

  export type FileRelationUncheckedUpdateManyWithoutToFileNestedInput = {
    create?: XOR<FileRelationCreateWithoutToFileInput, FileRelationUncheckedCreateWithoutToFileInput> | FileRelationCreateWithoutToFileInput[] | FileRelationUncheckedCreateWithoutToFileInput[]
    connectOrCreate?: FileRelationCreateOrConnectWithoutToFileInput | FileRelationCreateOrConnectWithoutToFileInput[]
    upsert?: FileRelationUpsertWithWhereUniqueWithoutToFileInput | FileRelationUpsertWithWhereUniqueWithoutToFileInput[]
    createMany?: FileRelationCreateManyToFileInputEnvelope
    set?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    disconnect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    delete?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    connect?: FileRelationWhereUniqueInput | FileRelationWhereUniqueInput[]
    update?: FileRelationUpdateWithWhereUniqueWithoutToFileInput | FileRelationUpdateWithWhereUniqueWithoutToFileInput[]
    updateMany?: FileRelationUpdateManyWithWhereWithoutToFileInput | FileRelationUpdateManyWithWhereWithoutToFileInput[]
    deleteMany?: FileRelationScalarWhereInput | FileRelationScalarWhereInput[]
  }

  export type FileCreateNestedOneWithoutDependenciesInput = {
    create?: XOR<FileCreateWithoutDependenciesInput, FileUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: FileCreateOrConnectWithoutDependenciesInput
    connect?: FileWhereUniqueInput
  }

  export type FileUpdateOneRequiredWithoutDependenciesNestedInput = {
    create?: XOR<FileCreateWithoutDependenciesInput, FileUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: FileCreateOrConnectWithoutDependenciesInput
    upsert?: FileUpsertWithoutDependenciesInput
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutDependenciesInput, FileUpdateWithoutDependenciesInput>, FileUncheckedUpdateWithoutDependenciesInput>
  }

  export type FileCreateNestedOneWithoutRelationsFromInput = {
    create?: XOR<FileCreateWithoutRelationsFromInput, FileUncheckedCreateWithoutRelationsFromInput>
    connectOrCreate?: FileCreateOrConnectWithoutRelationsFromInput
    connect?: FileWhereUniqueInput
  }

  export type FileCreateNestedOneWithoutRelationsToInput = {
    create?: XOR<FileCreateWithoutRelationsToInput, FileUncheckedCreateWithoutRelationsToInput>
    connectOrCreate?: FileCreateOrConnectWithoutRelationsToInput
    connect?: FileWhereUniqueInput
  }

  export type EnumRelationTypeFieldUpdateOperationsInput = {
    set?: $Enums.RelationType
  }

  export type FileUpdateOneRequiredWithoutRelationsFromNestedInput = {
    create?: XOR<FileCreateWithoutRelationsFromInput, FileUncheckedCreateWithoutRelationsFromInput>
    connectOrCreate?: FileCreateOrConnectWithoutRelationsFromInput
    upsert?: FileUpsertWithoutRelationsFromInput
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutRelationsFromInput, FileUpdateWithoutRelationsFromInput>, FileUncheckedUpdateWithoutRelationsFromInput>
  }

  export type FileUpdateOneRequiredWithoutRelationsToNestedInput = {
    create?: XOR<FileCreateWithoutRelationsToInput, FileUncheckedCreateWithoutRelationsToInput>
    connectOrCreate?: FileCreateOrConnectWithoutRelationsToInput
    upsert?: FileUpsertWithoutRelationsToInput
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutRelationsToInput, FileUpdateWithoutRelationsToInput>, FileUncheckedUpdateWithoutRelationsToInput>
  }

  export type MemberCreateNestedOneWithoutCommentsInput = {
    create?: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCommentsInput
    connect?: MemberWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCommentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ThemaCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ThemaCreateWithoutCommentsInput, ThemaUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ThemaCreateOrConnectWithoutCommentsInput
    connect?: ThemaWhereUniqueInput
  }

  export type EpicCreateNestedOneWithoutCommentsInput = {
    create?: XOR<EpicCreateWithoutCommentsInput, EpicUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: EpicCreateOrConnectWithoutCommentsInput
    connect?: EpicWhereUniqueInput
  }

  export type UserStoryCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserStoryCreateWithoutCommentsInput, UserStoryUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserStoryCreateOrConnectWithoutCommentsInput
    connect?: UserStoryWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    connect?: TaskWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCommentsInput
    upsert?: MemberUpsertWithoutCommentsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutCommentsInput, MemberUpdateWithoutCommentsInput>, MemberUncheckedUpdateWithoutCommentsInput>
  }

  export type ProjectUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCommentsInput
    upsert?: ProjectUpsertWithoutCommentsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCommentsInput, ProjectUpdateWithoutCommentsInput>, ProjectUncheckedUpdateWithoutCommentsInput>
  }

  export type ThemaUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<ThemaCreateWithoutCommentsInput, ThemaUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ThemaCreateOrConnectWithoutCommentsInput
    upsert?: ThemaUpsertWithoutCommentsInput
    disconnect?: ThemaWhereInput | boolean
    delete?: ThemaWhereInput | boolean
    connect?: ThemaWhereUniqueInput
    update?: XOR<XOR<ThemaUpdateToOneWithWhereWithoutCommentsInput, ThemaUpdateWithoutCommentsInput>, ThemaUncheckedUpdateWithoutCommentsInput>
  }

  export type EpicUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<EpicCreateWithoutCommentsInput, EpicUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: EpicCreateOrConnectWithoutCommentsInput
    upsert?: EpicUpsertWithoutCommentsInput
    disconnect?: EpicWhereInput | boolean
    delete?: EpicWhereInput | boolean
    connect?: EpicWhereUniqueInput
    update?: XOR<XOR<EpicUpdateToOneWithWhereWithoutCommentsInput, EpicUpdateWithoutCommentsInput>, EpicUncheckedUpdateWithoutCommentsInput>
  }

  export type UserStoryUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<UserStoryCreateWithoutCommentsInput, UserStoryUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserStoryCreateOrConnectWithoutCommentsInput
    upsert?: UserStoryUpsertWithoutCommentsInput
    disconnect?: UserStoryWhereInput | boolean
    delete?: UserStoryWhereInput | boolean
    connect?: UserStoryWhereUniqueInput
    update?: XOR<XOR<UserStoryUpdateToOneWithWhereWithoutCommentsInput, UserStoryUpdateWithoutCommentsInput>, UserStoryUncheckedUpdateWithoutCommentsInput>
  }

  export type TaskUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    upsert?: TaskUpsertWithoutCommentsInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCommentsInput, TaskUpdateWithoutCommentsInput>, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type TaskCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeLogsInput
    connect?: TaskWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<MemberCreateWithoutTimeLogsInput, MemberUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutTimeLogsInput
    connect?: MemberWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTimeLogsNestedInput = {
    create?: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeLogsInput
    upsert?: TaskUpsertWithoutTimeLogsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTimeLogsInput, TaskUpdateWithoutTimeLogsInput>, TaskUncheckedUpdateWithoutTimeLogsInput>
  }

  export type MemberUpdateOneRequiredWithoutTimeLogsNestedInput = {
    create?: XOR<MemberCreateWithoutTimeLogsInput, MemberUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutTimeLogsInput
    upsert?: MemberUpsertWithoutTimeLogsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutTimeLogsInput, MemberUpdateWithoutTimeLogsInput>, MemberUncheckedUpdateWithoutTimeLogsInput>
  }

  export type MemberCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<MemberCreateWithoutActivitiesInput, MemberUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutActivitiesInput
    connect?: MemberWhereUniqueInput
  }

  export type EnumActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActionType
  }

  export type MemberUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<MemberCreateWithoutActivitiesInput, MemberUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutActivitiesInput
    upsert?: MemberUpsertWithoutActivitiesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutActivitiesInput, MemberUpdateWithoutActivitiesInput>, MemberUncheckedUpdateWithoutActivitiesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[]
    notIn?: $Enums.FileType[]
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[]
    notIn?: $Enums.FileType[]
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedEnumRelationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[]
    notIn?: $Enums.RelationType[]
    not?: NestedEnumRelationTypeFilter<$PrismaModel> | $Enums.RelationType
  }

  export type NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[]
    notIn?: $Enums.RelationType[]
    not?: NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationTypeFilter<$PrismaModel>
  }

  export type NestedEnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[]
    notIn?: $Enums.ActionType[]
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type NestedEnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[]
    notIn?: $Enums.ActionType[]
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type MemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutUserInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutUserInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberCreateManyUserInputEnvelope = {
    data: MemberCreateManyUserInput | MemberCreateManyUserInput[]
  }

  export type VerificationCreateWithoutUserInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateWithoutUserInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationCreateOrConnectWithoutUserInput = {
    where: VerificationWhereUniqueInput
    create: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput>
  }

  export type VerificationCreateManyUserInputEnvelope = {
    data: VerificationCreateManyUserInput | VerificationCreateManyUserInput[]
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type MemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
  }

  export type MemberUpdateManyWithWhereWithoutUserInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: StringFilter<"Member"> | string
    role?: EnumRoleFilter<"Member"> | $Enums.Role
    joinedAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    userId?: StringFilter<"Member"> | string
    projectId?: StringFilter<"Member"> | string
  }

  export type VerificationUpsertWithWhereUniqueWithoutUserInput = {
    where: VerificationWhereUniqueInput
    update: XOR<VerificationUpdateWithoutUserInput, VerificationUncheckedUpdateWithoutUserInput>
    create: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput>
  }

  export type VerificationUpdateWithWhereUniqueWithoutUserInput = {
    where: VerificationWhereUniqueInput
    data: XOR<VerificationUpdateWithoutUserInput, VerificationUncheckedUpdateWithoutUserInput>
  }

  export type VerificationUpdateManyWithWhereWithoutUserInput = {
    where: VerificationScalarWhereInput
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyWithoutUserInput>
  }

  export type VerificationScalarWhereInput = {
    AND?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
    OR?: VerificationScalarWhereInput[]
    NOT?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
    userId?: StringFilter<"Verification"> | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.Role
    lang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    memberships?: MemberCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.Role
    lang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    memberships?: MemberUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    memberships?: MemberUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MemberUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.Role
    lang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    memberships?: MemberCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.Role
    lang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    memberships?: MemberUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    memberships?: MemberUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MemberUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVerificationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.Role
    lang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    memberships?: MemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVerificationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.Role
    lang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    memberships?: MemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVerificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
  }

  export type UserUpsertWithoutVerificationsInput = {
    update: XOR<UserUpdateWithoutVerificationsInput, UserUncheckedUpdateWithoutVerificationsInput>
    create: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerificationsInput, UserUncheckedUpdateWithoutVerificationsInput>
  }

  export type UserUpdateWithoutVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    memberships?: MemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ThemaCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: MemberCreateNestedOneWithoutThemasInput
    tasks?: TaskCreateNestedManyWithoutThemaInput
    comments?: CommentCreateNestedManyWithoutThemaInput
  }

  export type ThemaUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutThemaInput
    comments?: CommentUncheckedCreateNestedManyWithoutThemaInput
  }

  export type ThemaCreateOrConnectWithoutProjectInput = {
    where: ThemaWhereUniqueInput
    create: XOR<ThemaCreateWithoutProjectInput, ThemaUncheckedCreateWithoutProjectInput>
  }

  export type ThemaCreateManyProjectInputEnvelope = {
    data: ThemaCreateManyProjectInput | ThemaCreateManyProjectInput[]
  }

  export type EpicCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: MemberCreateNestedOneWithoutEpicsInput
    userStories?: UserStoryCreateNestedManyWithoutEpicInput
    comments?: CommentCreateNestedManyWithoutEpicInput
  }

  export type EpicUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    userStories?: UserStoryUncheckedCreateNestedManyWithoutEpicInput
    comments?: CommentUncheckedCreateNestedManyWithoutEpicInput
  }

  export type EpicCreateOrConnectWithoutProjectInput = {
    where: EpicWhereUniqueInput
    create: XOR<EpicCreateWithoutProjectInput, EpicUncheckedCreateWithoutProjectInput>
  }

  export type EpicCreateManyProjectInputEnvelope = {
    data: EpicCreateManyProjectInput | EpicCreateManyProjectInput[]
  }

  export type UserStoryCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    epic?: EpicCreateNestedOneWithoutUserStoriesInput
    creator: MemberCreateNestedOneWithoutUserStoriesInput
    sprint?: SprintCreateNestedOneWithoutUserStoriesInput
    tasks?: TaskCreateNestedManyWithoutUserStoryInput
    comments?: CommentCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    epicId?: string | null
    creatorId: string
    sprintId?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutUserStoryInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryCreateOrConnectWithoutProjectInput = {
    where: UserStoryWhereUniqueInput
    create: XOR<UserStoryCreateWithoutProjectInput, UserStoryUncheckedCreateWithoutProjectInput>
  }

  export type UserStoryCreateManyProjectInputEnvelope = {
    data: UserStoryCreateManyProjectInput | UserStoryCreateManyProjectInput[]
  }

  export type SprintCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: MemberCreateNestedOneWithoutSprintsInput
    userStories?: UserStoryCreateNestedManyWithoutSprintInput
    tasks?: TaskCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskCreateNestedManyWithoutSprintInput
    files?: FileCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    userStories?: UserStoryUncheckedCreateNestedManyWithoutSprintInput
    tasks?: TaskUncheckedCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutSprintInput
    files?: FileUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutProjectInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput>
  }

  export type SprintCreateManyProjectInputEnvelope = {
    data: SprintCreateManyProjectInput | SprintCreateManyProjectInput[]
  }

  export type MemberCreateWithoutProjectInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutProjectInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutProjectInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput>
  }

  export type MemberCreateManyProjectInputEnvelope = {
    data: MemberCreateManyProjectInput | MemberCreateManyProjectInput[]
  }

  export type FolderCreateWithoutProjectInput = {
    id?: string
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    files?: FileCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutProjectInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutProjectInput, FolderUncheckedCreateWithoutProjectInput>
  }

  export type FolderCreateManyProjectInputEnvelope = {
    data: FolderCreateManyProjectInput | FolderCreateManyProjectInput[]
  }

  export type FileCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: FolderCreateNestedOneWithoutFilesInput
    subtask?: SubtaskCreateNestedOneWithoutFilesInput
    sprint?: SprintCreateNestedOneWithoutFilesInput
    uploader: MemberCreateNestedOneWithoutFilesInput
    dependencies?: DependencyCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationCreateNestedManyWithoutToFileInput
  }

  export type FileUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    subtaskId?: string | null
    sprintId?: string | null
    uploaderId: string
    dependencies?: DependencyUncheckedCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationUncheckedCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationUncheckedCreateNestedManyWithoutToFileInput
  }

  export type FileCreateOrConnectWithoutProjectInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutProjectInput, FileUncheckedCreateWithoutProjectInput>
  }

  export type FileCreateManyProjectInputEnvelope = {
    data: FileCreateManyProjectInput | FileCreateManyProjectInput[]
  }

  export type CommentCreateWithoutProjectInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: MemberCreateNestedOneWithoutCommentsInput
    thema?: ThemaCreateNestedOneWithoutCommentsInput
    epic?: EpicCreateNestedOneWithoutCommentsInput
    userStory?: UserStoryCreateNestedOneWithoutCommentsInput
    task?: TaskCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutProjectInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    themaId?: string | null
    epicId?: string | null
    userStoryId?: string | null
    taskId?: string | null
  }

  export type CommentCreateOrConnectWithoutProjectInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput>
  }

  export type CommentCreateManyProjectInputEnvelope = {
    data: CommentCreateManyProjectInput | CommentCreateManyProjectInput[]
  }

  export type MemberCreateWithoutCreatedProjectsInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutCreatedProjectsInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutCreatedProjectsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutCreatedProjectsInput, MemberUncheckedCreateWithoutCreatedProjectsInput>
  }

  export type ThemaUpsertWithWhereUniqueWithoutProjectInput = {
    where: ThemaWhereUniqueInput
    update: XOR<ThemaUpdateWithoutProjectInput, ThemaUncheckedUpdateWithoutProjectInput>
    create: XOR<ThemaCreateWithoutProjectInput, ThemaUncheckedCreateWithoutProjectInput>
  }

  export type ThemaUpdateWithWhereUniqueWithoutProjectInput = {
    where: ThemaWhereUniqueInput
    data: XOR<ThemaUpdateWithoutProjectInput, ThemaUncheckedUpdateWithoutProjectInput>
  }

  export type ThemaUpdateManyWithWhereWithoutProjectInput = {
    where: ThemaScalarWhereInput
    data: XOR<ThemaUpdateManyMutationInput, ThemaUncheckedUpdateManyWithoutProjectInput>
  }

  export type ThemaScalarWhereInput = {
    AND?: ThemaScalarWhereInput | ThemaScalarWhereInput[]
    OR?: ThemaScalarWhereInput[]
    NOT?: ThemaScalarWhereInput | ThemaScalarWhereInput[]
    id?: StringFilter<"Thema"> | string
    name?: StringFilter<"Thema"> | string
    description?: StringNullableFilter<"Thema"> | string | null
    status?: EnumStatusFilter<"Thema"> | $Enums.Status
    priority?: IntFilter<"Thema"> | number
    startDate?: DateTimeNullableFilter<"Thema"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Thema"> | Date | string | null
    createdAt?: DateTimeFilter<"Thema"> | Date | string
    updatedAt?: DateTimeFilter<"Thema"> | Date | string
    projectId?: StringFilter<"Thema"> | string
    creatorId?: StringFilter<"Thema"> | string
  }

  export type EpicUpsertWithWhereUniqueWithoutProjectInput = {
    where: EpicWhereUniqueInput
    update: XOR<EpicUpdateWithoutProjectInput, EpicUncheckedUpdateWithoutProjectInput>
    create: XOR<EpicCreateWithoutProjectInput, EpicUncheckedCreateWithoutProjectInput>
  }

  export type EpicUpdateWithWhereUniqueWithoutProjectInput = {
    where: EpicWhereUniqueInput
    data: XOR<EpicUpdateWithoutProjectInput, EpicUncheckedUpdateWithoutProjectInput>
  }

  export type EpicUpdateManyWithWhereWithoutProjectInput = {
    where: EpicScalarWhereInput
    data: XOR<EpicUpdateManyMutationInput, EpicUncheckedUpdateManyWithoutProjectInput>
  }

  export type EpicScalarWhereInput = {
    AND?: EpicScalarWhereInput | EpicScalarWhereInput[]
    OR?: EpicScalarWhereInput[]
    NOT?: EpicScalarWhereInput | EpicScalarWhereInput[]
    id?: StringFilter<"Epic"> | string
    name?: StringFilter<"Epic"> | string
    description?: StringNullableFilter<"Epic"> | string | null
    status?: EnumStatusFilter<"Epic"> | $Enums.Status
    priority?: IntFilter<"Epic"> | number
    startDate?: DateTimeNullableFilter<"Epic"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Epic"> | Date | string | null
    createdAt?: DateTimeFilter<"Epic"> | Date | string
    updatedAt?: DateTimeFilter<"Epic"> | Date | string
    projectId?: StringFilter<"Epic"> | string
    creatorId?: StringFilter<"Epic"> | string
  }

  export type UserStoryUpsertWithWhereUniqueWithoutProjectInput = {
    where: UserStoryWhereUniqueInput
    update: XOR<UserStoryUpdateWithoutProjectInput, UserStoryUncheckedUpdateWithoutProjectInput>
    create: XOR<UserStoryCreateWithoutProjectInput, UserStoryUncheckedCreateWithoutProjectInput>
  }

  export type UserStoryUpdateWithWhereUniqueWithoutProjectInput = {
    where: UserStoryWhereUniqueInput
    data: XOR<UserStoryUpdateWithoutProjectInput, UserStoryUncheckedUpdateWithoutProjectInput>
  }

  export type UserStoryUpdateManyWithWhereWithoutProjectInput = {
    where: UserStoryScalarWhereInput
    data: XOR<UserStoryUpdateManyMutationInput, UserStoryUncheckedUpdateManyWithoutProjectInput>
  }

  export type UserStoryScalarWhereInput = {
    AND?: UserStoryScalarWhereInput | UserStoryScalarWhereInput[]
    OR?: UserStoryScalarWhereInput[]
    NOT?: UserStoryScalarWhereInput | UserStoryScalarWhereInput[]
    id?: StringFilter<"UserStory"> | string
    title?: StringFilter<"UserStory"> | string
    description?: StringNullableFilter<"UserStory"> | string | null
    status?: EnumStatusFilter<"UserStory"> | $Enums.Status
    priority?: IntFilter<"UserStory"> | number
    createdAt?: DateTimeFilter<"UserStory"> | Date | string
    updatedAt?: DateTimeFilter<"UserStory"> | Date | string
    projectId?: StringFilter<"UserStory"> | string
    epicId?: StringNullableFilter<"UserStory"> | string | null
    creatorId?: StringFilter<"UserStory"> | string
    sprintId?: StringNullableFilter<"UserStory"> | string | null
  }

  export type SprintUpsertWithWhereUniqueWithoutProjectInput = {
    where: SprintWhereUniqueInput
    update: XOR<SprintUpdateWithoutProjectInput, SprintUncheckedUpdateWithoutProjectInput>
    create: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput>
  }

  export type SprintUpdateWithWhereUniqueWithoutProjectInput = {
    where: SprintWhereUniqueInput
    data: XOR<SprintUpdateWithoutProjectInput, SprintUncheckedUpdateWithoutProjectInput>
  }

  export type SprintUpdateManyWithWhereWithoutProjectInput = {
    where: SprintScalarWhereInput
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyWithoutProjectInput>
  }

  export type SprintScalarWhereInput = {
    AND?: SprintScalarWhereInput | SprintScalarWhereInput[]
    OR?: SprintScalarWhereInput[]
    NOT?: SprintScalarWhereInput | SprintScalarWhereInput[]
    id?: StringFilter<"Sprint"> | string
    name?: StringFilter<"Sprint"> | string
    description?: StringNullableFilter<"Sprint"> | string | null
    status?: EnumStatusFilter<"Sprint"> | $Enums.Status
    startDate?: DateTimeNullableFilter<"Sprint"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Sprint"> | Date | string | null
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    projectId?: StringFilter<"Sprint"> | string
    creatorId?: StringFilter<"Sprint"> | string
  }

  export type MemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutProjectInput, MemberUncheckedUpdateWithoutProjectInput>
    create: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutProjectInput, MemberUncheckedUpdateWithoutProjectInput>
  }

  export type MemberUpdateManyWithWhereWithoutProjectInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type FolderUpsertWithWhereUniqueWithoutProjectInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutProjectInput, FolderUncheckedUpdateWithoutProjectInput>
    create: XOR<FolderCreateWithoutProjectInput, FolderUncheckedCreateWithoutProjectInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutProjectInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutProjectInput, FolderUncheckedUpdateWithoutProjectInput>
  }

  export type FolderUpdateManyWithWhereWithoutProjectInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutProjectInput>
  }

  export type FolderScalarWhereInput = {
    AND?: FolderScalarWhereInput | FolderScalarWhereInput[]
    OR?: FolderScalarWhereInput[]
    NOT?: FolderScalarWhereInput | FolderScalarWhereInput[]
    id?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    path?: StringFilter<"Folder"> | string
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    parentId?: StringNullableFilter<"Folder"> | string | null
    projectId?: StringFilter<"Folder"> | string
  }

  export type FileUpsertWithWhereUniqueWithoutProjectInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutProjectInput, FileUncheckedUpdateWithoutProjectInput>
    create: XOR<FileCreateWithoutProjectInput, FileUncheckedCreateWithoutProjectInput>
  }

  export type FileUpdateWithWhereUniqueWithoutProjectInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutProjectInput, FileUncheckedUpdateWithoutProjectInput>
  }

  export type FileUpdateManyWithWhereWithoutProjectInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutProjectInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    description?: StringNullableFilter<"File"> | string | null
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    size?: IntFilter<"File"> | number
    url?: StringFilter<"File"> | string
    version?: IntFilter<"File"> | number
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    folderId?: StringNullableFilter<"File"> | string | null
    projectId?: StringFilter<"File"> | string
    subtaskId?: StringNullableFilter<"File"> | string | null
    sprintId?: StringNullableFilter<"File"> | string | null
    uploaderId?: StringFilter<"File"> | string
  }

  export type CommentUpsertWithWhereUniqueWithoutProjectInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutProjectInput, CommentUncheckedUpdateWithoutProjectInput>
    create: XOR<CommentCreateWithoutProjectInput, CommentUncheckedCreateWithoutProjectInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutProjectInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutProjectInput, CommentUncheckedUpdateWithoutProjectInput>
  }

  export type CommentUpdateManyWithWhereWithoutProjectInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutProjectInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    authorId?: StringFilter<"Comment"> | string
    projectId?: StringNullableFilter<"Comment"> | string | null
    themaId?: StringNullableFilter<"Comment"> | string | null
    epicId?: StringNullableFilter<"Comment"> | string | null
    userStoryId?: StringNullableFilter<"Comment"> | string | null
    taskId?: StringNullableFilter<"Comment"> | string | null
  }

  export type MemberUpsertWithoutCreatedProjectsInput = {
    update: XOR<MemberUpdateWithoutCreatedProjectsInput, MemberUncheckedUpdateWithoutCreatedProjectsInput>
    create: XOR<MemberCreateWithoutCreatedProjectsInput, MemberUncheckedCreateWithoutCreatedProjectsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutCreatedProjectsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutCreatedProjectsInput, MemberUncheckedUpdateWithoutCreatedProjectsInput>
  }

  export type MemberUpdateWithoutCreatedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutCreatedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.Role
    lang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.Role
    lang?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themas?: ThemaCreateNestedManyWithoutProjectInput
    epics?: EpicCreateNestedManyWithoutProjectInput
    userStories?: UserStoryCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    folders?: FolderCreateNestedManyWithoutProjectInput
    files?: FileCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    creator?: MemberCreateNestedOneWithoutCreatedProjectsInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId?: string | null
    themas?: ThemaUncheckedCreateNestedManyWithoutProjectInput
    epics?: EpicUncheckedCreateNestedManyWithoutProjectInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    folders?: FolderUncheckedCreateNestedManyWithoutProjectInput
    files?: FileUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type FileCreateWithoutUploaderInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: FolderCreateNestedOneWithoutFilesInput
    project: ProjectCreateNestedOneWithoutFilesInput
    subtask?: SubtaskCreateNestedOneWithoutFilesInput
    sprint?: SprintCreateNestedOneWithoutFilesInput
    dependencies?: DependencyCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationCreateNestedManyWithoutToFileInput
  }

  export type FileUncheckedCreateWithoutUploaderInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    projectId: string
    subtaskId?: string | null
    sprintId?: string | null
    dependencies?: DependencyUncheckedCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationUncheckedCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationUncheckedCreateNestedManyWithoutToFileInput
  }

  export type FileCreateOrConnectWithoutUploaderInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput>
  }

  export type FileCreateManyUploaderInputEnvelope = {
    data: FileCreateManyUploaderInput | FileCreateManyUploaderInput[]
  }

  export type TaskCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thema?: ThemaCreateNestedOneWithoutTasksInput
    userStory?: UserStoryCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    dependencies?: TaskCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskCreateNestedManyWithoutDependenciesInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    userStoryId?: string | null
    sprintId?: string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    dependencies?: TaskUncheckedCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskUncheckedCreateNestedManyWithoutDependenciesInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskCreateManyAssigneeInputEnvelope = {
    data: TaskCreateManyAssigneeInput | TaskCreateManyAssigneeInput[]
  }

  export type SubtaskCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutSubtasksInput
    sprint?: SprintCreateNestedOneWithoutSubtasksInput
    files?: FileCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    taskId: string
    sprintId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskCreateOrConnectWithoutAssigneeInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput>
  }

  export type SubtaskCreateManyAssigneeInputEnvelope = {
    data: SubtaskCreateManyAssigneeInput | SubtaskCreateManyAssigneeInput[]
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutCommentsInput
    thema?: ThemaCreateNestedOneWithoutCommentsInput
    epic?: EpicCreateNestedOneWithoutCommentsInput
    userStory?: UserStoryCreateNestedOneWithoutCommentsInput
    task?: TaskCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string | null
    themaId?: string | null
    epicId?: string | null
    userStoryId?: string | null
    taskId?: string | null
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
  }

  export type TimeLogCreateWithoutMemberInput = {
    id?: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateWithoutMemberInput = {
    id?: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    taskId: string
  }

  export type TimeLogCreateOrConnectWithoutMemberInput = {
    where: TimeLogWhereUniqueInput
    create: XOR<TimeLogCreateWithoutMemberInput, TimeLogUncheckedCreateWithoutMemberInput>
  }

  export type TimeLogCreateManyMemberInputEnvelope = {
    data: TimeLogCreateManyMemberInput | TimeLogCreateManyMemberInput[]
  }

  export type UserStoryCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUserStoriesInput
    epic?: EpicCreateNestedOneWithoutUserStoriesInput
    sprint?: SprintCreateNestedOneWithoutUserStoriesInput
    tasks?: TaskCreateNestedManyWithoutUserStoryInput
    comments?: CommentCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    epicId?: string | null
    sprintId?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutUserStoryInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryCreateOrConnectWithoutCreatorInput = {
    where: UserStoryWhereUniqueInput
    create: XOR<UserStoryCreateWithoutCreatorInput, UserStoryUncheckedCreateWithoutCreatorInput>
  }

  export type UserStoryCreateManyCreatorInputEnvelope = {
    data: UserStoryCreateManyCreatorInput | UserStoryCreateManyCreatorInput[]
  }

  export type ThemaCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutThemasInput
    tasks?: TaskCreateNestedManyWithoutThemaInput
    comments?: CommentCreateNestedManyWithoutThemaInput
  }

  export type ThemaUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutThemaInput
    comments?: CommentUncheckedCreateNestedManyWithoutThemaInput
  }

  export type ThemaCreateOrConnectWithoutCreatorInput = {
    where: ThemaWhereUniqueInput
    create: XOR<ThemaCreateWithoutCreatorInput, ThemaUncheckedCreateWithoutCreatorInput>
  }

  export type ThemaCreateManyCreatorInputEnvelope = {
    data: ThemaCreateManyCreatorInput | ThemaCreateManyCreatorInput[]
  }

  export type EpicCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutEpicsInput
    userStories?: UserStoryCreateNestedManyWithoutEpicInput
    comments?: CommentCreateNestedManyWithoutEpicInput
  }

  export type EpicUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userStories?: UserStoryUncheckedCreateNestedManyWithoutEpicInput
    comments?: CommentUncheckedCreateNestedManyWithoutEpicInput
  }

  export type EpicCreateOrConnectWithoutCreatorInput = {
    where: EpicWhereUniqueInput
    create: XOR<EpicCreateWithoutCreatorInput, EpicUncheckedCreateWithoutCreatorInput>
  }

  export type EpicCreateManyCreatorInputEnvelope = {
    data: EpicCreateManyCreatorInput | EpicCreateManyCreatorInput[]
  }

  export type SprintCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    userStories?: UserStoryCreateNestedManyWithoutSprintInput
    tasks?: TaskCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskCreateNestedManyWithoutSprintInput
    files?: FileCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userStories?: UserStoryUncheckedCreateNestedManyWithoutSprintInput
    tasks?: TaskUncheckedCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutSprintInput
    files?: FileUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutCreatorInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutCreatorInput, SprintUncheckedCreateWithoutCreatorInput>
  }

  export type SprintCreateManyCreatorInputEnvelope = {
    data: SprintCreateManyCreatorInput | SprintCreateManyCreatorInput[]
  }

  export type ActivityLogCreateWithoutMemberInput = {
    id?: string
    action: $Enums.ActionType
    entityId: string
    timestamp?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutMemberInput = {
    id?: string
    action: $Enums.ActionType
    entityId: string
    timestamp?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutMemberInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutMemberInput, ActivityLogUncheckedCreateWithoutMemberInput>
  }

  export type ActivityLogCreateManyMemberInputEnvelope = {
    data: ActivityLogCreateManyMemberInput | ActivityLogCreateManyMemberInput[]
  }

  export type ProjectCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themas?: ThemaCreateNestedManyWithoutProjectInput
    epics?: EpicCreateNestedManyWithoutProjectInput
    userStories?: UserStoryCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    folders?: FolderCreateNestedManyWithoutProjectInput
    files?: FileCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themas?: ThemaUncheckedCreateNestedManyWithoutProjectInput
    epics?: EpicUncheckedCreateNestedManyWithoutProjectInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    folders?: FolderUncheckedCreateNestedManyWithoutProjectInput
    files?: FileUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectCreateManyCreatorInputEnvelope = {
    data: ProjectCreateManyCreatorInput | ProjectCreateManyCreatorInput[]
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themas?: ThemaUpdateManyWithoutProjectNestedInput
    epics?: EpicUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    folders?: FolderUpdateManyWithoutProjectNestedInput
    files?: FileUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    creator?: MemberUpdateOneWithoutCreatedProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    themas?: ThemaUncheckedUpdateManyWithoutProjectNestedInput
    epics?: EpicUncheckedUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    folders?: FolderUncheckedUpdateManyWithoutProjectNestedInput
    files?: FileUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type FileUpsertWithWhereUniqueWithoutUploaderInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutUploaderInput, FileUncheckedUpdateWithoutUploaderInput>
    create: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput>
  }

  export type FileUpdateWithWhereUniqueWithoutUploaderInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutUploaderInput, FileUncheckedUpdateWithoutUploaderInput>
  }

  export type FileUpdateManyWithWhereWithoutUploaderInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutUploaderInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumStatusFilter<"Task"> | $Enums.Status
    priority?: IntFilter<"Task"> | number
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedDuration?: IntNullableFilter<"Task"> | number | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    themaId?: StringNullableFilter<"Task"> | string | null
    userStoryId?: StringNullableFilter<"Task"> | string | null
    sprintId?: StringNullableFilter<"Task"> | string | null
    assigneeId?: StringNullableFilter<"Task"> | string | null
  }

  export type SubtaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: SubtaskWhereUniqueInput
    update: XOR<SubtaskUpdateWithoutAssigneeInput, SubtaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput>
  }

  export type SubtaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: SubtaskWhereUniqueInput
    data: XOR<SubtaskUpdateWithoutAssigneeInput, SubtaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type SubtaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: SubtaskScalarWhereInput
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type SubtaskScalarWhereInput = {
    AND?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
    OR?: SubtaskScalarWhereInput[]
    NOT?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
    id?: StringFilter<"Subtask"> | string
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: EnumStatusFilter<"Subtask"> | $Enums.Status
    createdAt?: DateTimeFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeFilter<"Subtask"> | Date | string
    taskId?: StringFilter<"Subtask"> | string
    sprintId?: StringNullableFilter<"Subtask"> | string | null
    assigneeId?: StringNullableFilter<"Subtask"> | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type TimeLogUpsertWithWhereUniqueWithoutMemberInput = {
    where: TimeLogWhereUniqueInput
    update: XOR<TimeLogUpdateWithoutMemberInput, TimeLogUncheckedUpdateWithoutMemberInput>
    create: XOR<TimeLogCreateWithoutMemberInput, TimeLogUncheckedCreateWithoutMemberInput>
  }

  export type TimeLogUpdateWithWhereUniqueWithoutMemberInput = {
    where: TimeLogWhereUniqueInput
    data: XOR<TimeLogUpdateWithoutMemberInput, TimeLogUncheckedUpdateWithoutMemberInput>
  }

  export type TimeLogUpdateManyWithWhereWithoutMemberInput = {
    where: TimeLogScalarWhereInput
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyWithoutMemberInput>
  }

  export type TimeLogScalarWhereInput = {
    AND?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
    OR?: TimeLogScalarWhereInput[]
    NOT?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
    id?: StringFilter<"TimeLog"> | string
    description?: StringNullableFilter<"TimeLog"> | string | null
    startTime?: DateTimeFilter<"TimeLog"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    taskId?: StringFilter<"TimeLog"> | string
    memberId?: StringFilter<"TimeLog"> | string
  }

  export type UserStoryUpsertWithWhereUniqueWithoutCreatorInput = {
    where: UserStoryWhereUniqueInput
    update: XOR<UserStoryUpdateWithoutCreatorInput, UserStoryUncheckedUpdateWithoutCreatorInput>
    create: XOR<UserStoryCreateWithoutCreatorInput, UserStoryUncheckedCreateWithoutCreatorInput>
  }

  export type UserStoryUpdateWithWhereUniqueWithoutCreatorInput = {
    where: UserStoryWhereUniqueInput
    data: XOR<UserStoryUpdateWithoutCreatorInput, UserStoryUncheckedUpdateWithoutCreatorInput>
  }

  export type UserStoryUpdateManyWithWhereWithoutCreatorInput = {
    where: UserStoryScalarWhereInput
    data: XOR<UserStoryUpdateManyMutationInput, UserStoryUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ThemaUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ThemaWhereUniqueInput
    update: XOR<ThemaUpdateWithoutCreatorInput, ThemaUncheckedUpdateWithoutCreatorInput>
    create: XOR<ThemaCreateWithoutCreatorInput, ThemaUncheckedCreateWithoutCreatorInput>
  }

  export type ThemaUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ThemaWhereUniqueInput
    data: XOR<ThemaUpdateWithoutCreatorInput, ThemaUncheckedUpdateWithoutCreatorInput>
  }

  export type ThemaUpdateManyWithWhereWithoutCreatorInput = {
    where: ThemaScalarWhereInput
    data: XOR<ThemaUpdateManyMutationInput, ThemaUncheckedUpdateManyWithoutCreatorInput>
  }

  export type EpicUpsertWithWhereUniqueWithoutCreatorInput = {
    where: EpicWhereUniqueInput
    update: XOR<EpicUpdateWithoutCreatorInput, EpicUncheckedUpdateWithoutCreatorInput>
    create: XOR<EpicCreateWithoutCreatorInput, EpicUncheckedCreateWithoutCreatorInput>
  }

  export type EpicUpdateWithWhereUniqueWithoutCreatorInput = {
    where: EpicWhereUniqueInput
    data: XOR<EpicUpdateWithoutCreatorInput, EpicUncheckedUpdateWithoutCreatorInput>
  }

  export type EpicUpdateManyWithWhereWithoutCreatorInput = {
    where: EpicScalarWhereInput
    data: XOR<EpicUpdateManyMutationInput, EpicUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SprintUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SprintWhereUniqueInput
    update: XOR<SprintUpdateWithoutCreatorInput, SprintUncheckedUpdateWithoutCreatorInput>
    create: XOR<SprintCreateWithoutCreatorInput, SprintUncheckedCreateWithoutCreatorInput>
  }

  export type SprintUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SprintWhereUniqueInput
    data: XOR<SprintUpdateWithoutCreatorInput, SprintUncheckedUpdateWithoutCreatorInput>
  }

  export type SprintUpdateManyWithWhereWithoutCreatorInput = {
    where: SprintScalarWhereInput
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutMemberInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutMemberInput, ActivityLogUncheckedUpdateWithoutMemberInput>
    create: XOR<ActivityLogCreateWithoutMemberInput, ActivityLogUncheckedCreateWithoutMemberInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutMemberInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutMemberInput, ActivityLogUncheckedUpdateWithoutMemberInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutMemberInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutMemberInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    action?: EnumActionTypeFilter<"ActivityLog"> | $Enums.ActionType
    entityId?: StringFilter<"ActivityLog"> | string
    timestamp?: DateTimeFilter<"ActivityLog"> | Date | string
    memberId?: StringFilter<"ActivityLog"> | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCreatorInput, ProjectUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCreatorInput, ProjectUncheckedUpdateWithoutCreatorInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCreatorInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    image?: StringNullableFilter<"Project"> | string | null
    status?: EnumStatusFilter<"Project"> | $Enums.Status
    priority?: IntFilter<"Project"> | number
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    creatorId?: StringNullableFilter<"Project"> | string | null
  }

  export type ProjectCreateWithoutThemasInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    epics?: EpicCreateNestedManyWithoutProjectInput
    userStories?: UserStoryCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    folders?: FolderCreateNestedManyWithoutProjectInput
    files?: FileCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    creator?: MemberCreateNestedOneWithoutCreatedProjectsInput
  }

  export type ProjectUncheckedCreateWithoutThemasInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId?: string | null
    epics?: EpicUncheckedCreateNestedManyWithoutProjectInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    folders?: FolderUncheckedCreateNestedManyWithoutProjectInput
    files?: FileUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutThemasInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutThemasInput, ProjectUncheckedCreateWithoutThemasInput>
  }

  export type MemberCreateWithoutThemasInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutThemasInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutThemasInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutThemasInput, MemberUncheckedCreateWithoutThemasInput>
  }

  export type TaskCreateWithoutThemaInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userStory?: UserStoryCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    assignee?: MemberCreateNestedOneWithoutTasksInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    dependencies?: TaskCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskCreateNestedManyWithoutDependenciesInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutThemaInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userStoryId?: string | null
    sprintId?: string | null
    assigneeId?: string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    dependencies?: TaskUncheckedCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskUncheckedCreateNestedManyWithoutDependenciesInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutThemaInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutThemaInput, TaskUncheckedCreateWithoutThemaInput>
  }

  export type TaskCreateManyThemaInputEnvelope = {
    data: TaskCreateManyThemaInput | TaskCreateManyThemaInput[]
  }

  export type CommentCreateWithoutThemaInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: MemberCreateNestedOneWithoutCommentsInput
    project?: ProjectCreateNestedOneWithoutCommentsInput
    epic?: EpicCreateNestedOneWithoutCommentsInput
    userStory?: UserStoryCreateNestedOneWithoutCommentsInput
    task?: TaskCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutThemaInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    projectId?: string | null
    epicId?: string | null
    userStoryId?: string | null
    taskId?: string | null
  }

  export type CommentCreateOrConnectWithoutThemaInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutThemaInput, CommentUncheckedCreateWithoutThemaInput>
  }

  export type CommentCreateManyThemaInputEnvelope = {
    data: CommentCreateManyThemaInput | CommentCreateManyThemaInput[]
  }

  export type ProjectUpsertWithoutThemasInput = {
    update: XOR<ProjectUpdateWithoutThemasInput, ProjectUncheckedUpdateWithoutThemasInput>
    create: XOR<ProjectCreateWithoutThemasInput, ProjectUncheckedCreateWithoutThemasInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutThemasInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutThemasInput, ProjectUncheckedUpdateWithoutThemasInput>
  }

  export type ProjectUpdateWithoutThemasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    epics?: EpicUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    folders?: FolderUpdateManyWithoutProjectNestedInput
    files?: FileUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    creator?: MemberUpdateOneWithoutCreatedProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutThemasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    epics?: EpicUncheckedUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    folders?: FolderUncheckedUpdateManyWithoutProjectNestedInput
    files?: FileUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type MemberUpsertWithoutThemasInput = {
    update: XOR<MemberUpdateWithoutThemasInput, MemberUncheckedUpdateWithoutThemasInput>
    create: XOR<MemberCreateWithoutThemasInput, MemberUncheckedCreateWithoutThemasInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutThemasInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutThemasInput, MemberUncheckedUpdateWithoutThemasInput>
  }

  export type MemberUpdateWithoutThemasInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutThemasInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutThemaInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutThemaInput, TaskUncheckedUpdateWithoutThemaInput>
    create: XOR<TaskCreateWithoutThemaInput, TaskUncheckedCreateWithoutThemaInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutThemaInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutThemaInput, TaskUncheckedUpdateWithoutThemaInput>
  }

  export type TaskUpdateManyWithWhereWithoutThemaInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutThemaInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutThemaInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutThemaInput, CommentUncheckedUpdateWithoutThemaInput>
    create: XOR<CommentCreateWithoutThemaInput, CommentUncheckedCreateWithoutThemaInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutThemaInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutThemaInput, CommentUncheckedUpdateWithoutThemaInput>
  }

  export type CommentUpdateManyWithWhereWithoutThemaInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutThemaInput>
  }

  export type ProjectCreateWithoutEpicsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themas?: ThemaCreateNestedManyWithoutProjectInput
    userStories?: UserStoryCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    folders?: FolderCreateNestedManyWithoutProjectInput
    files?: FileCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    creator?: MemberCreateNestedOneWithoutCreatedProjectsInput
  }

  export type ProjectUncheckedCreateWithoutEpicsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId?: string | null
    themas?: ThemaUncheckedCreateNestedManyWithoutProjectInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    folders?: FolderUncheckedCreateNestedManyWithoutProjectInput
    files?: FileUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutEpicsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutEpicsInput, ProjectUncheckedCreateWithoutEpicsInput>
  }

  export type MemberCreateWithoutEpicsInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutEpicsInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutEpicsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutEpicsInput, MemberUncheckedCreateWithoutEpicsInput>
  }

  export type UserStoryCreateWithoutEpicInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUserStoriesInput
    creator: MemberCreateNestedOneWithoutUserStoriesInput
    sprint?: SprintCreateNestedOneWithoutUserStoriesInput
    tasks?: TaskCreateNestedManyWithoutUserStoryInput
    comments?: CommentCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryUncheckedCreateWithoutEpicInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    sprintId?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutUserStoryInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryCreateOrConnectWithoutEpicInput = {
    where: UserStoryWhereUniqueInput
    create: XOR<UserStoryCreateWithoutEpicInput, UserStoryUncheckedCreateWithoutEpicInput>
  }

  export type UserStoryCreateManyEpicInputEnvelope = {
    data: UserStoryCreateManyEpicInput | UserStoryCreateManyEpicInput[]
  }

  export type CommentCreateWithoutEpicInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: MemberCreateNestedOneWithoutCommentsInput
    project?: ProjectCreateNestedOneWithoutCommentsInput
    thema?: ThemaCreateNestedOneWithoutCommentsInput
    userStory?: UserStoryCreateNestedOneWithoutCommentsInput
    task?: TaskCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutEpicInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    projectId?: string | null
    themaId?: string | null
    userStoryId?: string | null
    taskId?: string | null
  }

  export type CommentCreateOrConnectWithoutEpicInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutEpicInput, CommentUncheckedCreateWithoutEpicInput>
  }

  export type CommentCreateManyEpicInputEnvelope = {
    data: CommentCreateManyEpicInput | CommentCreateManyEpicInput[]
  }

  export type ProjectUpsertWithoutEpicsInput = {
    update: XOR<ProjectUpdateWithoutEpicsInput, ProjectUncheckedUpdateWithoutEpicsInput>
    create: XOR<ProjectCreateWithoutEpicsInput, ProjectUncheckedCreateWithoutEpicsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutEpicsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutEpicsInput, ProjectUncheckedUpdateWithoutEpicsInput>
  }

  export type ProjectUpdateWithoutEpicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themas?: ThemaUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    folders?: FolderUpdateManyWithoutProjectNestedInput
    files?: FileUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    creator?: MemberUpdateOneWithoutCreatedProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutEpicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    themas?: ThemaUncheckedUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    folders?: FolderUncheckedUpdateManyWithoutProjectNestedInput
    files?: FileUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type MemberUpsertWithoutEpicsInput = {
    update: XOR<MemberUpdateWithoutEpicsInput, MemberUncheckedUpdateWithoutEpicsInput>
    create: XOR<MemberCreateWithoutEpicsInput, MemberUncheckedCreateWithoutEpicsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutEpicsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutEpicsInput, MemberUncheckedUpdateWithoutEpicsInput>
  }

  export type MemberUpdateWithoutEpicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutEpicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserStoryUpsertWithWhereUniqueWithoutEpicInput = {
    where: UserStoryWhereUniqueInput
    update: XOR<UserStoryUpdateWithoutEpicInput, UserStoryUncheckedUpdateWithoutEpicInput>
    create: XOR<UserStoryCreateWithoutEpicInput, UserStoryUncheckedCreateWithoutEpicInput>
  }

  export type UserStoryUpdateWithWhereUniqueWithoutEpicInput = {
    where: UserStoryWhereUniqueInput
    data: XOR<UserStoryUpdateWithoutEpicInput, UserStoryUncheckedUpdateWithoutEpicInput>
  }

  export type UserStoryUpdateManyWithWhereWithoutEpicInput = {
    where: UserStoryScalarWhereInput
    data: XOR<UserStoryUpdateManyMutationInput, UserStoryUncheckedUpdateManyWithoutEpicInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutEpicInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutEpicInput, CommentUncheckedUpdateWithoutEpicInput>
    create: XOR<CommentCreateWithoutEpicInput, CommentUncheckedCreateWithoutEpicInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutEpicInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutEpicInput, CommentUncheckedUpdateWithoutEpicInput>
  }

  export type CommentUpdateManyWithWhereWithoutEpicInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutEpicInput>
  }

  export type ProjectCreateWithoutUserStoriesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themas?: ThemaCreateNestedManyWithoutProjectInput
    epics?: EpicCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    folders?: FolderCreateNestedManyWithoutProjectInput
    files?: FileCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    creator?: MemberCreateNestedOneWithoutCreatedProjectsInput
  }

  export type ProjectUncheckedCreateWithoutUserStoriesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId?: string | null
    themas?: ThemaUncheckedCreateNestedManyWithoutProjectInput
    epics?: EpicUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    folders?: FolderUncheckedCreateNestedManyWithoutProjectInput
    files?: FileUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUserStoriesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserStoriesInput, ProjectUncheckedCreateWithoutUserStoriesInput>
  }

  export type EpicCreateWithoutUserStoriesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutEpicsInput
    creator: MemberCreateNestedOneWithoutEpicsInput
    comments?: CommentCreateNestedManyWithoutEpicInput
  }

  export type EpicUncheckedCreateWithoutUserStoriesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    comments?: CommentUncheckedCreateNestedManyWithoutEpicInput
  }

  export type EpicCreateOrConnectWithoutUserStoriesInput = {
    where: EpicWhereUniqueInput
    create: XOR<EpicCreateWithoutUserStoriesInput, EpicUncheckedCreateWithoutUserStoriesInput>
  }

  export type MemberCreateWithoutUserStoriesInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutUserStoriesInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutUserStoriesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserStoriesInput, MemberUncheckedCreateWithoutUserStoriesInput>
  }

  export type SprintCreateWithoutUserStoriesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    creator: MemberCreateNestedOneWithoutSprintsInput
    tasks?: TaskCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskCreateNestedManyWithoutSprintInput
    files?: FileCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutUserStoriesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutSprintInput
    files?: FileUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutUserStoriesInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutUserStoriesInput, SprintUncheckedCreateWithoutUserStoriesInput>
  }

  export type TaskCreateWithoutUserStoryInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thema?: ThemaCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    assignee?: MemberCreateNestedOneWithoutTasksInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    dependencies?: TaskCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskCreateNestedManyWithoutDependenciesInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutUserStoryInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    sprintId?: string | null
    assigneeId?: string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    dependencies?: TaskUncheckedCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskUncheckedCreateNestedManyWithoutDependenciesInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutUserStoryInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutUserStoryInput, TaskUncheckedCreateWithoutUserStoryInput>
  }

  export type TaskCreateManyUserStoryInputEnvelope = {
    data: TaskCreateManyUserStoryInput | TaskCreateManyUserStoryInput[]
  }

  export type CommentCreateWithoutUserStoryInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: MemberCreateNestedOneWithoutCommentsInput
    project?: ProjectCreateNestedOneWithoutCommentsInput
    thema?: ThemaCreateNestedOneWithoutCommentsInput
    epic?: EpicCreateNestedOneWithoutCommentsInput
    task?: TaskCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserStoryInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    projectId?: string | null
    themaId?: string | null
    epicId?: string | null
    taskId?: string | null
  }

  export type CommentCreateOrConnectWithoutUserStoryInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserStoryInput, CommentUncheckedCreateWithoutUserStoryInput>
  }

  export type CommentCreateManyUserStoryInputEnvelope = {
    data: CommentCreateManyUserStoryInput | CommentCreateManyUserStoryInput[]
  }

  export type ProjectUpsertWithoutUserStoriesInput = {
    update: XOR<ProjectUpdateWithoutUserStoriesInput, ProjectUncheckedUpdateWithoutUserStoriesInput>
    create: XOR<ProjectCreateWithoutUserStoriesInput, ProjectUncheckedCreateWithoutUserStoriesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutUserStoriesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutUserStoriesInput, ProjectUncheckedUpdateWithoutUserStoriesInput>
  }

  export type ProjectUpdateWithoutUserStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themas?: ThemaUpdateManyWithoutProjectNestedInput
    epics?: EpicUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    folders?: FolderUpdateManyWithoutProjectNestedInput
    files?: FileUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    creator?: MemberUpdateOneWithoutCreatedProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUserStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    themas?: ThemaUncheckedUpdateManyWithoutProjectNestedInput
    epics?: EpicUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    folders?: FolderUncheckedUpdateManyWithoutProjectNestedInput
    files?: FileUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type EpicUpsertWithoutUserStoriesInput = {
    update: XOR<EpicUpdateWithoutUserStoriesInput, EpicUncheckedUpdateWithoutUserStoriesInput>
    create: XOR<EpicCreateWithoutUserStoriesInput, EpicUncheckedCreateWithoutUserStoriesInput>
    where?: EpicWhereInput
  }

  export type EpicUpdateToOneWithWhereWithoutUserStoriesInput = {
    where?: EpicWhereInput
    data: XOR<EpicUpdateWithoutUserStoriesInput, EpicUncheckedUpdateWithoutUserStoriesInput>
  }

  export type EpicUpdateWithoutUserStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutEpicsNestedInput
    creator?: MemberUpdateOneRequiredWithoutEpicsNestedInput
    comments?: CommentUpdateManyWithoutEpicNestedInput
  }

  export type EpicUncheckedUpdateWithoutUserStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    comments?: CommentUncheckedUpdateManyWithoutEpicNestedInput
  }

  export type MemberUpsertWithoutUserStoriesInput = {
    update: XOR<MemberUpdateWithoutUserStoriesInput, MemberUncheckedUpdateWithoutUserStoriesInput>
    create: XOR<MemberCreateWithoutUserStoriesInput, MemberUncheckedCreateWithoutUserStoriesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutUserStoriesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutUserStoriesInput, MemberUncheckedUpdateWithoutUserStoriesInput>
  }

  export type MemberUpdateWithoutUserStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SprintUpsertWithoutUserStoriesInput = {
    update: XOR<SprintUpdateWithoutUserStoriesInput, SprintUncheckedUpdateWithoutUserStoriesInput>
    create: XOR<SprintCreateWithoutUserStoriesInput, SprintUncheckedCreateWithoutUserStoriesInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutUserStoriesInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutUserStoriesInput, SprintUncheckedUpdateWithoutUserStoriesInput>
  }

  export type SprintUpdateWithoutUserStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    creator?: MemberUpdateOneRequiredWithoutSprintsNestedInput
    tasks?: TaskUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUpdateManyWithoutSprintNestedInput
    files?: FileUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutUserStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutSprintNestedInput
    files?: FileUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutUserStoryInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutUserStoryInput, TaskUncheckedUpdateWithoutUserStoryInput>
    create: XOR<TaskCreateWithoutUserStoryInput, TaskUncheckedCreateWithoutUserStoryInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutUserStoryInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutUserStoryInput, TaskUncheckedUpdateWithoutUserStoryInput>
  }

  export type TaskUpdateManyWithWhereWithoutUserStoryInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutUserStoryInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutUserStoryInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserStoryInput, CommentUncheckedUpdateWithoutUserStoryInput>
    create: XOR<CommentCreateWithoutUserStoryInput, CommentUncheckedCreateWithoutUserStoryInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserStoryInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserStoryInput, CommentUncheckedUpdateWithoutUserStoryInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserStoryInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserStoryInput>
  }

  export type ProjectCreateWithoutSprintsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themas?: ThemaCreateNestedManyWithoutProjectInput
    epics?: EpicCreateNestedManyWithoutProjectInput
    userStories?: UserStoryCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    folders?: FolderCreateNestedManyWithoutProjectInput
    files?: FileCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    creator?: MemberCreateNestedOneWithoutCreatedProjectsInput
  }

  export type ProjectUncheckedCreateWithoutSprintsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId?: string | null
    themas?: ThemaUncheckedCreateNestedManyWithoutProjectInput
    epics?: EpicUncheckedCreateNestedManyWithoutProjectInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    folders?: FolderUncheckedCreateNestedManyWithoutProjectInput
    files?: FileUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSprintsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
  }

  export type MemberCreateWithoutSprintsInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutSprintsInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutSprintsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutSprintsInput, MemberUncheckedCreateWithoutSprintsInput>
  }

  export type UserStoryCreateWithoutSprintInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUserStoriesInput
    epic?: EpicCreateNestedOneWithoutUserStoriesInput
    creator: MemberCreateNestedOneWithoutUserStoriesInput
    tasks?: TaskCreateNestedManyWithoutUserStoryInput
    comments?: CommentCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryUncheckedCreateWithoutSprintInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    epicId?: string | null
    creatorId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutUserStoryInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryCreateOrConnectWithoutSprintInput = {
    where: UserStoryWhereUniqueInput
    create: XOR<UserStoryCreateWithoutSprintInput, UserStoryUncheckedCreateWithoutSprintInput>
  }

  export type UserStoryCreateManySprintInputEnvelope = {
    data: UserStoryCreateManySprintInput | UserStoryCreateManySprintInput[]
  }

  export type TaskCreateWithoutSprintInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thema?: ThemaCreateNestedOneWithoutTasksInput
    userStory?: UserStoryCreateNestedOneWithoutTasksInput
    assignee?: MemberCreateNestedOneWithoutTasksInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    dependencies?: TaskCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskCreateNestedManyWithoutDependenciesInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutSprintInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    userStoryId?: string | null
    assigneeId?: string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    dependencies?: TaskUncheckedCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskUncheckedCreateNestedManyWithoutDependenciesInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutSprintInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput>
  }

  export type TaskCreateManySprintInputEnvelope = {
    data: TaskCreateManySprintInput | TaskCreateManySprintInput[]
  }

  export type SubtaskCreateWithoutSprintInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutSubtasksInput
    assignee?: MemberCreateNestedOneWithoutSubtasksInput
    files?: FileCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateWithoutSprintInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    taskId: string
    assigneeId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskCreateOrConnectWithoutSprintInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutSprintInput, SubtaskUncheckedCreateWithoutSprintInput>
  }

  export type SubtaskCreateManySprintInputEnvelope = {
    data: SubtaskCreateManySprintInput | SubtaskCreateManySprintInput[]
  }

  export type FileCreateWithoutSprintInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: FolderCreateNestedOneWithoutFilesInput
    project: ProjectCreateNestedOneWithoutFilesInput
    subtask?: SubtaskCreateNestedOneWithoutFilesInput
    uploader: MemberCreateNestedOneWithoutFilesInput
    dependencies?: DependencyCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationCreateNestedManyWithoutToFileInput
  }

  export type FileUncheckedCreateWithoutSprintInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    projectId: string
    subtaskId?: string | null
    uploaderId: string
    dependencies?: DependencyUncheckedCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationUncheckedCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationUncheckedCreateNestedManyWithoutToFileInput
  }

  export type FileCreateOrConnectWithoutSprintInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutSprintInput, FileUncheckedCreateWithoutSprintInput>
  }

  export type FileCreateManySprintInputEnvelope = {
    data: FileCreateManySprintInput | FileCreateManySprintInput[]
  }

  export type ProjectUpsertWithoutSprintsInput = {
    update: XOR<ProjectUpdateWithoutSprintsInput, ProjectUncheckedUpdateWithoutSprintsInput>
    create: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSprintsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSprintsInput, ProjectUncheckedUpdateWithoutSprintsInput>
  }

  export type ProjectUpdateWithoutSprintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themas?: ThemaUpdateManyWithoutProjectNestedInput
    epics?: EpicUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    folders?: FolderUpdateManyWithoutProjectNestedInput
    files?: FileUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    creator?: MemberUpdateOneWithoutCreatedProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSprintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    themas?: ThemaUncheckedUpdateManyWithoutProjectNestedInput
    epics?: EpicUncheckedUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    folders?: FolderUncheckedUpdateManyWithoutProjectNestedInput
    files?: FileUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type MemberUpsertWithoutSprintsInput = {
    update: XOR<MemberUpdateWithoutSprintsInput, MemberUncheckedUpdateWithoutSprintsInput>
    create: XOR<MemberCreateWithoutSprintsInput, MemberUncheckedCreateWithoutSprintsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutSprintsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutSprintsInput, MemberUncheckedUpdateWithoutSprintsInput>
  }

  export type MemberUpdateWithoutSprintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutSprintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserStoryUpsertWithWhereUniqueWithoutSprintInput = {
    where: UserStoryWhereUniqueInput
    update: XOR<UserStoryUpdateWithoutSprintInput, UserStoryUncheckedUpdateWithoutSprintInput>
    create: XOR<UserStoryCreateWithoutSprintInput, UserStoryUncheckedCreateWithoutSprintInput>
  }

  export type UserStoryUpdateWithWhereUniqueWithoutSprintInput = {
    where: UserStoryWhereUniqueInput
    data: XOR<UserStoryUpdateWithoutSprintInput, UserStoryUncheckedUpdateWithoutSprintInput>
  }

  export type UserStoryUpdateManyWithWhereWithoutSprintInput = {
    where: UserStoryScalarWhereInput
    data: XOR<UserStoryUpdateManyMutationInput, UserStoryUncheckedUpdateManyWithoutSprintInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutSprintInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutSprintInput, TaskUncheckedUpdateWithoutSprintInput>
    create: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutSprintInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutSprintInput, TaskUncheckedUpdateWithoutSprintInput>
  }

  export type TaskUpdateManyWithWhereWithoutSprintInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutSprintInput>
  }

  export type SubtaskUpsertWithWhereUniqueWithoutSprintInput = {
    where: SubtaskWhereUniqueInput
    update: XOR<SubtaskUpdateWithoutSprintInput, SubtaskUncheckedUpdateWithoutSprintInput>
    create: XOR<SubtaskCreateWithoutSprintInput, SubtaskUncheckedCreateWithoutSprintInput>
  }

  export type SubtaskUpdateWithWhereUniqueWithoutSprintInput = {
    where: SubtaskWhereUniqueInput
    data: XOR<SubtaskUpdateWithoutSprintInput, SubtaskUncheckedUpdateWithoutSprintInput>
  }

  export type SubtaskUpdateManyWithWhereWithoutSprintInput = {
    where: SubtaskScalarWhereInput
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyWithoutSprintInput>
  }

  export type FileUpsertWithWhereUniqueWithoutSprintInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutSprintInput, FileUncheckedUpdateWithoutSprintInput>
    create: XOR<FileCreateWithoutSprintInput, FileUncheckedCreateWithoutSprintInput>
  }

  export type FileUpdateWithWhereUniqueWithoutSprintInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutSprintInput, FileUncheckedUpdateWithoutSprintInput>
  }

  export type FileUpdateManyWithWhereWithoutSprintInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutSprintInput>
  }

  export type ThemaCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutThemasInput
    creator: MemberCreateNestedOneWithoutThemasInput
    comments?: CommentCreateNestedManyWithoutThemaInput
  }

  export type ThemaUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    comments?: CommentUncheckedCreateNestedManyWithoutThemaInput
  }

  export type ThemaCreateOrConnectWithoutTasksInput = {
    where: ThemaWhereUniqueInput
    create: XOR<ThemaCreateWithoutTasksInput, ThemaUncheckedCreateWithoutTasksInput>
  }

  export type UserStoryCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUserStoriesInput
    epic?: EpicCreateNestedOneWithoutUserStoriesInput
    creator: MemberCreateNestedOneWithoutUserStoriesInput
    sprint?: SprintCreateNestedOneWithoutUserStoriesInput
    comments?: CommentCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    epicId?: string | null
    creatorId: string
    sprintId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryCreateOrConnectWithoutTasksInput = {
    where: UserStoryWhereUniqueInput
    create: XOR<UserStoryCreateWithoutTasksInput, UserStoryUncheckedCreateWithoutTasksInput>
  }

  export type SprintCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    creator: MemberCreateNestedOneWithoutSprintsInput
    userStories?: UserStoryCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskCreateNestedManyWithoutSprintInput
    files?: FileCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    userStories?: UserStoryUncheckedCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutSprintInput
    files?: FileUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutTasksInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutTasksInput, SprintUncheckedCreateWithoutTasksInput>
  }

  export type MemberCreateWithoutTasksInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutTasksInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutTasksInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutTasksInput, MemberUncheckedCreateWithoutTasksInput>
  }

  export type SubtaskCreateWithoutTaskInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sprint?: SprintCreateNestedOneWithoutSubtasksInput
    assignee?: MemberCreateNestedOneWithoutSubtasksInput
    files?: FileCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateWithoutTaskInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sprintId?: string | null
    assigneeId?: string | null
    files?: FileUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskCreateOrConnectWithoutTaskInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput>
  }

  export type SubtaskCreateManyTaskInputEnvelope = {
    data: SubtaskCreateManyTaskInput | SubtaskCreateManyTaskInput[]
  }

  export type TaskCreateWithoutBlockedByInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thema?: ThemaCreateNestedOneWithoutTasksInput
    userStory?: UserStoryCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    assignee?: MemberCreateNestedOneWithoutTasksInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    dependencies?: TaskCreateNestedManyWithoutBlockedByInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutBlockedByInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    userStoryId?: string | null
    sprintId?: string | null
    assigneeId?: string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    dependencies?: TaskUncheckedCreateNestedManyWithoutBlockedByInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutBlockedByInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutBlockedByInput, TaskUncheckedCreateWithoutBlockedByInput>
  }

  export type TaskCreateWithoutDependenciesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thema?: ThemaCreateNestedOneWithoutTasksInput
    userStory?: UserStoryCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    assignee?: MemberCreateNestedOneWithoutTasksInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    blockedBy?: TaskCreateNestedManyWithoutDependenciesInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutDependenciesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    userStoryId?: string | null
    sprintId?: string | null
    assigneeId?: string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    blockedBy?: TaskUncheckedCreateNestedManyWithoutDependenciesInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutDependenciesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
  }

  export type CommentCreateWithoutTaskInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: MemberCreateNestedOneWithoutCommentsInput
    project?: ProjectCreateNestedOneWithoutCommentsInput
    thema?: ThemaCreateNestedOneWithoutCommentsInput
    epic?: EpicCreateNestedOneWithoutCommentsInput
    userStory?: UserStoryCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutTaskInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    projectId?: string | null
    themaId?: string | null
    epicId?: string | null
    userStoryId?: string | null
  }

  export type CommentCreateOrConnectWithoutTaskInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
  }

  export type CommentCreateManyTaskInputEnvelope = {
    data: CommentCreateManyTaskInput | CommentCreateManyTaskInput[]
  }

  export type TimeLogCreateWithoutTaskInput = {
    id?: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    member: MemberCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateWithoutTaskInput = {
    id?: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    memberId: string
  }

  export type TimeLogCreateOrConnectWithoutTaskInput = {
    where: TimeLogWhereUniqueInput
    create: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput>
  }

  export type TimeLogCreateManyTaskInputEnvelope = {
    data: TimeLogCreateManyTaskInput | TimeLogCreateManyTaskInput[]
  }

  export type ThemaUpsertWithoutTasksInput = {
    update: XOR<ThemaUpdateWithoutTasksInput, ThemaUncheckedUpdateWithoutTasksInput>
    create: XOR<ThemaCreateWithoutTasksInput, ThemaUncheckedCreateWithoutTasksInput>
    where?: ThemaWhereInput
  }

  export type ThemaUpdateToOneWithWhereWithoutTasksInput = {
    where?: ThemaWhereInput
    data: XOR<ThemaUpdateWithoutTasksInput, ThemaUncheckedUpdateWithoutTasksInput>
  }

  export type ThemaUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutThemasNestedInput
    creator?: MemberUpdateOneRequiredWithoutThemasNestedInput
    comments?: CommentUpdateManyWithoutThemaNestedInput
  }

  export type ThemaUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    comments?: CommentUncheckedUpdateManyWithoutThemaNestedInput
  }

  export type UserStoryUpsertWithoutTasksInput = {
    update: XOR<UserStoryUpdateWithoutTasksInput, UserStoryUncheckedUpdateWithoutTasksInput>
    create: XOR<UserStoryCreateWithoutTasksInput, UserStoryUncheckedCreateWithoutTasksInput>
    where?: UserStoryWhereInput
  }

  export type UserStoryUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserStoryWhereInput
    data: XOR<UserStoryUpdateWithoutTasksInput, UserStoryUncheckedUpdateWithoutTasksInput>
  }

  export type UserStoryUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUserStoriesNestedInput
    epic?: EpicUpdateOneWithoutUserStoriesNestedInput
    creator?: MemberUpdateOneRequiredWithoutUserStoriesNestedInput
    sprint?: SprintUpdateOneWithoutUserStoriesNestedInput
    comments?: CommentUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserStoryNestedInput
  }

  export type SprintUpsertWithoutTasksInput = {
    update: XOR<SprintUpdateWithoutTasksInput, SprintUncheckedUpdateWithoutTasksInput>
    create: XOR<SprintCreateWithoutTasksInput, SprintUncheckedCreateWithoutTasksInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutTasksInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutTasksInput, SprintUncheckedUpdateWithoutTasksInput>
  }

  export type SprintUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    creator?: MemberUpdateOneRequiredWithoutSprintsNestedInput
    userStories?: UserStoryUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUpdateManyWithoutSprintNestedInput
    files?: FileUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    userStories?: UserStoryUncheckedUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutSprintNestedInput
    files?: FileUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type MemberUpsertWithoutTasksInput = {
    update: XOR<MemberUpdateWithoutTasksInput, MemberUncheckedUpdateWithoutTasksInput>
    create: XOR<MemberCreateWithoutTasksInput, MemberUncheckedCreateWithoutTasksInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutTasksInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutTasksInput, MemberUncheckedUpdateWithoutTasksInput>
  }

  export type MemberUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SubtaskUpsertWithWhereUniqueWithoutTaskInput = {
    where: SubtaskWhereUniqueInput
    update: XOR<SubtaskUpdateWithoutTaskInput, SubtaskUncheckedUpdateWithoutTaskInput>
    create: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput>
  }

  export type SubtaskUpdateWithWhereUniqueWithoutTaskInput = {
    where: SubtaskWhereUniqueInput
    data: XOR<SubtaskUpdateWithoutTaskInput, SubtaskUncheckedUpdateWithoutTaskInput>
  }

  export type SubtaskUpdateManyWithWhereWithoutTaskInput = {
    where: SubtaskScalarWhereInput
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutBlockedByInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutBlockedByInput, TaskUncheckedUpdateWithoutBlockedByInput>
    create: XOR<TaskCreateWithoutBlockedByInput, TaskUncheckedCreateWithoutBlockedByInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutBlockedByInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutBlockedByInput, TaskUncheckedUpdateWithoutBlockedByInput>
  }

  export type TaskUpdateManyWithWhereWithoutBlockedByInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutBlockedByInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutDependenciesInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutDependenciesInput, TaskUncheckedUpdateWithoutDependenciesInput>
    create: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutDependenciesInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutDependenciesInput, TaskUncheckedUpdateWithoutDependenciesInput>
  }

  export type TaskUpdateManyWithWhereWithoutDependenciesInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutDependenciesInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>
  }

  export type CommentUpdateManyWithWhereWithoutTaskInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TimeLogUpsertWithWhereUniqueWithoutTaskInput = {
    where: TimeLogWhereUniqueInput
    update: XOR<TimeLogUpdateWithoutTaskInput, TimeLogUncheckedUpdateWithoutTaskInput>
    create: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput>
  }

  export type TimeLogUpdateWithWhereUniqueWithoutTaskInput = {
    where: TimeLogWhereUniqueInput
    data: XOR<TimeLogUpdateWithoutTaskInput, TimeLogUncheckedUpdateWithoutTaskInput>
  }

  export type TimeLogUpdateManyWithWhereWithoutTaskInput = {
    where: TimeLogScalarWhereInput
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskCreateWithoutSubtasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thema?: ThemaCreateNestedOneWithoutTasksInput
    userStory?: UserStoryCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    assignee?: MemberCreateNestedOneWithoutTasksInput
    dependencies?: TaskCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskCreateNestedManyWithoutDependenciesInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutSubtasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    userStoryId?: string | null
    sprintId?: string | null
    assigneeId?: string | null
    dependencies?: TaskUncheckedCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskUncheckedCreateNestedManyWithoutDependenciesInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutSubtasksInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
  }

  export type SprintCreateWithoutSubtasksInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    creator: MemberCreateNestedOneWithoutSprintsInput
    userStories?: UserStoryCreateNestedManyWithoutSprintInput
    tasks?: TaskCreateNestedManyWithoutSprintInput
    files?: FileCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutSubtasksInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    userStories?: UserStoryUncheckedCreateNestedManyWithoutSprintInput
    tasks?: TaskUncheckedCreateNestedManyWithoutSprintInput
    files?: FileUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutSubtasksInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutSubtasksInput, SprintUncheckedCreateWithoutSubtasksInput>
  }

  export type MemberCreateWithoutSubtasksInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutSubtasksInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutSubtasksInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutSubtasksInput, MemberUncheckedCreateWithoutSubtasksInput>
  }

  export type FileCreateWithoutSubtaskInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: FolderCreateNestedOneWithoutFilesInput
    project: ProjectCreateNestedOneWithoutFilesInput
    sprint?: SprintCreateNestedOneWithoutFilesInput
    uploader: MemberCreateNestedOneWithoutFilesInput
    dependencies?: DependencyCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationCreateNestedManyWithoutToFileInput
  }

  export type FileUncheckedCreateWithoutSubtaskInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    projectId: string
    sprintId?: string | null
    uploaderId: string
    dependencies?: DependencyUncheckedCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationUncheckedCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationUncheckedCreateNestedManyWithoutToFileInput
  }

  export type FileCreateOrConnectWithoutSubtaskInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutSubtaskInput, FileUncheckedCreateWithoutSubtaskInput>
  }

  export type FileCreateManySubtaskInputEnvelope = {
    data: FileCreateManySubtaskInput | FileCreateManySubtaskInput[]
  }

  export type TaskUpsertWithoutSubtasksInput = {
    update: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>
    create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type TaskUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thema?: ThemaUpdateOneWithoutTasksNestedInput
    userStory?: UserStoryUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    assignee?: MemberUpdateOneWithoutTasksNestedInput
    dependencies?: TaskUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: TaskUncheckedUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUncheckedUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type SprintUpsertWithoutSubtasksInput = {
    update: XOR<SprintUpdateWithoutSubtasksInput, SprintUncheckedUpdateWithoutSubtasksInput>
    create: XOR<SprintCreateWithoutSubtasksInput, SprintUncheckedCreateWithoutSubtasksInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutSubtasksInput, SprintUncheckedUpdateWithoutSubtasksInput>
  }

  export type SprintUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    creator?: MemberUpdateOneRequiredWithoutSprintsNestedInput
    userStories?: UserStoryUpdateManyWithoutSprintNestedInput
    tasks?: TaskUpdateManyWithoutSprintNestedInput
    files?: FileUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    userStories?: UserStoryUncheckedUpdateManyWithoutSprintNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutSprintNestedInput
    files?: FileUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type MemberUpsertWithoutSubtasksInput = {
    update: XOR<MemberUpdateWithoutSubtasksInput, MemberUncheckedUpdateWithoutSubtasksInput>
    create: XOR<MemberCreateWithoutSubtasksInput, MemberUncheckedCreateWithoutSubtasksInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutSubtasksInput, MemberUncheckedUpdateWithoutSubtasksInput>
  }

  export type MemberUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type FileUpsertWithWhereUniqueWithoutSubtaskInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutSubtaskInput, FileUncheckedUpdateWithoutSubtaskInput>
    create: XOR<FileCreateWithoutSubtaskInput, FileUncheckedCreateWithoutSubtaskInput>
  }

  export type FileUpdateWithWhereUniqueWithoutSubtaskInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutSubtaskInput, FileUncheckedUpdateWithoutSubtaskInput>
  }

  export type FileUpdateManyWithWhereWithoutSubtaskInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutSubtaskInput>
  }

  export type ProjectCreateWithoutFoldersInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themas?: ThemaCreateNestedManyWithoutProjectInput
    epics?: EpicCreateNestedManyWithoutProjectInput
    userStories?: UserStoryCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    files?: FileCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    creator?: MemberCreateNestedOneWithoutCreatedProjectsInput
  }

  export type ProjectUncheckedCreateWithoutFoldersInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId?: string | null
    themas?: ThemaUncheckedCreateNestedManyWithoutProjectInput
    epics?: EpicUncheckedCreateNestedManyWithoutProjectInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    files?: FileUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutFoldersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFoldersInput, ProjectUncheckedCreateWithoutFoldersInput>
  }

  export type FileCreateWithoutFolderInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutFilesInput
    subtask?: SubtaskCreateNestedOneWithoutFilesInput
    sprint?: SprintCreateNestedOneWithoutFilesInput
    uploader: MemberCreateNestedOneWithoutFilesInput
    dependencies?: DependencyCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationCreateNestedManyWithoutToFileInput
  }

  export type FileUncheckedCreateWithoutFolderInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    subtaskId?: string | null
    sprintId?: string | null
    uploaderId: string
    dependencies?: DependencyUncheckedCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationUncheckedCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationUncheckedCreateNestedManyWithoutToFileInput
  }

  export type FileCreateOrConnectWithoutFolderInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput>
  }

  export type FileCreateManyFolderInputEnvelope = {
    data: FileCreateManyFolderInput | FileCreateManyFolderInput[]
  }

  export type ProjectUpsertWithoutFoldersInput = {
    update: XOR<ProjectUpdateWithoutFoldersInput, ProjectUncheckedUpdateWithoutFoldersInput>
    create: XOR<ProjectCreateWithoutFoldersInput, ProjectUncheckedCreateWithoutFoldersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutFoldersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutFoldersInput, ProjectUncheckedUpdateWithoutFoldersInput>
  }

  export type ProjectUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themas?: ThemaUpdateManyWithoutProjectNestedInput
    epics?: EpicUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    files?: FileUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    creator?: MemberUpdateOneWithoutCreatedProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    themas?: ThemaUncheckedUpdateManyWithoutProjectNestedInput
    epics?: EpicUncheckedUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    files?: FileUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type FileUpsertWithWhereUniqueWithoutFolderInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutFolderInput, FileUncheckedUpdateWithoutFolderInput>
    create: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput>
  }

  export type FileUpdateWithWhereUniqueWithoutFolderInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutFolderInput, FileUncheckedUpdateWithoutFolderInput>
  }

  export type FileUpdateManyWithWhereWithoutFolderInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutFolderInput>
  }

  export type FolderCreateWithoutFilesInput = {
    id?: string
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    project: ProjectCreateNestedOneWithoutFoldersInput
  }

  export type FolderUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    projectId: string
  }

  export type FolderCreateOrConnectWithoutFilesInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutFilesInput, FolderUncheckedCreateWithoutFilesInput>
  }

  export type ProjectCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themas?: ThemaCreateNestedManyWithoutProjectInput
    epics?: EpicCreateNestedManyWithoutProjectInput
    userStories?: UserStoryCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    folders?: FolderCreateNestedManyWithoutProjectInput
    comments?: CommentCreateNestedManyWithoutProjectInput
    creator?: MemberCreateNestedOneWithoutCreatedProjectsInput
  }

  export type ProjectUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId?: string | null
    themas?: ThemaUncheckedCreateNestedManyWithoutProjectInput
    epics?: EpicUncheckedCreateNestedManyWithoutProjectInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    folders?: FolderUncheckedCreateNestedManyWithoutProjectInput
    comments?: CommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutFilesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFilesInput, ProjectUncheckedCreateWithoutFilesInput>
  }

  export type SubtaskCreateWithoutFilesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutSubtasksInput
    sprint?: SprintCreateNestedOneWithoutSubtasksInput
    assignee?: MemberCreateNestedOneWithoutSubtasksInput
  }

  export type SubtaskUncheckedCreateWithoutFilesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    taskId: string
    sprintId?: string | null
    assigneeId?: string | null
  }

  export type SubtaskCreateOrConnectWithoutFilesInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutFilesInput, SubtaskUncheckedCreateWithoutFilesInput>
  }

  export type SprintCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    creator: MemberCreateNestedOneWithoutSprintsInput
    userStories?: UserStoryCreateNestedManyWithoutSprintInput
    tasks?: TaskCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    userStories?: UserStoryUncheckedCreateNestedManyWithoutSprintInput
    tasks?: TaskUncheckedCreateNestedManyWithoutSprintInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutFilesInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutFilesInput, SprintUncheckedCreateWithoutFilesInput>
  }

  export type MemberCreateWithoutFilesInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutFilesInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutFilesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutFilesInput, MemberUncheckedCreateWithoutFilesInput>
  }

  export type DependencyCreateWithoutFileInput = {
    id?: string
    componentName: string
    version?: string | null
    createdAt?: Date | string
  }

  export type DependencyUncheckedCreateWithoutFileInput = {
    id?: string
    componentName: string
    version?: string | null
    createdAt?: Date | string
  }

  export type DependencyCreateOrConnectWithoutFileInput = {
    where: DependencyWhereUniqueInput
    create: XOR<DependencyCreateWithoutFileInput, DependencyUncheckedCreateWithoutFileInput>
  }

  export type DependencyCreateManyFileInputEnvelope = {
    data: DependencyCreateManyFileInput | DependencyCreateManyFileInput[]
  }

  export type FileRelationCreateWithoutFromFileInput = {
    id?: string
    type: $Enums.RelationType
    createdAt?: Date | string
    toFile: FileCreateNestedOneWithoutRelationsToInput
  }

  export type FileRelationUncheckedCreateWithoutFromFileInput = {
    id?: string
    toFileId: string
    type: $Enums.RelationType
    createdAt?: Date | string
  }

  export type FileRelationCreateOrConnectWithoutFromFileInput = {
    where: FileRelationWhereUniqueInput
    create: XOR<FileRelationCreateWithoutFromFileInput, FileRelationUncheckedCreateWithoutFromFileInput>
  }

  export type FileRelationCreateManyFromFileInputEnvelope = {
    data: FileRelationCreateManyFromFileInput | FileRelationCreateManyFromFileInput[]
  }

  export type FileRelationCreateWithoutToFileInput = {
    id?: string
    type: $Enums.RelationType
    createdAt?: Date | string
    fromFile: FileCreateNestedOneWithoutRelationsFromInput
  }

  export type FileRelationUncheckedCreateWithoutToFileInput = {
    id?: string
    fromFileId: string
    type: $Enums.RelationType
    createdAt?: Date | string
  }

  export type FileRelationCreateOrConnectWithoutToFileInput = {
    where: FileRelationWhereUniqueInput
    create: XOR<FileRelationCreateWithoutToFileInput, FileRelationUncheckedCreateWithoutToFileInput>
  }

  export type FileRelationCreateManyToFileInputEnvelope = {
    data: FileRelationCreateManyToFileInput | FileRelationCreateManyToFileInput[]
  }

  export type FolderUpsertWithoutFilesInput = {
    update: XOR<FolderUpdateWithoutFilesInput, FolderUncheckedUpdateWithoutFilesInput>
    create: XOR<FolderCreateWithoutFilesInput, FolderUncheckedCreateWithoutFilesInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutFilesInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutFilesInput, FolderUncheckedUpdateWithoutFilesInput>
  }

  export type FolderUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutFoldersNestedInput
  }

  export type FolderUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpsertWithoutFilesInput = {
    update: XOR<ProjectUpdateWithoutFilesInput, ProjectUncheckedUpdateWithoutFilesInput>
    create: XOR<ProjectCreateWithoutFilesInput, ProjectUncheckedCreateWithoutFilesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutFilesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutFilesInput, ProjectUncheckedUpdateWithoutFilesInput>
  }

  export type ProjectUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themas?: ThemaUpdateManyWithoutProjectNestedInput
    epics?: EpicUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    folders?: FolderUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
    creator?: MemberUpdateOneWithoutCreatedProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    themas?: ThemaUncheckedUpdateManyWithoutProjectNestedInput
    epics?: EpicUncheckedUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    folders?: FolderUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type SubtaskUpsertWithoutFilesInput = {
    update: XOR<SubtaskUpdateWithoutFilesInput, SubtaskUncheckedUpdateWithoutFilesInput>
    create: XOR<SubtaskCreateWithoutFilesInput, SubtaskUncheckedCreateWithoutFilesInput>
    where?: SubtaskWhereInput
  }

  export type SubtaskUpdateToOneWithWhereWithoutFilesInput = {
    where?: SubtaskWhereInput
    data: XOR<SubtaskUpdateWithoutFilesInput, SubtaskUncheckedUpdateWithoutFilesInput>
  }

  export type SubtaskUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    sprint?: SprintUpdateOneWithoutSubtasksNestedInput
    assignee?: MemberUpdateOneWithoutSubtasksNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SprintUpsertWithoutFilesInput = {
    update: XOR<SprintUpdateWithoutFilesInput, SprintUncheckedUpdateWithoutFilesInput>
    create: XOR<SprintCreateWithoutFilesInput, SprintUncheckedCreateWithoutFilesInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutFilesInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutFilesInput, SprintUncheckedUpdateWithoutFilesInput>
  }

  export type SprintUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    creator?: MemberUpdateOneRequiredWithoutSprintsNestedInput
    userStories?: UserStoryUpdateManyWithoutSprintNestedInput
    tasks?: TaskUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    userStories?: UserStoryUncheckedUpdateManyWithoutSprintNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type MemberUpsertWithoutFilesInput = {
    update: XOR<MemberUpdateWithoutFilesInput, MemberUncheckedUpdateWithoutFilesInput>
    create: XOR<MemberCreateWithoutFilesInput, MemberUncheckedCreateWithoutFilesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutFilesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutFilesInput, MemberUncheckedUpdateWithoutFilesInput>
  }

  export type MemberUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DependencyUpsertWithWhereUniqueWithoutFileInput = {
    where: DependencyWhereUniqueInput
    update: XOR<DependencyUpdateWithoutFileInput, DependencyUncheckedUpdateWithoutFileInput>
    create: XOR<DependencyCreateWithoutFileInput, DependencyUncheckedCreateWithoutFileInput>
  }

  export type DependencyUpdateWithWhereUniqueWithoutFileInput = {
    where: DependencyWhereUniqueInput
    data: XOR<DependencyUpdateWithoutFileInput, DependencyUncheckedUpdateWithoutFileInput>
  }

  export type DependencyUpdateManyWithWhereWithoutFileInput = {
    where: DependencyScalarWhereInput
    data: XOR<DependencyUpdateManyMutationInput, DependencyUncheckedUpdateManyWithoutFileInput>
  }

  export type DependencyScalarWhereInput = {
    AND?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
    OR?: DependencyScalarWhereInput[]
    NOT?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
    id?: StringFilter<"Dependency"> | string
    fileId?: StringFilter<"Dependency"> | string
    componentName?: StringFilter<"Dependency"> | string
    version?: StringNullableFilter<"Dependency"> | string | null
    createdAt?: DateTimeFilter<"Dependency"> | Date | string
  }

  export type FileRelationUpsertWithWhereUniqueWithoutFromFileInput = {
    where: FileRelationWhereUniqueInput
    update: XOR<FileRelationUpdateWithoutFromFileInput, FileRelationUncheckedUpdateWithoutFromFileInput>
    create: XOR<FileRelationCreateWithoutFromFileInput, FileRelationUncheckedCreateWithoutFromFileInput>
  }

  export type FileRelationUpdateWithWhereUniqueWithoutFromFileInput = {
    where: FileRelationWhereUniqueInput
    data: XOR<FileRelationUpdateWithoutFromFileInput, FileRelationUncheckedUpdateWithoutFromFileInput>
  }

  export type FileRelationUpdateManyWithWhereWithoutFromFileInput = {
    where: FileRelationScalarWhereInput
    data: XOR<FileRelationUpdateManyMutationInput, FileRelationUncheckedUpdateManyWithoutFromFileInput>
  }

  export type FileRelationScalarWhereInput = {
    AND?: FileRelationScalarWhereInput | FileRelationScalarWhereInput[]
    OR?: FileRelationScalarWhereInput[]
    NOT?: FileRelationScalarWhereInput | FileRelationScalarWhereInput[]
    id?: StringFilter<"FileRelation"> | string
    fromFileId?: StringFilter<"FileRelation"> | string
    toFileId?: StringFilter<"FileRelation"> | string
    type?: EnumRelationTypeFilter<"FileRelation"> | $Enums.RelationType
    createdAt?: DateTimeFilter<"FileRelation"> | Date | string
  }

  export type FileRelationUpsertWithWhereUniqueWithoutToFileInput = {
    where: FileRelationWhereUniqueInput
    update: XOR<FileRelationUpdateWithoutToFileInput, FileRelationUncheckedUpdateWithoutToFileInput>
    create: XOR<FileRelationCreateWithoutToFileInput, FileRelationUncheckedCreateWithoutToFileInput>
  }

  export type FileRelationUpdateWithWhereUniqueWithoutToFileInput = {
    where: FileRelationWhereUniqueInput
    data: XOR<FileRelationUpdateWithoutToFileInput, FileRelationUncheckedUpdateWithoutToFileInput>
  }

  export type FileRelationUpdateManyWithWhereWithoutToFileInput = {
    where: FileRelationScalarWhereInput
    data: XOR<FileRelationUpdateManyMutationInput, FileRelationUncheckedUpdateManyWithoutToFileInput>
  }

  export type FileCreateWithoutDependenciesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: FolderCreateNestedOneWithoutFilesInput
    project: ProjectCreateNestedOneWithoutFilesInput
    subtask?: SubtaskCreateNestedOneWithoutFilesInput
    sprint?: SprintCreateNestedOneWithoutFilesInput
    uploader: MemberCreateNestedOneWithoutFilesInput
    relationsFrom?: FileRelationCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationCreateNestedManyWithoutToFileInput
  }

  export type FileUncheckedCreateWithoutDependenciesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    projectId: string
    subtaskId?: string | null
    sprintId?: string | null
    uploaderId: string
    relationsFrom?: FileRelationUncheckedCreateNestedManyWithoutFromFileInput
    relationsTo?: FileRelationUncheckedCreateNestedManyWithoutToFileInput
  }

  export type FileCreateOrConnectWithoutDependenciesInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutDependenciesInput, FileUncheckedCreateWithoutDependenciesInput>
  }

  export type FileUpsertWithoutDependenciesInput = {
    update: XOR<FileUpdateWithoutDependenciesInput, FileUncheckedUpdateWithoutDependenciesInput>
    create: XOR<FileCreateWithoutDependenciesInput, FileUncheckedCreateWithoutDependenciesInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutDependenciesInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutDependenciesInput, FileUncheckedUpdateWithoutDependenciesInput>
  }

  export type FileUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutFilesNestedInput
    project?: ProjectUpdateOneRequiredWithoutFilesNestedInput
    subtask?: SubtaskUpdateOneWithoutFilesNestedInput
    sprint?: SprintUpdateOneWithoutFilesNestedInput
    uploader?: MemberUpdateOneRequiredWithoutFilesNestedInput
    relationsFrom?: FileRelationUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    relationsFrom?: FileRelationUncheckedUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUncheckedUpdateManyWithoutToFileNestedInput
  }

  export type FileCreateWithoutRelationsFromInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: FolderCreateNestedOneWithoutFilesInput
    project: ProjectCreateNestedOneWithoutFilesInput
    subtask?: SubtaskCreateNestedOneWithoutFilesInput
    sprint?: SprintCreateNestedOneWithoutFilesInput
    uploader: MemberCreateNestedOneWithoutFilesInput
    dependencies?: DependencyCreateNestedManyWithoutFileInput
    relationsTo?: FileRelationCreateNestedManyWithoutToFileInput
  }

  export type FileUncheckedCreateWithoutRelationsFromInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    projectId: string
    subtaskId?: string | null
    sprintId?: string | null
    uploaderId: string
    dependencies?: DependencyUncheckedCreateNestedManyWithoutFileInput
    relationsTo?: FileRelationUncheckedCreateNestedManyWithoutToFileInput
  }

  export type FileCreateOrConnectWithoutRelationsFromInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutRelationsFromInput, FileUncheckedCreateWithoutRelationsFromInput>
  }

  export type FileCreateWithoutRelationsToInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: FolderCreateNestedOneWithoutFilesInput
    project: ProjectCreateNestedOneWithoutFilesInput
    subtask?: SubtaskCreateNestedOneWithoutFilesInput
    sprint?: SprintCreateNestedOneWithoutFilesInput
    uploader: MemberCreateNestedOneWithoutFilesInput
    dependencies?: DependencyCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationCreateNestedManyWithoutFromFileInput
  }

  export type FileUncheckedCreateWithoutRelationsToInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    projectId: string
    subtaskId?: string | null
    sprintId?: string | null
    uploaderId: string
    dependencies?: DependencyUncheckedCreateNestedManyWithoutFileInput
    relationsFrom?: FileRelationUncheckedCreateNestedManyWithoutFromFileInput
  }

  export type FileCreateOrConnectWithoutRelationsToInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutRelationsToInput, FileUncheckedCreateWithoutRelationsToInput>
  }

  export type FileUpsertWithoutRelationsFromInput = {
    update: XOR<FileUpdateWithoutRelationsFromInput, FileUncheckedUpdateWithoutRelationsFromInput>
    create: XOR<FileCreateWithoutRelationsFromInput, FileUncheckedCreateWithoutRelationsFromInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutRelationsFromInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutRelationsFromInput, FileUncheckedUpdateWithoutRelationsFromInput>
  }

  export type FileUpdateWithoutRelationsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutFilesNestedInput
    project?: ProjectUpdateOneRequiredWithoutFilesNestedInput
    subtask?: SubtaskUpdateOneWithoutFilesNestedInput
    sprint?: SprintUpdateOneWithoutFilesNestedInput
    uploader?: MemberUpdateOneRequiredWithoutFilesNestedInput
    dependencies?: DependencyUpdateManyWithoutFileNestedInput
    relationsTo?: FileRelationUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateWithoutRelationsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    dependencies?: DependencyUncheckedUpdateManyWithoutFileNestedInput
    relationsTo?: FileRelationUncheckedUpdateManyWithoutToFileNestedInput
  }

  export type FileUpsertWithoutRelationsToInput = {
    update: XOR<FileUpdateWithoutRelationsToInput, FileUncheckedUpdateWithoutRelationsToInput>
    create: XOR<FileCreateWithoutRelationsToInput, FileUncheckedCreateWithoutRelationsToInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutRelationsToInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutRelationsToInput, FileUncheckedUpdateWithoutRelationsToInput>
  }

  export type FileUpdateWithoutRelationsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutFilesNestedInput
    project?: ProjectUpdateOneRequiredWithoutFilesNestedInput
    subtask?: SubtaskUpdateOneWithoutFilesNestedInput
    sprint?: SprintUpdateOneWithoutFilesNestedInput
    uploader?: MemberUpdateOneRequiredWithoutFilesNestedInput
    dependencies?: DependencyUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUpdateManyWithoutFromFileNestedInput
  }

  export type FileUncheckedUpdateWithoutRelationsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    dependencies?: DependencyUncheckedUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUncheckedUpdateManyWithoutFromFileNestedInput
  }

  export type MemberCreateWithoutCommentsInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutCommentsInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutCommentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
  }

  export type ProjectCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themas?: ThemaCreateNestedManyWithoutProjectInput
    epics?: EpicCreateNestedManyWithoutProjectInput
    userStories?: UserStoryCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    members?: MemberCreateNestedManyWithoutProjectInput
    folders?: FolderCreateNestedManyWithoutProjectInput
    files?: FileCreateNestedManyWithoutProjectInput
    creator?: MemberCreateNestedOneWithoutCreatedProjectsInput
  }

  export type ProjectUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId?: string | null
    themas?: ThemaUncheckedCreateNestedManyWithoutProjectInput
    epics?: EpicUncheckedCreateNestedManyWithoutProjectInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    members?: MemberUncheckedCreateNestedManyWithoutProjectInput
    folders?: FolderUncheckedCreateNestedManyWithoutProjectInput
    files?: FileUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCommentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
  }

  export type ThemaCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutThemasInput
    creator: MemberCreateNestedOneWithoutThemasInput
    tasks?: TaskCreateNestedManyWithoutThemaInput
  }

  export type ThemaUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    tasks?: TaskUncheckedCreateNestedManyWithoutThemaInput
  }

  export type ThemaCreateOrConnectWithoutCommentsInput = {
    where: ThemaWhereUniqueInput
    create: XOR<ThemaCreateWithoutCommentsInput, ThemaUncheckedCreateWithoutCommentsInput>
  }

  export type EpicCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutEpicsInput
    creator: MemberCreateNestedOneWithoutEpicsInput
    userStories?: UserStoryCreateNestedManyWithoutEpicInput
  }

  export type EpicUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    userStories?: UserStoryUncheckedCreateNestedManyWithoutEpicInput
  }

  export type EpicCreateOrConnectWithoutCommentsInput = {
    where: EpicWhereUniqueInput
    create: XOR<EpicCreateWithoutCommentsInput, EpicUncheckedCreateWithoutCommentsInput>
  }

  export type UserStoryCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUserStoriesInput
    epic?: EpicCreateNestedOneWithoutUserStoriesInput
    creator: MemberCreateNestedOneWithoutUserStoriesInput
    sprint?: SprintCreateNestedOneWithoutUserStoriesInput
    tasks?: TaskCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    epicId?: string | null
    creatorId: string
    sprintId?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutUserStoryInput
  }

  export type UserStoryCreateOrConnectWithoutCommentsInput = {
    where: UserStoryWhereUniqueInput
    create: XOR<UserStoryCreateWithoutCommentsInput, UserStoryUncheckedCreateWithoutCommentsInput>
  }

  export type TaskCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thema?: ThemaCreateNestedOneWithoutTasksInput
    userStory?: UserStoryCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    assignee?: MemberCreateNestedOneWithoutTasksInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    dependencies?: TaskCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskCreateNestedManyWithoutDependenciesInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    userStoryId?: string | null
    sprintId?: string | null
    assigneeId?: string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    dependencies?: TaskUncheckedCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskUncheckedCreateNestedManyWithoutDependenciesInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCommentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
  }

  export type MemberUpsertWithoutCommentsInput = {
    update: XOR<MemberUpdateWithoutCommentsInput, MemberUncheckedUpdateWithoutCommentsInput>
    create: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutCommentsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutCommentsInput, MemberUncheckedUpdateWithoutCommentsInput>
  }

  export type MemberUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectUpsertWithoutCommentsInput = {
    update: XOR<ProjectUpdateWithoutCommentsInput, ProjectUncheckedUpdateWithoutCommentsInput>
    create: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCommentsInput, ProjectUncheckedUpdateWithoutCommentsInput>
  }

  export type ProjectUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themas?: ThemaUpdateManyWithoutProjectNestedInput
    epics?: EpicUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    folders?: FolderUpdateManyWithoutProjectNestedInput
    files?: FileUpdateManyWithoutProjectNestedInput
    creator?: MemberUpdateOneWithoutCreatedProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    themas?: ThemaUncheckedUpdateManyWithoutProjectNestedInput
    epics?: EpicUncheckedUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    folders?: FolderUncheckedUpdateManyWithoutProjectNestedInput
    files?: FileUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ThemaUpsertWithoutCommentsInput = {
    update: XOR<ThemaUpdateWithoutCommentsInput, ThemaUncheckedUpdateWithoutCommentsInput>
    create: XOR<ThemaCreateWithoutCommentsInput, ThemaUncheckedCreateWithoutCommentsInput>
    where?: ThemaWhereInput
  }

  export type ThemaUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ThemaWhereInput
    data: XOR<ThemaUpdateWithoutCommentsInput, ThemaUncheckedUpdateWithoutCommentsInput>
  }

  export type ThemaUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutThemasNestedInput
    creator?: MemberUpdateOneRequiredWithoutThemasNestedInput
    tasks?: TaskUpdateManyWithoutThemaNestedInput
  }

  export type ThemaUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutThemaNestedInput
  }

  export type EpicUpsertWithoutCommentsInput = {
    update: XOR<EpicUpdateWithoutCommentsInput, EpicUncheckedUpdateWithoutCommentsInput>
    create: XOR<EpicCreateWithoutCommentsInput, EpicUncheckedCreateWithoutCommentsInput>
    where?: EpicWhereInput
  }

  export type EpicUpdateToOneWithWhereWithoutCommentsInput = {
    where?: EpicWhereInput
    data: XOR<EpicUpdateWithoutCommentsInput, EpicUncheckedUpdateWithoutCommentsInput>
  }

  export type EpicUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutEpicsNestedInput
    creator?: MemberUpdateOneRequiredWithoutEpicsNestedInput
    userStories?: UserStoryUpdateManyWithoutEpicNestedInput
  }

  export type EpicUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    userStories?: UserStoryUncheckedUpdateManyWithoutEpicNestedInput
  }

  export type UserStoryUpsertWithoutCommentsInput = {
    update: XOR<UserStoryUpdateWithoutCommentsInput, UserStoryUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserStoryCreateWithoutCommentsInput, UserStoryUncheckedCreateWithoutCommentsInput>
    where?: UserStoryWhereInput
  }

  export type UserStoryUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserStoryWhereInput
    data: XOR<UserStoryUpdateWithoutCommentsInput, UserStoryUncheckedUpdateWithoutCommentsInput>
  }

  export type UserStoryUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUserStoriesNestedInput
    epic?: EpicUpdateOneWithoutUserStoriesNestedInput
    creator?: MemberUpdateOneRequiredWithoutUserStoriesNestedInput
    sprint?: SprintUpdateOneWithoutUserStoriesNestedInput
    tasks?: TaskUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutUserStoryNestedInput
  }

  export type TaskUpsertWithoutCommentsInput = {
    update: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type TaskUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thema?: ThemaUpdateOneWithoutTasksNestedInput
    userStory?: UserStoryUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    assignee?: MemberUpdateOneWithoutTasksNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUpdateManyWithoutDependenciesNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUncheckedUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUncheckedUpdateManyWithoutDependenciesNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateWithoutTimeLogsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thema?: ThemaCreateNestedOneWithoutTasksInput
    userStory?: UserStoryCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    assignee?: MemberCreateNestedOneWithoutTasksInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    dependencies?: TaskCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskCreateNestedManyWithoutDependenciesInput
    comments?: CommentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTimeLogsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    userStoryId?: string | null
    sprintId?: string | null
    assigneeId?: string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    dependencies?: TaskUncheckedCreateNestedManyWithoutBlockedByInput
    blockedBy?: TaskUncheckedCreateNestedManyWithoutDependenciesInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTimeLogsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
  }

  export type MemberCreateWithoutTimeLogsInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutTimeLogsInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutMemberInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutTimeLogsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutTimeLogsInput, MemberUncheckedCreateWithoutTimeLogsInput>
  }

  export type TaskUpsertWithoutTimeLogsInput = {
    update: XOR<TaskUpdateWithoutTimeLogsInput, TaskUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTimeLogsInput, TaskUncheckedUpdateWithoutTimeLogsInput>
  }

  export type TaskUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thema?: ThemaUpdateOneWithoutTasksNestedInput
    userStory?: UserStoryUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    assignee?: MemberUpdateOneWithoutTasksNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUncheckedUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUncheckedUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type MemberUpsertWithoutTimeLogsInput = {
    update: XOR<MemberUpdateWithoutTimeLogsInput, MemberUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<MemberCreateWithoutTimeLogsInput, MemberUncheckedCreateWithoutTimeLogsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutTimeLogsInput, MemberUncheckedUpdateWithoutTimeLogsInput>
  }

  export type MemberUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MemberCreateWithoutActivitiesInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    project: ProjectCreateNestedOneWithoutMembersInput
    files?: FileCreateNestedManyWithoutUploaderInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogCreateNestedManyWithoutMemberInput
    userStories?: UserStoryCreateNestedManyWithoutCreatorInput
    themas?: ThemaCreateNestedManyWithoutCreatorInput
    epics?: EpicCreateNestedManyWithoutCreatorInput
    sprints?: SprintCreateNestedManyWithoutCreatorInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
  }

  export type MemberUncheckedCreateWithoutActivitiesInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
    files?: FileUncheckedCreateNestedManyWithoutUploaderInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutMemberInput
    userStories?: UserStoryUncheckedCreateNestedManyWithoutCreatorInput
    themas?: ThemaUncheckedCreateNestedManyWithoutCreatorInput
    epics?: EpicUncheckedCreateNestedManyWithoutCreatorInput
    sprints?: SprintUncheckedCreateNestedManyWithoutCreatorInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type MemberCreateOrConnectWithoutActivitiesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutActivitiesInput, MemberUncheckedCreateWithoutActivitiesInput>
  }

  export type MemberUpsertWithoutActivitiesInput = {
    update: XOR<MemberUpdateWithoutActivitiesInput, MemberUncheckedUpdateWithoutActivitiesInput>
    create: XOR<MemberCreateWithoutActivitiesInput, MemberUncheckedCreateWithoutActivitiesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutActivitiesInput, MemberUncheckedUpdateWithoutActivitiesInput>
  }

  export type MemberUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberCreateManyUserInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type VerificationCreateManyUserInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemaCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
  }

  export type EpicCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
  }

  export type UserStoryCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    epicId?: string | null
    creatorId: string
    sprintId?: string | null
  }

  export type SprintCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
  }

  export type MemberCreateManyProjectInput = {
    id?: string
    role?: $Enums.Role
    joinedAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type FolderCreateManyProjectInput = {
    id?: string
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type FileCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    subtaskId?: string | null
    sprintId?: string | null
    uploaderId: string
  }

  export type CommentCreateManyProjectInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    themaId?: string | null
    epicId?: string | null
    userStoryId?: string | null
    taskId?: string | null
  }

  export type ThemaUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: MemberUpdateOneRequiredWithoutThemasNestedInput
    tasks?: TaskUpdateManyWithoutThemaNestedInput
    comments?: CommentUpdateManyWithoutThemaNestedInput
  }

  export type ThemaUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutThemaNestedInput
    comments?: CommentUncheckedUpdateManyWithoutThemaNestedInput
  }

  export type ThemaUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type EpicUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: MemberUpdateOneRequiredWithoutEpicsNestedInput
    userStories?: UserStoryUpdateManyWithoutEpicNestedInput
    comments?: CommentUpdateManyWithoutEpicNestedInput
  }

  export type EpicUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    userStories?: UserStoryUncheckedUpdateManyWithoutEpicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutEpicNestedInput
  }

  export type EpicUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type UserStoryUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    epic?: EpicUpdateOneWithoutUserStoriesNestedInput
    creator?: MemberUpdateOneRequiredWithoutUserStoriesNestedInput
    sprint?: SprintUpdateOneWithoutUserStoriesNestedInput
    tasks?: TaskUpdateManyWithoutUserStoryNestedInput
    comments?: CommentUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutUserStoryNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SprintUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: MemberUpdateOneRequiredWithoutSprintsNestedInput
    userStories?: UserStoryUpdateManyWithoutSprintNestedInput
    tasks?: TaskUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUpdateManyWithoutSprintNestedInput
    files?: FileUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    userStories?: UserStoryUncheckedUpdateManyWithoutSprintNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutSprintNestedInput
    files?: FileUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type MemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    files?: FileUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUpdateManyWithoutCreatorNestedInput
    epics?: EpicUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutUploaderNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutMemberNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutCreatorNestedInput
    themas?: ThemaUncheckedUpdateManyWithoutCreatorNestedInput
    epics?: EpicUncheckedUpdateManyWithoutCreatorNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutCreatorNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutMemberNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FolderUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutFilesNestedInput
    subtask?: SubtaskUpdateOneWithoutFilesNestedInput
    sprint?: SprintUpdateOneWithoutFilesNestedInput
    uploader?: MemberUpdateOneRequiredWithoutFilesNestedInput
    dependencies?: DependencyUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    dependencies?: DependencyUncheckedUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUncheckedUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUncheckedUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    thema?: ThemaUpdateOneWithoutCommentsNestedInput
    epic?: EpicUpdateOneWithoutCommentsNestedInput
    userStory?: UserStoryUpdateOneWithoutCommentsNestedInput
    task?: TaskUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileCreateManyUploaderInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    projectId: string
    subtaskId?: string | null
    sprintId?: string | null
  }

  export type TaskCreateManyAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    userStoryId?: string | null
    sprintId?: string | null
  }

  export type SubtaskCreateManyAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    taskId: string
    sprintId?: string | null
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string | null
    themaId?: string | null
    epicId?: string | null
    userStoryId?: string | null
    taskId?: string | null
  }

  export type TimeLogCreateManyMemberInput = {
    id?: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    taskId: string
  }

  export type UserStoryCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    epicId?: string | null
    sprintId?: string | null
  }

  export type ThemaCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type EpicCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type SprintCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ActivityLogCreateManyMemberInput = {
    id?: string
    action: $Enums.ActionType
    entityId: string
    timestamp?: Date | string
  }

  export type ProjectCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    status?: $Enums.Status
    priority?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutFilesNestedInput
    project?: ProjectUpdateOneRequiredWithoutFilesNestedInput
    subtask?: SubtaskUpdateOneWithoutFilesNestedInput
    sprint?: SprintUpdateOneWithoutFilesNestedInput
    dependencies?: DependencyUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: DependencyUncheckedUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUncheckedUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUncheckedUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thema?: ThemaUpdateOneWithoutTasksNestedInput
    userStory?: UserStoryUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUncheckedUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUncheckedUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubtaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    sprint?: SprintUpdateOneWithoutSubtasksNestedInput
    files?: FileUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutCommentsNestedInput
    thema?: ThemaUpdateOneWithoutCommentsNestedInput
    epic?: EpicUpdateOneWithoutCommentsNestedInput
    userStory?: UserStoryUpdateOneWithoutCommentsNestedInput
    task?: TaskUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeLogUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type UserStoryUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUserStoriesNestedInput
    epic?: EpicUpdateOneWithoutUserStoriesNestedInput
    sprint?: SprintUpdateOneWithoutUserStoriesNestedInput
    tasks?: TaskUpdateManyWithoutUserStoryNestedInput
    comments?: CommentUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutUserStoryNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThemaUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutThemasNestedInput
    tasks?: TaskUpdateManyWithoutThemaNestedInput
    comments?: CommentUpdateManyWithoutThemaNestedInput
  }

  export type ThemaUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutThemaNestedInput
    comments?: CommentUncheckedUpdateManyWithoutThemaNestedInput
  }

  export type ThemaUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type EpicUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutEpicsNestedInput
    userStories?: UserStoryUpdateManyWithoutEpicNestedInput
    comments?: CommentUpdateManyWithoutEpicNestedInput
  }

  export type EpicUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userStories?: UserStoryUncheckedUpdateManyWithoutEpicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutEpicNestedInput
  }

  export type EpicUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type SprintUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    userStories?: UserStoryUpdateManyWithoutSprintNestedInput
    tasks?: TaskUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUpdateManyWithoutSprintNestedInput
    files?: FileUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userStories?: UserStoryUncheckedUpdateManyWithoutSprintNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutSprintNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutSprintNestedInput
    files?: FileUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityLogUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entityId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entityId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entityId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themas?: ThemaUpdateManyWithoutProjectNestedInput
    epics?: EpicUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    members?: MemberUpdateManyWithoutProjectNestedInput
    folders?: FolderUpdateManyWithoutProjectNestedInput
    files?: FileUpdateManyWithoutProjectNestedInput
    comments?: CommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themas?: ThemaUncheckedUpdateManyWithoutProjectNestedInput
    epics?: EpicUncheckedUpdateManyWithoutProjectNestedInput
    userStories?: UserStoryUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    members?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    folders?: FolderUncheckedUpdateManyWithoutProjectNestedInput
    files?: FileUncheckedUpdateManyWithoutProjectNestedInput
    comments?: CommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyThemaInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userStoryId?: string | null
    sprintId?: string | null
    assigneeId?: string | null
  }

  export type CommentCreateManyThemaInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    projectId?: string | null
    epicId?: string | null
    userStoryId?: string | null
    taskId?: string | null
  }

  export type TaskUpdateWithoutThemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStory?: UserStoryUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    assignee?: MemberUpdateOneWithoutTasksNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutThemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUncheckedUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUncheckedUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutThemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutThemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    project?: ProjectUpdateOneWithoutCommentsNestedInput
    epic?: EpicUpdateOneWithoutCommentsNestedInput
    userStory?: UserStoryUpdateOneWithoutCommentsNestedInput
    task?: TaskUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutThemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyWithoutThemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserStoryCreateManyEpicInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    creatorId: string
    sprintId?: string | null
  }

  export type CommentCreateManyEpicInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    projectId?: string | null
    themaId?: string | null
    userStoryId?: string | null
    taskId?: string | null
  }

  export type UserStoryUpdateWithoutEpicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUserStoriesNestedInput
    creator?: MemberUpdateOneRequiredWithoutUserStoriesNestedInput
    sprint?: SprintUpdateOneWithoutUserStoriesNestedInput
    tasks?: TaskUpdateManyWithoutUserStoryNestedInput
    comments?: CommentUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryUncheckedUpdateWithoutEpicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutUserStoryNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryUncheckedUpdateManyWithoutEpicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutEpicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    project?: ProjectUpdateOneWithoutCommentsNestedInput
    thema?: ThemaUpdateOneWithoutCommentsNestedInput
    userStory?: UserStoryUpdateOneWithoutCommentsNestedInput
    task?: TaskUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutEpicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyWithoutEpicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyUserStoryInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    sprintId?: string | null
    assigneeId?: string | null
  }

  export type CommentCreateManyUserStoryInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    projectId?: string | null
    themaId?: string | null
    epicId?: string | null
    taskId?: string | null
  }

  export type TaskUpdateWithoutUserStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thema?: ThemaUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    assignee?: MemberUpdateOneWithoutTasksNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutUserStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUncheckedUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUncheckedUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutUserStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutUserStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    project?: ProjectUpdateOneWithoutCommentsNestedInput
    thema?: ThemaUpdateOneWithoutCommentsNestedInput
    epic?: EpicUpdateOneWithoutCommentsNestedInput
    task?: TaskUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyWithoutUserStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserStoryCreateManySprintInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    epicId?: string | null
    creatorId: string
  }

  export type TaskCreateManySprintInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    priority?: number
    dueDate?: Date | string | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    themaId?: string | null
    userStoryId?: string | null
    assigneeId?: string | null
  }

  export type SubtaskCreateManySprintInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    taskId: string
    assigneeId?: string | null
  }

  export type FileCreateManySprintInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    projectId: string
    subtaskId?: string | null
    uploaderId: string
  }

  export type UserStoryUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUserStoriesNestedInput
    epic?: EpicUpdateOneWithoutUserStoriesNestedInput
    creator?: MemberUpdateOneRequiredWithoutUserStoriesNestedInput
    tasks?: TaskUpdateManyWithoutUserStoryNestedInput
    comments?: CommentUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutUserStoryNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserStoryNestedInput
  }

  export type UserStoryUncheckedUpdateManyWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thema?: ThemaUpdateOneWithoutTasksNestedInput
    userStory?: UserStoryUpdateOneWithoutTasksNestedInput
    assignee?: MemberUpdateOneWithoutTasksNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUncheckedUpdateManyWithoutBlockedByNestedInput
    blockedBy?: TaskUncheckedUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubtaskUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    assignee?: MemberUpdateOneWithoutSubtasksNestedInput
    files?: FileUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateManyWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutFilesNestedInput
    project?: ProjectUpdateOneRequiredWithoutFilesNestedInput
    subtask?: SubtaskUpdateOneWithoutFilesNestedInput
    uploader?: MemberUpdateOneRequiredWithoutFilesNestedInput
    dependencies?: DependencyUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    dependencies?: DependencyUncheckedUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUncheckedUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUncheckedUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
  }

  export type SubtaskCreateManyTaskInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sprintId?: string | null
    assigneeId?: string | null
  }

  export type CommentCreateManyTaskInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    projectId?: string | null
    themaId?: string | null
    epicId?: string | null
    userStoryId?: string | null
  }

  export type TimeLogCreateManyTaskInput = {
    id?: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    memberId: string
  }

  export type SubtaskUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sprint?: SprintUpdateOneWithoutSubtasksNestedInput
    assignee?: MemberUpdateOneWithoutSubtasksNestedInput
    files?: FileUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutBlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thema?: ThemaUpdateOneWithoutTasksNestedInput
    userStory?: UserStoryUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    assignee?: MemberUpdateOneWithoutTasksNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUpdateManyWithoutBlockedByNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutBlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    dependencies?: TaskUncheckedUpdateManyWithoutBlockedByNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutBlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thema?: ThemaUpdateOneWithoutTasksNestedInput
    userStory?: UserStoryUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    assignee?: MemberUpdateOneWithoutTasksNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    blockedBy?: TaskUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    blockedBy?: TaskUncheckedUpdateManyWithoutDependenciesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    priority?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    project?: ProjectUpdateOneWithoutCommentsNestedInput
    thema?: ThemaUpdateOneWithoutCommentsNestedInput
    epic?: EpicUpdateOneWithoutCommentsNestedInput
    userStory?: UserStoryUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    themaId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    userStoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeLogUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type FileCreateManySubtaskInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    folderId?: string | null
    projectId: string
    sprintId?: string | null
    uploaderId: string
  }

  export type FileUpdateWithoutSubtaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutFilesNestedInput
    project?: ProjectUpdateOneRequiredWithoutFilesNestedInput
    sprint?: SprintUpdateOneWithoutFilesNestedInput
    uploader?: MemberUpdateOneRequiredWithoutFilesNestedInput
    dependencies?: DependencyUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateWithoutSubtaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    dependencies?: DependencyUncheckedUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUncheckedUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUncheckedUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutSubtaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
  }

  export type FileCreateManyFolderInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.FileType
    size: number
    url: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    subtaskId?: string | null
    sprintId?: string | null
    uploaderId: string
  }

  export type FileUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutFilesNestedInput
    subtask?: SubtaskUpdateOneWithoutFilesNestedInput
    sprint?: SprintUpdateOneWithoutFilesNestedInput
    uploader?: MemberUpdateOneRequiredWithoutFilesNestedInput
    dependencies?: DependencyUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
    dependencies?: DependencyUncheckedUpdateManyWithoutFileNestedInput
    relationsFrom?: FileRelationUncheckedUpdateManyWithoutFromFileNestedInput
    relationsTo?: FileRelationUncheckedUpdateManyWithoutToFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    subtaskId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: StringFieldUpdateOperationsInput | string
  }

  export type DependencyCreateManyFileInput = {
    id?: string
    componentName: string
    version?: string | null
    createdAt?: Date | string
  }

  export type FileRelationCreateManyFromFileInput = {
    id?: string
    toFileId: string
    type: $Enums.RelationType
    createdAt?: Date | string
  }

  export type FileRelationCreateManyToFileInput = {
    id?: string
    fromFileId: string
    type: $Enums.RelationType
    createdAt?: Date | string
  }

  export type DependencyUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentName?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependencyUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentName?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependencyUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentName?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileRelationUpdateWithoutFromFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toFile?: FileUpdateOneRequiredWithoutRelationsToNestedInput
  }

  export type FileRelationUncheckedUpdateWithoutFromFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    toFileId?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileRelationUncheckedUpdateManyWithoutFromFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    toFileId?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileRelationUpdateWithoutToFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFile?: FileUpdateOneRequiredWithoutRelationsFromNestedInput
  }

  export type FileRelationUncheckedUpdateWithoutToFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromFileId?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileRelationUncheckedUpdateManyWithoutToFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromFileId?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}